#pragma config(Sensor, dgtl3,  liftEncoderRight,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftEncoderLeft,     sensorQuadEncoder)
#pragma config(Motor,  port4,           LiftL,         tmotorNormal, openLoop)
#pragma config(Motor,  port7,           LiftR,         tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	float Kp = 0.5;
	float Ki = 0;
	float Kd = 0.05; //0.5;
	float Integral;
	float Derivative;
	float Error;
	float LastError;
	float TargetValue;
	float Tp = 0;
	float Output;
	int LeftEncoder;
	int RightEncoder;
	int lift_height;
	int height_setting;
	SensorValue[liftEncoderLeft] = 0;
	SensorValue[liftEncoderRight] = 0;
	height_setting = 0;
	while (true)
	{
		if (vexRT[Btn5D])
		{
			SensorValue[liftEncoderLeft] = 0;
			SensorValue[liftEncoderRight] = 0;
		}
//----------------------------------button settings--------------------------------------\\
		if(vexRT[Btn7D]==1)
		{
			if(height_setting==1)
			{
				lift_height=0;
				height_setting=0;
				while(vexRT[btn7D]==1);
			}
			else
			{
				//lift height = first goal setting//
				height_setting=1;
				while(vexRT[btn7D]==1);
			}
		}
		if(vexRT[Btn7L]==1)
		{
			if(height_setting==2)
			{
				lift_height=0;
				height_setting=0;
				while(vexRT[btn7L]==1);
			}
			else
			{
				//lift height = second goal setting//
				height_setting=2;
				while(vexRT[btn7L]==1);
			}
		}
		if(vexRT[Btn7U]==1)
		{
			if(height_setting==3)
			{
				lift_height=0;
				height_setting=0;
				while(vexRT[btn7U]==1);
			}
			else
			{
				//lift height = third goal setting//
				height_setting=3;
				while(vexRT[btn7U]==1);
			}
		}

//----------------------------------end-------------------------------------------------\\


		Tp = 0 - vexRT[Ch3];
		LeftEncoder = SensorValue[liftEncoderLeft];
		RightEncoder = SensorValue[liftEncoderRight];
		Error = SensorValue[liftEncoderRight] - SensorValue[liftEncoderLeft];
		Integral = Integral * (3 / 4) + Error;
		Derivative = Error - LastError;
		Output = Kp * Error + Ki * Integral + Kd * Derivative;
		LastError = Error;
		motor[LiftL] = Tp - Output;
		motor[LiftR] = Tp + Output;
		//motor[LiftL] = Tp;
		//motor[LiftR] = Tp;
		wait1Msec(70);
	}
}
