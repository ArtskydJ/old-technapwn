#pragma config(UART_Usage, UART2, VEX_2x16_LCD, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro,                sensorGyro)
#pragma config(Sensor, dgtl1,  liftEncoderRight,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftEncoderLeft,     sensorQuadEncoder)
#pragma config(Sensor, dgtl12, AutonomousJumperPort, sensorDigitalIn)
#pragma config(Motor,  port1,           DriveBL,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port2,           IntakeL,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           LiftBR,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           LiftFL,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port5,           DriveFR,       tmotorNormal, openLoop)
#pragma config(Motor,  port6,           DriveFL,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           LiftBL,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           LiftFR,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port9,           IntakeR,       tmotorNormal, openLoop)
#pragma config(Motor,  port10,          DriveBR,       tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int MotorFrontLeft;
int MotorBackLeft;
int MotorFrontRight;
int MotorBackRight;

task main()
{
	float Kp = 1.5;
	float Ki = 0;
	float Kd = 0; //0.5;
	float Integral;
	float Derivative;
	float Error;
	float LastError;
	float TargetValue;
	float Tp = 0;
	float Output;
	int LeftEncoder;
	int RightEncoder;
	SensorValue[liftEncoderLeft] = 0;
	SensorValue[liftEncoderRight] = 0;
	while (true)
	{
		if (vexRT[Btn5D])
		{
			SensorValue[liftEncoderLeft] = 0;
			SensorValue[liftEncoderRight] = 0;
		}

		Tp = vexRT[Ch3];
		LeftEncoder = SensorValue[liftEncoderLeft];
		RightEncoder = SensorValue[liftEncoderRight];
		Error = SensorValue[liftEncoderRight] - SensorValue[liftEncoderLeft];
		Integral = Integral * (3 / 4) + Error;
		Derivative = Error - LastError;
	Output = Kp * Error + Ki * Integral + Kd * Derivative;
		LastError = Error;
		MotorFrontLeft = Tp + Output;
		MotorBackLeft = Tp + Output;
		MotorFrontRight = Tp - Output;
		MotorBackRight = Tp - Output;

		if ((Tp + Output) < 0)
		{
			MotorFrontLeft = (Tp + Output)*.5;  //.75
			MotorBackLeft = (Tp + Output)*.5;   //.75
		}
		if ((Tp - Output) < 0)
		{
			MotorFrontRight = (Tp - Output)*.5; //.75
			MotorBackRight = (Tp - Output)*.5;  //.75
		}


		motor[LiftFL] = MotorFrontLeft;
		motor[LiftBL] = MotorBackLeft;
		motor[LiftFR] = MotorFrontRight;
		motor[LiftBR] = MotorBackRight;

		/*motor[LiftFR] = Tp;
		motor[LiftFL] = Tp;
		motor[LiftBR] = Tp;
		motor[LiftBL] = Tp;*/
		wait1Msec(70);
	}
}
