#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    SpatulaPotentiometer, sensorNone)
#pragma config(Sensor, in2,    LiftPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in3,    AutoSelector,   sensorPotentiometer)
#pragma config(Sensor, in4,    RightLineFollower, sensorLineFollower)
#pragma config(Sensor, in5,    LeftLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    LeftLineEdgeDetector, sensorLineFollower)
#pragma config(Sensor, in7,    Gyro,           sensorGyro)
#pragma config(Sensor, in8,    RightLineEdgeDetector, sensorLineFollower)
#pragma config(Sensor, dgtl1,  BackRightQuad,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ConveyerSwitch, sensorTouch)
#pragma config(Sensor, dgtl4,  BackSideUltrasonic, sensorSONAR_mm)
#pragma config(Sensor, dgtl6,  LeftSideUltrasonic, sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  BackLeftQuad,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, RightSideUltrasonic, sensorSONAR_mm)
#pragma config(Sensor, I2C_1,  BackRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  BackLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           DriveBR,       tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           DriveFR,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port3,           Conveyor,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           LiftR,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           DriveBL,       tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port6,           SpatulaR,      tmotorVex393, openLoop)
#pragma config(Motor,  port7,           SpatulaL,      tmotorVex393, openLoop)
#pragma config(Motor,  port8,           Descorer,      tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port9,           DriveFL,       tmotorVex393, openLoop)
#pragma config(Motor,  port10,          LiftL,         tmotorVex393HighSpeed, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Hello there! Welcome to the programming that makes the robot work well. This is where all of intructions for the motors and	//
//	sensors are located. A portion of this code was formed from another robot; FILSS. It was mostly created by Josiah Krutz and	//
//	Ryan Plummer with contributions by Joseph Dykstra. Below, the different files of the code are included so that they can be 	//
//	referenced when needed but they do not clutter up the main file.															//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
//#define LOGENCODERS
#define COMPETITION //Comment this out to allow the pc simulator
//#define ET

#include "Definitions_and_Declarations.c"
#include "Other_Functions.c"
#include "Driver_Control.c"
#include "Input_and_Output.c"
#include "LCD.c"
	#ifndef ET
#include "Driver_Autos.c"
#include "Auto01HighSpeed.c"
#include "Auto02HighSpeed.c"
#include "Auto03HighSpeed.c"
#include "Auto04HighSpeed.c"
#include "Auto05HighSpeed.c" //Test Autonomous
#include "Auto06HighSpeed.c"
#include "Auto07HighSpeed.c"
#include "Auto08HighSpeed.c"
#include "Auto09HighSpeed.c"
	#else
#include "etAutos2.c"
	#endif
#include "Autonomous_Structures_NEW.c"
#include "Initialization.c"


//Here, the distinctions between the autonomous personality and driver personality is defined.
task main()
{
	InitializeLCDScreen();
	InitializePIDControllers();
	InitializeDebugStream();
	InitializeTimers();
	InitializeEncoders();
	SenAutoPot = SensorValue(AutoSelector);
	UpdateAutonomousRoutine();
	while(true)
	{
		Input();
		if(!IsRobotDisabled) //Simulation Allowed but Competiton still works if defined
		{
			if (IsRobotInAutonomousMode || IsRobotInVirtualAutonomousMode ||
				(DriverMode != DriverJoystickControl && DriverMode != DriverMotorTest))
			{
				AutonomousControl();
				UpdateScreen(DispAutonomousMode);
				#ifdef LOGENCODERS
					LogEncoders();
				#endif
				if (!IsRobotInAutonomousMode)
					if (!JoystickCheck(true))
						IsRobotInVirtualAutonomousMode = false;
			}
			else
			{
				AutonomousStep=0;
				UpdateAutonomousRoutine();
				UpdateScreen(DispDriverMode);
				if (DriverMode == DriverJoystickControl)
				{
					AutonomousReset(Finish);
					SubroutineCheck();
					DriveControl();
					IntakeControl();
					LiftControl();
					DescorerControl();
				}
				else if (DriverMode == DriverMotorTest)
				{
					if (!JoystickCheck(false))
						DriverMode = DriverJoystickControl;
				}
			}
		}
		else
		{
			AutonomousStep=0;
			AutonomousReset(Finish);
			UpdateAutonomousRoutine();
			UpdateScreen(DispDisabledMode);
		}
		Output();
		MainNonDelayedLoopTime = time1[T4];
		while (time1[T4] < MinLoopMS) {}
		MainLoopTime = time1[T4];
		ClearTimer(T4);
	}
}
const int auto01[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset
{GLPos,	0,		HSPos,	Up,		120,	120,	Left,	240,	ENCODSTRA}, //strafe left and drive forward
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		1700,	ENCODSTRA}, //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT}, //scoop bags under trough
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-200,	ENCODSTRA}, //back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	TIMELIMIT}, //raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		0100,	ENCODSTRA}, //drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		0,		0,		0,		1300,	TIMELIMIT}, //dump bags in trough
{GLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		-10,	ENCODSTRA}, //drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		800,	RELTRNGYR},	//Gyro Spin //maybe lessen this
{GLPos,	0,		LSPos,	0,		0,		0,		0,		700,	TIMELIMIT}, //Wait for lift to go down all the way
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0400,	ENCODSTRA},  //drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},  //scoop up bags in pyramid part 1
{GLPos,	Rev,	LSPos,	0,		-80,	-80,	0,		-100,	ENCODSTRA},  //back up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0150,	ENCODSTRA},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},  //scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-70,	ENCODSTRA},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0150,	ENCODSTRA},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},  //scoop up bags in pyramid part 3
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//Autonomous is done
const int auto02[][]={ //New Two (not used, not working after picking up wall)
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset
//{-100,	0,		Up,		127,	0,		0,		Left,	-001,	ENCODTURN},	//strafe right, lower spatula
{-100,	0,		LSPos,	Up,		0,		0,		0,		0200,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0700,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-100,	ENCODSTRA},	//drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	250,	RIGTULGYR},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0600,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-80,	ENCODSTRA},	//drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	600,	RIGTULGYR},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		550,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-100,	ENCODSTRA},	//drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		-1760,	RELTRNGYR},	//Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop bags under trough
{0,		50,		LSPos,	0,		Rev,	Rev,	0,		-250,	ENCODSTRA},	//back up and raise lift
{ULPos,	0,		MSPos,	0,		0,		0,		0,		3000,	TIMELIMIT},	//raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	TIMELIMIT},	//Outtake
{TLPos,	Fwd,	0,		0,		Rev,	Fwd,	0,		100,	TIMELIMIT},	//back up
//{TLPos,-50,	0,		0,		Fwd,	Fwd,	0,		200,	TIMELIMIT},	//Push in
{GLPos,	Fwd,	LSPos,	0,		Rev,	Rev,		0,		-1100,	ENCODSTRA},	//back up
//{GLPos,Fwd,	LSPos,	0,		0,		0,		Right,	900,	TIMELIMIT},	//strafe onto tile
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//Reset
const int auto03[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset
//{-100,	0,		Up,		127,	0,		0,		Left,	-001,	ENCODTURN},	//strafe right, lower spatula
{-100,	0,		LSPos,	127,	0,		0,		0,		0200,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		LSPos,	HDPos,	100,	127,	0,		0800,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		HDPos,	0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-150,	ENCODSTRA},	//drive backward
{GLPos,	Rev,	LSPos,	0,		0,		0,		Right,	250,	LEFTULGYR},	//strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		100,	100,	0,		0600,	TIMELIMIT},	//drive forward
{GLPos,	Rev,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-150,	ENCODSTRA},	//drive backward
{GLPos,	Rev,	LSPos,	0,		0,		0,		Right,	600,	LEFTULGYR},	//strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		600,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
//{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-1,		ENCODSTRA},	//drive backward
{GLPos,	Rev,	MSPos,	0,		0,		0,		0,		860,	RELTRNGYR},	//Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop bags under trough
{0,		50,		LSPos,	0,		Rev,	Rev,	0,		-250,	ENCODSTRA},	//back up and raise lift
{TLPos,	0,		MSPos,	0,		0,		0,		0,		3000,	TIMELIMIT},	//raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	TIMELIMIT},	//Outtake
//{TLPos,	-50,	0,		0,		Fwd,	Fwd,	0,		200,	TIMELIMIT},	//Push in
{TLPos,	Fwd,	LSPos,	0,		Rev,	-70,		0,		-1300,	ENCODSTRA},	//back up
//{GLPos,	Fwd,	LSPos,	0,		0,		0,		Right,	900,	TIMELIMIT},	//strafe onto tile

{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//Reset

/*
{GLPos,	0,		Up,		127,	0,		0,		Left,	-001,	ENCODTURN},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	127,	0,		0,		0,		0200,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		LSPos,	HDPos,	Fwd,	Fwd,	0,		0800,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		HDPos,	0,		0,		0,		0700,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-250,	ENCODSTRA},	//drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0720,	ENCODTURN},	//strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		0500,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0600,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-300,	ENCODSTRA},	//drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0500,	ENCODTURN},	//strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		750,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		Fwd,	Rev,	0,		-920,	ENCODTURN},	//turn
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		1050,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0500,	TIMELIMIT},	//scoop bags under trough
{TLPos,	50,		LSPos,	0,		Rev,	Rev,	0,		-250,	ENCODSTRA},	//back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos,	50,		LSPos,	0,		Fwd,	Fwd,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		40,		1900,	TIMELIMIT},	//Outtake
{TLPos,	Rev,	0,		0,		Fwd,	Fwd,	0,		300,	TIMELIMIT},	//Push in
{TLPos,	Fwd,	0,		0,		Rev,	Rev,	0,		800,	TIMELIMIT},	//back up
*/
const int auto03[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset
//{-100,0,		Up,		Up,		0,		0,		Left,	-001,	ENCODTURN},	//strafe right, lower spatula
{-100,	0,		LSPos,	Up,		0,		0,		0,		0200,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		0,		0,		90,		127,	0,		0700,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-150,	ENCODSTRA},	//drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		Right,	230,	LEFTULGYR},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0700,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-150,	ENCODSTRA},	//drive backward
{GLPos,	0,		0,		0,		0,		0,		Right,	600,	LEFTULGYR},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		750,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		100,	TIMELIMIT},	//drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		860,	RELTRNGYR},	//Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop bags under trough
{0,		50,		LSPos,	0,		Rev,	Rev,	0,		-250,	ENCODSTRA},	//back up and raise lift
{ULPos,	0,		MSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		1600,	TIMELIMIT},	//Outtake
{TLPos,	50,		MSPos,	0,		100,	100,	0,		200,	TIMELIMIT},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		Rev,	Fwd,	0,		100,	TIMELIMIT},	//back up
//{TLPos,	-50,	0,		0,		Fwd,	Fwd,	0,		200,	TIMELIMIT},	//Push in
{GLPos,	Fwd,	LSPos,	0,		Rev,	Rev,		0,		-1100,	ENCODSTRA},	//back up
//{GLPos,	Fwd,	LSPos,	0,		0,		0,		Right,	900,	TIMELIMIT},	//strafe onto tile

{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//Reset

/*
{GLPos,	0,		Up,		127,	0,		0,		Left,	-001,	ENCODTURN},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	127,	0,		0,		0,		0200,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0800,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-250,	ENCODSTRA},	//drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0720,	ENCODTURN},	//strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		0500,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0600,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-300,	ENCODSTRA},	//drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0500,	ENCODTURN},	//strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		750,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		Fwd,	Rev,	0,		-920,	ENCODTURN},	//turn
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		1050,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0500,	TIMELIMIT},	//scoop bags under trough
{TLPos,	50,		LSPos,	0,		Rev,	Rev,	0,		-250,	ENCODSTRA},	//back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos,	50,		LSPos,	0,		Fwd,	Fwd,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		40,		1900,	TIMELIMIT},	//Outtake
{TLPos,	Rev,	0,		0,		Fwd,	Fwd,	0,		300,	TIMELIMIT},	//Push in
{TLPos,	Fwd,	0,		0,		Rev,	Rev,	0,		800,	TIMELIMIT},	//back up
*/
const int auto04[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset
{GLPos,	0,		HSPos,	Up,		110,	110,	Left,	700,	TIMELIMIT},	//strafe left and drive forward
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		600,	ENCODSTRA},	//drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags in pyramid part 1
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-100,	ENCODSTRA},	//back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		100,	ENCODSTRA},	//drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-250,	GYRSTRAFE},	//strafe
{GLPos,	0,		MSPos,	0,		0,		0,		0,		200,	TIMELIMIT},	//pause for motor slew to rest
{GLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		180,	TIMELIMIT},	//back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		150,	ENCODSTRA},	//drive forward to under trough ... maybe make this longer
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags
{GLPos,	0,		MSPos,	0,		0,		0,		0,		200,	TIMELIMIT},	//back up, start lifting
{TLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		-125,	ENCODSTRA},	//back up, start lifting
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2400,	TIMELIMIT},	//keep lifting
{TLPos,	0,		MSPos,	0,		100,	100,	0,		600,	TIMELIMIT},	//drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		20,		20,		0,		1800,	TIMELIMIT},	//dump sacks
{0,		Fwd,	MSPos,	0,		-40,	-40,	0,		-575,	ENCODSTRA},	//output bags and backing up
{    0,	0,		     0,	0,	      0,      0,	0,	       0,	RESETAUTO}};	//Autonomous is done
//Lift,	Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetV,TargetCondition
const int auto05[][]={
  {0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset
//{0,		Rev,	0,		0,		0,		0,		0,		1000,	TIMELIMIT},	//strafe right, lower spatula
//{0,		Fwd,	0,		0,		0,		0,		0,		1000,	TIMELIMIT},	//strafe right, lower spatula
//{0,		0,		0,		0,		0,		0,		Left,	250,	RIGTULGYR},	//strafe
{0,			0,		0,		0,		40,		40,		LINE,	60000,	TIMELIMIT},	//FOLLOW LINE
//{0,		0,		0,		0,		0,		0,		0,		-900,	RELTRNGYR},	//square up gyro
//{0,		0,		0,		0,		50,		50,		0,		900,	WHITELINE},	//SQUARE UP LINE
//{0,		0,		0,		0,		0,		0,		0,		100,	TIMELIMIT}, //WAIT FOR SLEW
//{0,		0,		0,		0,		-32,	-32,	0,		600,	WHITELINE},	//SQUARE UP LINE
//{0,		0,		Down,	0,		0,		0,		0,		100,	TIMELIMIT}, //SPAT DOWN
//{0,		0,		0,		0,		0,		0,		1000,	850,	SQUAREUPG},	//square up gyro
//{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-450,	GYRSTRAFE},	//strafe
//{0,		0,		0,		0,		0,		0,		Left,	100,	RUSRSTRAF},		//drive forward
//{0,		0,		0,		0,		0,      0,		0,		0,		ABSTRNGYR},
{0,			0,		0,		0,		0,      0,		0,		0,		RESETAUTO}};	//Reset
//lift,		conv,	spat,	desc,	left,	right,	strafe,	target,	durationType
const int auto06[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset
{GLPos,	0,		HSPos,	Up,		110,	110,	Left,	700,	TIMELIMIT},	//strafe left and drive forward
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		600,	ENCODSTRA},	//drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags in pyramid part 1
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-100,	ENCODSTRA},	//back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		100,	ENCODSTRA},	//drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-250,	GYRSTRAFE},	//strafe
{GLPos,	0,		MSPos,	0,		0,		0,		0,		200,	TIMELIMIT},	//pause for motor slew to rest
{GLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		180,	TIMELIMIT},	//back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		50,		ENCODSTRA},	//drive forward to trough           maybe make this longer
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags
{GLPos,	0,		MSPos,	0,		0,		0,		0,		200,	TIMELIMIT},	//back up, start lifting
{TLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		-125,	ENCODSTRA},	//back up, start lifting
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2400,	TIMELIMIT},	//keep lifting
{TLPos,	0,		MSPos,	0,		100,	100,	0,		600,	TIMELIMIT},	//drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		20,		20,		0,		1800,	TIMELIMIT},	//dump sacks

{0,		Fwd,	2800,	0,		-40,	-40,	0,		-300,	ENCODSTRA},	//output bags and backing up

{GLPos,	0,		MSPos,	0,		0,		0,		0,		800,	RELTRNGYR},	//Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		1000,	ENCODSTRA},	//drive forward
{GLPos,	0,		LSPos,	0,		0,		0,		0,		200,	TIMELIMIT},	//Wait
{GLPos,	0,		LSPos,	0,		0,		0,		0,		-880,	RELTRNGYR},	//Gyro Spin

//{GLPos,	0,		LSPos,	0,		0,		0,		0,		600,	TIMELIMIT},	//wait for lift
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		500,	ENCODSTRA},	//drive forward
{GLPos,	0,		Up,		Down,	0,		0,		0,		700,	TIMELIMIT},	//scoop up bags in pyramid part 2
{GLPos,	0,		MSPos,	0,		-90,	-90,		0,		1000,	TIMELIMIT},	//back up, start lifting

{    0,	0,		     0,	0,	      0,      0,	0,	       0,	RESETAUTO}};	//Autonomous is done
const int auto07[][]={

{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset

{-100,	0,		LSPos,	Up,		0,		0,		0,		0100,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0700,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{0,		-100,	MSPos,	0,		-80,	-80,	0,		-100,	ENCODSTRA},	//drive backward

{0,		0,		MSPos,	0,		0,		0,		0,		-925,	RELTRNGYR},	//Gyro Spin to trough
//{0,	0,		LSPos,	0,		0,		0,		Right,	50,		GYRSTRAFE},	//strafe right, lower spatula
//{0,	Rev,	LSPos,	0,		0,		0,		Left,	300,	RIGTULGYR},	//strafe left, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		1940,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop bags under trough
/*
{0,		0,		LSPos,	0,		Rev,	Rev,	0,		-150,	ENCODSTRA},	//back up and raise lift
{Up,	0,		MSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos,	100,	MSPos,	0,		90,		90,		0,		800,	TIMELIMIT},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		10,		10,		0,		2400,	TIMELIMIT},	//Outtake
{90,	Fwd,	0,		0,		80,		80,		0,		400,	TIMELIMIT},	//Outtake
//{0,	Fwd,	0,		0,		80,		80,		0,		80,		TIMELIMIT}, //Push sacks
{0,		Fwd,	MSPos,	0,		Rev,	Rev,	0,		380,	TIMELIMIT},	//back up
//{0,	Fwd,	MSPos,	0,		-50,	-50,	0,		-30,	BACKULSTR},	//back up
//             SCORE                   SCORE                      SCORE               SCORE
{GLPos,	0,		MSPos,	0,		0,		0,		0,		-820,	RELTRNGYR},	//Gyro Spin to next stack
//{GLPos,0,		MSPos,	0,		Rev,	Rev,	0,		-50,	ENCODSTRA},	//back up
//{GLPos,Fwd,	MSPos,	0,		Rev,	Rev,	0,		-800,	TIMELIMIT},	//back up
//{GLPos,Fwd,	0,		0,		Fwd,	Fwd,	0,		200,	ENCODSTRA}, //Push sacks
//{GLPos,0,		0,		0,		0,		0,		0,		700,	TIMELIMIT},	//Wait for lift
{GLPos,	0,		0,		0,		0,		0,		0,		1000,	TIMELIMIT},


{GLPos,	0,		LSPos,	0,		110,	110,	0,		400,	ENCODSTRA},	//drive to first pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 1
{0,		-50,	LSPos,	0,		-100,	-100,	0,		-150,	ENCODSTRA},	//back up

{0,		0,		LSPos,	0,		110,	110,	0,		155,	ENCODSTRA},	//drive forward first pyramid 2
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 2
{0,		0,		LSPos,	0,		-100,	-100,	0,		-100,	ENCODSTRA},	//scoop up bags

{0,		0,		LSPos,	0,		110,	110,	0,		740,	ENCODSTRA},	//drive forward yellow sack
{0,		-50,	Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up yellow
{0,		0,		LSPos,	0,		-95,	-100,	0,		550,	TIMELIMIT},	//hmm

{0,		0,		LSPos,	0,		110,	110,	0,		360,	ENCODSTRA},	//drive forward to second stack
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyraid take 1
{0,		-50,	LSPos,	0,		-80,	-80,	0,		-200,	ENCODSTRA},	//back up

{0,		0,		LSPos,	0,		110,	110,	0,		180,	ENCODSTRA},	//drive to second pyramid
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 2
{0,		-50,	LSPos,	0,		-80,	-80,	0,		-220,	ENCODSTRA},	//back up

{0,		0,		LSPos,	0,		110,	110,	0,		300,	ENCODSTRA},	//drive forward
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 3
{0,		0,		LSPos,	0,		-100,	-100,	0,		-60,	ENCODSTRA},	//back up to trough

{0,		0,		MSPos,	0,		0,		0,		0,		860,	RELTRNGYR},	//Gyro Spin
{GLPos,	-50,	LSPos,	0,		-80,	-80,	0,		-100,	ENCODSTRA},	//back up
{0,		0,		LSPos,	0,		Fwd,	Fwd,	0,		400,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop bags under trough
{TLPos,	0,		LSPos,	0,		-100,	-100,	0,		-200,	ENCODSTRA},	//flag ..... back up and raise lift
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos+50,50,	MSPos,	0,		100,	100,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	TIMELIMIT},	//Outtake
{Up,	Rev,	LSPos,	0,		100,	100,	0,		150,	TIMELIMIT},	//drive to trough
{0,		Fwd,	MSPos,	0,		Rev,	Rev,	0,		-200,	ENCODSTRA},	//back up from trough
//             SCORE                   SCORE                      SCORE               SCORE
{GLPos,		0,	MSPos,	0,		Fwd,	Rev,	0,		-200,	ENCODTURN},	//turn
{GLPos,		0,	MSPos,	0,		Rev,	Rev,	0,		-900,	ENCODSTRA},	//back up from trough
//{GLPos,	0,	MSPos,	0,		0,		0,	 	Left,	-1700,	ENCODSTRA},	//drive back to blue left start tile
{GLPos,		0,	MSPos,	0,		Rev,	Fwd,	0,		10,		ENCODTURN},	//turn
{GLPos,	0,		MSPos,	0,		Fwd,	Fwd,	0,		400,	TIMELIMIT},
{0,		0,		MSPos,	0,		70,		70,		0,		2000,	SCREENBTN},

//Robot is realigned on other starting tile

{GLPos,	0,		MSPos,	0,		0,		0,		0,		1300,	TIMELIMIT},	//Wait for Lift
{0,		0,		MSPos,	0,		0,		0,		0,		2700,	SCREENBTN},	//Wait for screen button

//Fourth Step
{-100,	0,		LSPos,	127,	0,		0,		0,		0200,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		0,		0,		80,		127,	0,		0720,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-150,	ENCODSTRA},	//drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		Right,	230,	LEFTULGYR},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0700,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-150,	ENCODSTRA},	//drive backward
{GLPos,	0,		0,		0,		0,		0,		Right,	600,	LEFTULGYR},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		750,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		100,	TIMELIMIT},	//drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		860,	RELTRNGYR},	//Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop bags under trough
{0,		50,		LSPos,	0,		Rev,	Rev,	0,		-250,	ENCODSTRA},	//back up and raise lift
{ULPos,	0,		MSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	TIMELIMIT},	//Outtake
{TLPos,	Fwd,	0,		0,		Rev,	Fwd,	0,		100,	TIMELIMIT},	//back up
{TLPos,	-50,	0,		0,		Fwd,	Fwd,	0,		200,	TIMELIMIT},	//Push in
{GLPos,	Fwd,	LSPos,	0,		Rev,	Rev,	0,		-1400,	ENCODSTRA},	//back up
//{GLPos,Fwd,	LSPos,	0,		0,		0,		Right,	900,	TIMELIMIT},	//strafe onto tile
*/
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//Reset
const int auto08[][]={ //New Programming Skills Start with 3 preloads in intake

/* Todo
*/

{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset


//{-100,0,		Up,		127,	0,		0,		Left,	-001,	ENCODTURN},	//strafe right, lower spatula
{-100,	0,		LSPos,	Up,		0,		0,		0,		0100,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0700,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{0,		-100,	MSPos,	0,		-80,	-80,	0,		-100,	ENCODSTRA},	//drive backward
{0,		0,		LSPos,	0,		0,		0,		Left,	270,	RIGTULGYR},	//strafe left, lower spatula
{0,		0,		LSPos,	0,		100,	100,	0,		0650,	TIMELIMIT},	//drive forward
{0,		0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{0,		0,		MSPos,	0,		-100,	-100,	0,		-80,	ENCODSTRA},	//drive backward
{0,		-100,	LSPos,	0,		0,		0,		Left,	590,	RIGTULGYR},	//strafe left, lower spatula
{0,		0,		LSPos,	0,		100,	100,	0,		660,	TIMELIMIT},	//drive forward
{0,		0,		100, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up 2 sacks
//{0,	0,		MSPos,	0,		0,		-80,	-80,	300,	TIMELIMIT},
{0,		0,		MSPos,	0,		0,		0,		0,		-925,	RELTRNGYR},	//Gyro Spin to trough
//{0,	0,		LSPos,	0,		0,		0,		Right,	50,		GYRSTRAFE},	//strafe right, lower spatula
//{0,	Rev,	LSPos,	0,		0,		0,		Left,	300,	RIGTULGYR},	//strafe left, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		940,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop bags under trough

{0,		0,		LSPos,	0,		Rev,	Rev,	0,		-150,	ENCODSTRA},	//back up and raise lift
{Up,	0,		MSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos,	100,	MSPos,	0,		90,		90,		0,		800,	TIMELIMIT},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		10,		10,		0,		2400,	TIMELIMIT},	//Outtake
{90,	Fwd,	0,		0,		80,		80,		0,		400,	TIMELIMIT},	//Outtake
//{0,	Fwd,	0,		0,		80,		80,		0,		80,		TIMELIMIT}, //Push sacks
{0,		Fwd,	MSPos,	0,		Rev,	Rev,	0,		380,	TIMELIMIT},	//back up
//{0,	Fwd,	MSPos,	0,		-50,	-50,	0,		-30,	BACKULSTR},	//back up
//             SCORE                   SCORE                      SCORE               SCORE
{GLPos,	0,		MSPos,	0,		0,		0,		0,		-820,	RELTRNGYR},	//Gyro Spin to next stack
//{GLPos,0,		MSPos,	0,		Rev,	Rev,	0,		-50,	ENCODSTRA},	//back up
//{GLPos,Fwd,	MSPos,	0,		Rev,	Rev,	0,		-800,	TIMELIMIT},	//back up
//{GLPos,Fwd,	0,		0,		Fwd,	Fwd,	0,		200,	ENCODSTRA}, //Push sacks
//{GLPos,0,		0,		0,		0,		0,		0,		700,	TIMELIMIT},	//Wait for lift
{GLPos,	0,		0,		0,		0,		0,		0,		1000,	TIMELIMIT},


{GLPos,	0,		LSPos,	0,		110,	110,	0,		400,	ENCODSTRA},	//drive to first pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 1
{0,		-50,	LSPos,	0,		-100,	-100,	0,		-150,	ENCODSTRA},	//back up

{0,		0,		LSPos,	0,		110,	110,	0,		155,	ENCODSTRA},	//drive forward first pyramid 2
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 2
{0,		0,		LSPos,	0,		-100,	-100,	0,		-100,	ENCODSTRA},	//scoop up bags

{0,		0,		LSPos,	0,		110,	110,	0,		740,	ENCODSTRA},	//drive forward yellow sack
{0,		-50,	Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up yellow
{0,		0,		LSPos,	0,		-95,	-100,	0,		550,	TIMELIMIT},	//hmm

{0,		0,		LSPos,	0,		110,	110,	0,		360,	ENCODSTRA},	//drive forward to second stack
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyraid take 1
{0,		-50,	LSPos,	0,		-80,	-80,	0,		-200,	ENCODSTRA},	//back up

{0,		0,		LSPos,	0,		110,	110,	0,		180,	ENCODSTRA},	//drive to second pyramid
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 2
{0,		-50,	LSPos,	0,		-80,	-80,	0,		-220,	ENCODSTRA},	//back up

{0,		0,		LSPos,	0,		110,	110,	0,		300,	ENCODSTRA},	//drive forward
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 3
{0,		0,		LSPos,	0,		-100,	-100,	0,		-60,	ENCODSTRA},	//back up to trough

{0,		0,		MSPos,	0,		0,		0,		0,		860,	RELTRNGYR},	//Gyro Spin
{GLPos,	-50,	LSPos,	0,		-80,	-80,	0,		-100,	ENCODSTRA},	//back up
{0,		0,		LSPos,	0,		Fwd,	Fwd,	0,		400,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop bags under trough
{TLPos,	0,		LSPos,	0,		-100,	-100,	0,		-200,	ENCODSTRA},	//flag ..... back up and raise lift
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos+50,50,	MSPos,	0,		100,	100,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	TIMELIMIT},	//Outtake
{Up,	Rev,	LSPos,	0,		100,	100,	0,		150,	TIMELIMIT},	//drive to trough
{0,		Fwd,	MSPos,	0,		Rev,	Rev,	0,		-200,	ENCODSTRA},	//back up from trough
//             SCORE                   SCORE                      SCORE               SCORE
{GLPos,		0,	MSPos,	0,		Fwd,	Rev,	0,		-200,	ENCODTURN},	//turn
{GLPos,		0,	MSPos,	0,		Rev,	Rev,	0,		-900,	ENCODSTRA},	//back up from trough
//{GLPos,	0,	MSPos,	0,		0,		0,	 	Left,	-1700,	ENCODSTRA},	//drive back to blue left start tile
{GLPos,		0,	MSPos,	0,		Rev,	Fwd,	0,		10,		ENCODTURN},	//turn
{GLPos,	0,		MSPos,	0,		Fwd,	Fwd,	0,		400,	TIMELIMIT},
{0,		0,		MSPos,	0,		70,		70,		0,		2000,	SCREENBTN},

//Robot is realigned on other starting tile

{GLPos,	0,		MSPos,	0,		0,		0,		0,		1300,	TIMELIMIT},	//Wait for Lift
{0,		0,		MSPos,	0,		0,		0,		0,		2700,	SCREENBTN},	//Wait for screen button

//Fourth Step
{-100,	0,		LSPos,	127,	0,		0,		0,		0200,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		0,		0,		80,		127,	0,		0720,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-150,	ENCODSTRA},	//drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		Right,	230,	LEFTULGYR},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0700,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-150,	ENCODSTRA},	//drive backward
{GLPos,	0,		0,		0,		0,		0,		Right,	600,	LEFTULGYR},	//strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		750,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		100,	TIMELIMIT},	//drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		860,	RELTRNGYR},	//Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop bags under trough
{0,		50,		LSPos,	0,		Rev,	Rev,	0,		-250,	ENCODSTRA},	//back up and raise lift
{ULPos,	0,		MSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	TIMELIMIT},	//Outtake
{TLPos,	Fwd,	0,		0,		Rev,	Fwd,	0,		100,	TIMELIMIT},	//back up
{TLPos,	-50,	0,		0,		Fwd,	Fwd,	0,		200,	TIMELIMIT},	//Push in
{GLPos,	Fwd,	LSPos,	0,		Rev,	Rev,	0,		-1400,	ENCODSTRA},	//back up
//{GLPos,Fwd,	LSPos,	0,		0,		0,		Right,	900,	TIMELIMIT},	//strafe onto tile

{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//Reset
const int auto09[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},		//Reset

{GLPos,	0,		HSPos,	Up,		100,	100,	Right,	500,	GYRSTRAFE}, //strafe right and drive forward
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		2300,	ENCODSTRA}, //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT}, //scoop bags under trough
{TLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-200,	ENCODSTRA}, //back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	TIMELIMIT}, //raise lift
{TLPos,	50,		MSPos,	0,		100,	100,	0,		0120,	ENCODSTRA}, //drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		0,		0,		0,		1300,	TIMELIMIT}, //dump bags in trough
{GLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		-1600,	ENCODSTRA}, //drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		800,	TIMELIMIT}, //lower lift
{0,		0,		MSPos,	0,		0,		0,		0,		1000,	SCREENBTN}, //reposition


/*{GLPos,	0,		MSPos,	0,		0,		0,		0,		-880,	RELTRNGYR},	//Gyro Spin
{GLPos,	0,		LSPos,	0,		0,		0,		0,		700,	TIMELIMIT}, //Wait for lift to go down all the way
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0400,	ENCODSTRA},  //drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},  //scoop up bags in pyramid part 1
{GLPos,	Rev,	LSPos,	0,		Rev,	Rev,	0,		-100,	ENCODSTRA},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0150,	ENCODSTRA},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},  //scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-70,	ENCODSTRA},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0150,	ENCODSTRA},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	TIMELIMIT},  //scoop up bags in pyramid part 3*/


{GLPos,	0,		MSPos,	0,		110,	110,	Left,	800,	TIMELIMIT},	//strafe left and drive forward
{GLPos,	0,		LSPos,	0,		100,	100,	0,		500,	ENCODSTRA},	//drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags in pyramid part 1
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-150,	ENCODSTRA},	//back up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		100,	ENCODSTRA},	//drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-150,	ENCODSTRA},	//back up
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-400,	ENCODTURN},	//strafe
{GLPos,	0,		LSPos,	0,		100,	100,	0,		200,	ENCODSTRA},	//drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-200,	ENCODSTRA},	//back up
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-500,	ENCODTURN},	//strafe
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		150,	ENCODSTRA},	//drive forward to trough           maybe make this longer
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	TIMELIMIT},	//scoop up bags
{TLPos,	Fwd,	MSPos,	0,		Rev,	Rev,	0,		-100,	ENCODSTRA},	//back up, start lifting
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2400,	TIMELIMIT},	//keep lifting
{TLPos,	0,		MSPos,	0,		Fwd,	Fwd,	0,		80,		ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		0,		0,		0,		1800,	TIMELIMIT},	//dump sacks
{TLPos,	Fwd,	MSPos,	0,		Rev,	Rev,	0,		-100,	ENCODSTRA},	//Reverse

{GLPos,	Fwd,	MSPos,	0,		-40,	-40,	0,		-205,	ENCODSTRA},	//output bags and backing up

// Second trough scored

{GLPos,	0,		MSPos,	0,		0,		0,		0,		-880,	RELTRNGYR},	//Gyro Spin
// Third Part

{GLPos,	0,		LSPos,	0,		0,		0,		0,		300,	TIMELIMIT},	//Wait for lift to go down all the way
{GLPos,	0,		LSPos,	0,		-100,	-100,	0,		150,	TIMELIMIT},	//back up to get yellow //This should be less
{GLPos,	0,		LSPos,	0,		100,	100,	0,		200,	ENCODSTRA},	//drive forward to yellow
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up yellow bag
{GLPos,	Fwd,	LSPos,	0,		0,		0,		0,		400,	TIMELIMIT},	//put spatula down
{GLPos,	0,		LSPos,	0,		100,	100,	0,		250,	ENCODSTRA},	//drive to second pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 1
{GLPos,	-50,	LSPos,	0,		-80,	-80,	0,		-200,	ENCODSTRA},	//back up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		150,	ENCODSTRA},	//drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 2
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-100,	ENCODSTRA},	//scoop up bags
{GLPos,	0,		LSPos,	0,		100,	100,	0,		150,	ENCODSTRA},	//drive forward
{0,		0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop up pyramid take 3
{0,		0,		LSPos,	0,		-100,	-100,	0,		-500,	ENCODSTRA},	//back up to line up with trough
{0,		0,		MSPos,	0,		0,		0,		0,		880,	RELTRNGYR},	//Gyro Spin
{0,		0,		LSPos,	0,		Fwd,	Fwd,	0,		400,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	TIMELIMIT},	//scoop bags under trough
{TLPos,	0,		LSPos,	0,		-80,	-80,	0,		-180,	ENCODSTRA},	//flag ..... back up and raise lift
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2400,	TIMELIMIT},	//raise lift
{TLPos,	Fwd,	MSPos,	0,		100,	100,	0,		100,	ENCODSTRA},	//flag2 ..... if good bat maybe, change to 500 drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		0,		0,		-30,	1500,	TIMELIMIT},	//dump bags in trough while straifing
{TLPos,	Rev,	LSPos,	0,		100,	100,	0,		150,	TIMELIMIT},	//drive to trough
{0,		Fwd,	MSPos,	0,		Rev,	Rev,	0,		-300,	ENCODSTRA},	//back up from trough
{GLPos,	0,		MSPos,	0,		-20,	-127,	0,		-1700,	ENCODSTRA},	//drive back to blue left start tile
{0,		0,		MSPos,	0,		Rev,	Fwd,	0,		10,		ENCODTURN},	//turn

//Robot is realigned on other starting tile

{-127,	0,		MSPos,	0,		0,		0,		0,		300,	TIMELIMIT},	//Wait for screen button
{0,		0,		MSPos,	0,		0,		0,		0,		2000,	SCREENBTN},	//Wait for screen button

//Fourth Step
{GLPos,	0,		LSPos,	127,	0,		0,		0,		0200,	TIMELIMIT},	//Descorer Up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0800,	ENCODSTRA},	//drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-250,	ENCODSTRA},	//drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0310,	ENCODTURN},	//strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		100,	100,	0,		0800,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0600,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-200,	ENCODSTRA},	//drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0280,	ENCODTURN},	//strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		800,	TIMELIMIT},	//drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-40,	ENCODSTRA},	//drive backward
{GLPos,	Rev,	MSPos,	0,		0,		0,		0,		880,	RELTRNGYR},	//Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	ENCODSTRA},	//drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	TIMELIMIT},	//scoop bags under trough
{TLPos,	50,		LSPos,	0,		Rev,	Rev,	0,		-250,	ENCODSTRA},	//back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	TIMELIMIT},	//raise lift
{TLPos,	50,		LSPos,	0,		Fwd,	Fwd,	0,		200,	ENCODSTRA},	//drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		40,		2000,	TIMELIMIT},	//Outtake
//{TLPos,	-50,	0,		0,		Fwd,	Fwd,	0,		200,	TIMELIMIT},	//Push in
{TLPos,	Fwd,	LSPos,	0,		Rev,	Rev,	0,		-1700,	ENCODSTRA},	//back up
{GLPos,	Fwd,	LSPos,	0,		0,		0,		Right,	900,	TIMELIMIT},	//strafe onto tile

{0,		0,		0,		0,		0,      0,		0,		0,		RESETAUTO}};	//Autonomous is done
#ifdef ET
void AutonomousStructure(int *INAutoStep)
{
	int INlift			= INAutoStep[0]; //Lift height or power
	int INconveyor		= INAutoStep[1]; //Conveyor power (no rotation sensor on it)
	int INspatula		= INAutoStep[2]; //Spatula height or power
	int INdescorer		= INAutoStep[3]; //Descorer power (no rotation sensor on it)
	int INdl			= INAutoStep[4]; //Left  side drive power
	int INdr			= INAutoStep[5]; //Right side drive power
	int INstrafe		= INAutoStep[6]; //Strafe power
	int INtarget		= INAutoStep[7]; //Target value (time, encoder, or other sensor)
	int INdriveType		= INAutoStep[8]; //Drive type (normal,
	int INendType		= INAutoStep[9];

	if(INdriveType == EncodStra || INdriveType == PIDStraig)	  DriveEncoderError = SenDriveEncoderAvg - DriveEncoderStartAvg;
	else if(INdriveType == EncodTurn || INdriveType == GyrStrafe) DriveEncoderError = SenDriveEncoderDif - DriveEncoderStartDif;
	if (INdriveType==FllwLineC) //LINE FOLLOWING, Center Sensors
	{
		if(SenLeftLine > SenRightLine+5)SenRightLine = FloorLine;
		PIDLineFollower.Output = UpdatePIDController(PIDLineFollower,((SenLeftLine + SenRightLine)/2 - LineEdge));
		MtrDrvFL = INdl - PIDLineFollower.Output;
		MtrDrvBL = INdl - PIDLineFollower.Output;
		MtrDrvFR = INdr + PIDLineFollower.Output;
		MtrDrvBR = INdr + PIDLineFollower.Output;
	}
	else if (INdriveType==FllwWallL || INdriveType==FllwWallR) //WALL FOLLOWING
	{
		if      (INdriveType==FllwWallL) PIDWallFollower.Error = (SenLeftUltrasonic  - INtarget);
		else if (INdriveType==FllwWallR) PIDWallFollower.Error = (SenRightUltrasonic - INtarget);
		PIDWallFollower.Output = UpdatePIDController(PIDWallFollower, PIDWallFollower.Error);
		MtrDrvFL = INdl - PIDWallFollower.Output;
		MtrDrvBL = INdl - PIDWallFollower.Output;
		MtrDrvFR = INdr + PIDWallFollower.Output;
		MtrDrvBR = INdr + PIDWallFollower.Output;
	}
	else if (INdriveType == PIDStraig)
	{
		PIDDriveStraight.Output = UpdatePIDController(PIDDriveStraight, INtarget - DriveEncoderError);
		MtrDrvFL = PIDDriveStraight.Output;
		MtrDrvBL = PIDDriveStraight.Output;
		MtrDrvFR = PIDDriveStraight.Output;
		MtrDrvBR = PIDDriveStraight.Output;
		//if (PIDDriveStraight.Output <= 0) PlayTone(440,10); //Debugging beep
	}
	else if (INdriveType == RelGyrosc || INdriveType == AbsGyrosc || INdriveType == GyrSqreUp)
	{
		if      (INdriveType == RelGyrosc)
			PIDDriveGyro.Output = UpdatePIDController(PIDDriveGyro, INtarget - (SenGyro - StepStartGyro));
		else if (INdriveType == AbsGyrosc)
			PIDDriveGyro.Output = UpdatePIDController(PIDDriveGyro, INtarget - AbsoluteGyro);
		/*else if (INdriveType == GyrSqreUp)
			PIDDriveGyro.Output = 0;*/
		MtrDrvFL = PIDDriveGyro.Output;
		MtrDrvBL = PIDDriveGyro.Output;
		MtrDrvFR = -PIDDriveGyro.Output;
		MtrDrvBR = -PIDDriveGyro.Output;
	}
	else if (INdriveType == GyrStrafe) //STRAFE AND STAY SQUARE WITH THE GYRO
	{
		MtrDrvFL = INdl+INstrafe-SenGyro*GYROSTRAFEP;
		MtrDrvBL = INdl-INstrafe-SenGyro*GYROSTRAFEP;
		MtrDrvFR = INdr-INstrafe+SenGyro*GYROSTRAFEP;
		MtrDrvBR = INdr+INstrafe+SenGyro*GYROSTRAFEP;
	}
	else //NORMAL DRIVING
	{
		MtrDrvFL = INdl+INstrafe;
		MtrDrvBL = INdl-INstrafe;
		MtrDrvFR = INdr-INstrafe;
		MtrDrvBR = INdr+INstrafe;
	}

	if (abs(INlift) <= 127) MtrLift = INlift;										//Lift
	else MtrLift	 = UpdatePIDController(PIDLift,		INlift	   - SenLiftPot);	//||||
	MtrConveyor = INconveyor;														//Conveyor
	PIDSpatula.Kp = 0.2;															//Spatula
	if(abs(INspatula) <= 127) MtrSpatula = INspatula;								//|||||||
	else MtrSpatula  = UpdatePIDController(PIDSpatula,  INspatula  - SenSpatPot);	//|||||||
	if(abs(INdescorer) <= 127) MtrDescorer = INdescorer;							//Descorer
	//else MtrDescorer = UpdatePIDController(PIDDescorer, INdescorer - SenDescPot);	//|||||||| //no pot

	if  (INendType == LineUpWhi) // If we're wanting to end up square with a white line
	{
		if (SenLeftEdge  > LineEdge) HaveFoundLeftEdge  = true; // Have we found the left edge?
		if (SenRightEdge > LineEdge) HaveFoundRightEdge = true; // Have we found the right edge?
		if (HaveFoundLeftEdge)	// If we have found the left  edge
		{
			MtrDrvFL = 0; //Make the left  motors stop
			MtrDrvBL = 0;
			MtrDrvFR /= 3; //Make the right motors slow down
			MtrDrvBR /= 3;
		}
		if (HaveFoundRightEdge) // If we have found the right edge
		{
			MtrDrvFL /= 3; //Make the left Motors slow down
			MtrDrvBL /= 3;
			MtrDrvFR = 0; //Make the right motors stop
			MtrDrvBR = 0;
		}
	}
	switch(INendType) // This code asks what type of target condition are we looking for? Have we met it?
	{
		case ResetAuto: AutonomousReset(AutonomousStep); break;
		case TimeLimit:	if(time1(T1) >= INtarget && INtarget != 0)													AutoNextStep();break;
		case EncodStra: if ((INdr > 0) ? (DriveEncoderError > INtarget) : (DriveEncoderError < INtarget))		AutoNextStep();break;
		case EncodTurn: if ((INdr < 0) ? (DriveEncoderError > INtarget) : (DriveEncoderError < INtarget))		AutoNextStep();break;
		//case EncodTurn: if((DriveEncoderError < INtarget)!=(DriveEncoderErrorLast < INtarget))					AutoNextStep();break;
		case LiftPoten: if((PIDLift.Error < INlift-100)!=(PIDLift.LastError < INlift-100))							AutoNextStep();break;
		case SpatPoten: if(abs(SenSpatPot-INtarget) <= 5)															AutoNextStep();break;
		case ScreenBtn: if(nLCDButtons>0		&& (time1(T1) >= INtarget && INtarget != 0))						AutoNextStep();break;
		case ConvSwich:	if(SenConveyerSwitch	&& (time1(T1) >= INtarget && INtarget != 0))						AutoNextStep();break;
		case AbsLeftUS: if((INstrafe > 0) ? (SenLeftUltrasonic  >= INtarget) : (SenLeftUltrasonic  <= INtarget))	AutoNextStep();break;
		case AbsRigtUS: if((INstrafe < 0) ? (SenRightUltrasonic >= INtarget) : (SenRightUltrasonic <= INtarget))	AutoNextStep();break;
		case AbsBackUS: if((INstrafe < 0) ? (SenBackUltrasonic  >= INtarget) : (SenBackUltrasonic  <= INtarget))	AutoNextStep();break;
		case AbsGyrosc: if((INtarget > 0) ? ((SenGyro % 3600) > INtarget) : ((SenGyro % 3600) < INtarget))			AutoNextStep();break;
		case RelGyrosc: if((INtarget > 0) ? ((SenGyro - StepStartGyro) > INtarget) : ((SenGyro - StepStartGyro) < INtarget)) AutoNextStep();break;
		case LineUpWhi: if(HaveFoundLeftEdge && HaveFoundRightEdge)													AutoNextStep();break;
		default://nothing
	}
	if( time1(T1) >= FailsafeMS && INendType != ResetAuto)															AutoNextStep();
	DriveEncoderErrorLast = DriveEncoderError;
}
#endif
//This part of the code is a funtion that takes inputs for all the mechanisms for the autonomous routines for unform execution.
//This allows code to be created easily and quickly.
void AutoNextStep()
{
	if (AutonomousStep < NumOfTimeRecords)
	{
		AutoTimeRecord[AutonomousStep] = time1[T1];
		writeDebugStreamLine("%d, %d.",AutonomousStep, AutoTimeRecord[AutonomousStep]);
	}
	else writeDebugStreamLine("AutoStep is too big");
	//writeDebugStreamLine("FL:%d, FR:%d, BL:%d, BR:%d",MtrDrvFL,MtrDrvFR,MtrDrvBL,MtrDrvBR);
	//nMotorEncoder[DriveBL] = 0;
	//nMotorEncoder[DriveBR] = 0;
	//SensorValue[BackRightQuad] = 0;
	DriveEncoderStartAvg = SenDriveEncoderAvg;
	DriveEncoderStartDif = SenDriveEncoderDif;
	HaveFoundLeftEdge = false;
	HaveFoundRightEdge = false;
	AddToAbsGyro += SensorValue(Gyro);
	SensorValue(Gyro) = 0;
	StepStartGyro = SensorValue(Gyro);
	AutonomousStep++;
	ClearTimer(T1);
	#ifdef BEEP
		if (AutonomousStep % 3 == 0) //Every third step...
			PlayTone(880,10);		// Make a higher tone
		else
			PlayTone(440,10);
	#endif

}

//This is a function that resets all the motors and will either start the code execution or exits autonomous mode all together.
void AutonomousReset(int StepNumber)
{
	MtrLift = 0;
	MtrDrvFL = 0;
	MtrDrvBL = 0;
	MtrDrvFR = 0;
	MtrDrvBR = 0;
	MtrSpatula = 0;
	MtrConveyor = 0;
	//for (int i=0; i<9; i++) AutoStep[i]=0;
	//writeDebugStreamLine("Start Or Done");
	if(StepNumber == 0) //Runs at start of Autonomous
	{
		AutoNextStep();
		AutonIsOnTheClock = true;
		ClearTimer(T2);
	}
	else //Runs at end of Autonomous
	{
		DriverMode = DriverJoystickControl;
		AutonIsOnTheClock = false;
	}
}

#ifdef ET
#include "Autonomous_Structures_ET.c"
#else
void AutonomousStructure(int *INAutoStep)
{
	int INlift			= INAutoStep[0];
	int INconveyor		= INAutoStep[1];
	int INspatula		= INAutoStep[2];
	int INdescorer		= INAutoStep[3];
	int INdl			= INAutoStep[4];
	int INdr			= INAutoStep[5];
	int INstrafe		= INAutoStep[6]; //Also used for Line and Wall following trigger
	int INtarget		= INAutoStep[7];
	int INdurationType	= INAutoStep[8];

	if      (INdurationType == ENCODSTRA || INdurationType == PIDSTRAIG) DriveEncoderError = SenDriveEncoderAvg - DriveEncoderStartAvg;
	else if (INdurationType == ENCODTURN || INdurationType == GYRSTRAFE) DriveEncoderError = SenDriveEncoderDif - DriveEncoderStartDif;

	if (INstrafe==LINE && INdurationType!=RELTRNGYR && INdurationType!=ENCODTURN && INdurationType!=PIDSTRAIG) //LINE FOLLOWING...Don't allow: drivegyro encodturn pidstraig
	{
		//if(SenLeftLine > SenRightLine+5)SenRightLine = FloorLine;
		//if (SenRightLine > LineEdge) PIDLineFollower.Kp = 0.12;
		//else PIDLineFollower.Kp = 0.06;
		PIDLineFollower.Output = UpdatePIDController(PIDLineFollower,(RightLineFolScaled - LeftLineFolScaled));
		MtrDrvFL = INdl + PIDLineFollower.Output;
		MtrDrvBL = INdl + PIDLineFollower.Output;
		MtrDrvFR = INdr - PIDLineFollower.Output;
		MtrDrvBR = INdr - PIDLineFollower.Output;
	}
	else if ((INstrafe==WALL_L || INstrafe==WALL_R)
		&& (INdurationType!=RELTRNGYR && INdurationType!=ENCODTURN && INdurationType!=PIDSTRAIG)) //WALL FOLLOWING...Don't allow: drivegyro encodturn pidstraig
	{
		if (INstrafe==WALL_L) PIDWallFollower.Error = (SenLeftUltrasonic  - INtarget);
		if (INstrafe==WALL_R) PIDWallFollower.Error = (SenRightUltrasonic - INtarget);
		PIDWallFollower.Output = UpdatePIDController(PIDWallFollower, PIDWallFollower.Error);
		MtrDrvFL = 75 - PIDWallFollower.Output;
		MtrDrvBL = 75 - PIDWallFollower.Output;
		MtrDrvFR = 75 + PIDWallFollower.Output;
		MtrDrvBR = 75 + PIDWallFollower.Output;
	}
	else //NORMAL DRIVING
	{
		CapValue(-127,INstrafe,127);
		MtrDrvFL = INdl+INstrafe;
		MtrDrvBL = INdl-INstrafe;
		MtrDrvFR = INdr-INstrafe;
		MtrDrvBR = INdr+INstrafe;
	}
	//Drive
	if (INdurationType == WHITELINE) // If we're wanting to line up with a white line
	{
		if (SenLeftEdge  > FloorEdgeLineup) HaveFoundLeftEdge  = true; // Have we found the left edge?
		if (SenRightEdge > FloorEdgeLineup) HaveFoundRightEdge = true; // Have we found the right edge?
		if (HaveFoundLeftEdge)	// If we have found the left  edge
		{
			MtrDrvFL /= -6; //Make the left  motors stop
			MtrDrvBL /= -6;
			//MtrDrvFR /= 3; //Make the right motors slow down
			//MtrDrvBR /= 3;
		}
		if (HaveFoundRightEdge) // If we have found the right edge
		{
			MtrDrvFR /= -6; //Make the right motors stop
			MtrDrvBR /= -6;
			//MtrDrvFL /= 3; //Make the right motors slow down
			//MtrDrvBL /= 3;
		}
		/*int errorLeft=(SenLeftEdge -FloorEdgeLineup);
		CapValue(-127,errorLeft,127);
		int errorRight=(SenRightEdge-FloorEdgeLineup);
		CapValue(-254,errorRight,254);
		MtrDrvFL = (errorLeft/4);
		MtrDrvBL = (errorLeft/4);
		MtrDrvFR = (errorRight/4);
		MtrDrvBR = (errorRight/4);*/
	}
	else if (INdurationType == PIDSTRAIG)
	{
		PIDDriveStraight.Output = UpdatePIDController(PIDDriveStraight, INtarget - DriveEncoderError);
		MtrDrvFL = PIDDriveStraight.Output;
		MtrDrvBL = PIDDriveStraight.Output;
		MtrDrvFR = PIDDriveStraight.Output;
		MtrDrvBR = PIDDriveStraight.Output;
		if (PIDDriveStraight.Output <= 0) PlayTone(440,10);
	}
	else if (INdurationType == RELTRNGYR)
	{
		PIDDriveGyro.Output = UpdatePIDController(PIDDriveGyro, INtarget - (SenGyro - StepStartGyro));
		MtrDrvFL = PIDDriveGyro.Output;
		MtrDrvBL = PIDDriveGyro.Output;
		MtrDrvFR = 0 - PIDDriveGyro.Output;
		MtrDrvBR = 0 - PIDDriveGyro.Output;
	}
	else if (INdurationType == ABSTRNGYR)
	{
		PIDDriveGyro.Output = UpdatePIDController(PIDDriveGyro, INtarget - (AbsoluteGyro));
		MtrDrvFL = PIDDriveGyro.Output;
		MtrDrvBL = PIDDriveGyro.Output;
		MtrDrvFR = 0 - PIDDriveGyro.Output;
		MtrDrvBR = 0 - PIDDriveGyro.Output;
	}
	else if (INdurationType == SQUAREUPG)
	{
		PIDDriveGyro.Output = UpdatePIDController(PIDDriveGyro, (INtarget - (SenGyro % 3600))*2);
		MtrDrvFL = PIDDriveGyro.Output;
		MtrDrvBL = PIDDriveGyro.Output;
		MtrDrvFR = 0 - PIDDriveGyro.Output;
		MtrDrvBR = 0 - PIDDriveGyro.Output;
	}

	else if (INdurationType == GYRSTRAFE)
	{
		MtrDrvFL = (INdl+INstrafe-SenGyro*GYROSTRAFEP)*.9;
		MtrDrvBL = INdl-INstrafe-SenGyro*GYROSTRAFEP;
		MtrDrvFR = (INdr-INstrafe+SenGyro*GYROSTRAFEP)*.9;
		MtrDrvBR = INdr+INstrafe+SenGyro*GYROSTRAFEP;
	}
	else if (INdurationType == LEFTULGYR || INdurationType == RIGTULGYR)
	{
		MtrDrvFL = INdl+INstrafe-SenGyro*GYROSTRAFEP;
		MtrDrvBL = INdl-INstrafe-SenGyro*GYROSTRAFEP;
		MtrDrvFR = INdr-INstrafe+SenGyro*GYROSTRAFEP;
		MtrDrvBR = INdr+INstrafe+SenGyro*GYROSTRAFEP;
	}

	if (abs(INlift) <= 127) MtrLift = INlift;
	else MtrLift	 = UpdatePIDController(PIDLift,		INlift	   - SenLiftPot); //Lift
	MtrConveyor = INconveyor;													  //Conveyor
	PIDSpatula.Kp = 0.2;
	if(abs(INspatula) <= 127) MtrSpatula = INspatula;
	else MtrSpatula  = UpdatePIDController(PIDSpatula,  INspatula  - SenSpatPot); //Spatula
	if(abs(INdescorer) <= 127) MtrDescorer = INdescorer;
	//else MtrDescorer = UpdatePIDController(PIDDescorer, INdescorer - SenDescPot); //Descorer //No pot

	switch(INdurationType) // This code asks what type of target condition are we looking for? Have we met it?
	{
		case RESETAUTO: AutonomousReset(AutonomousStep);																		   break;
		case TIMELIMIT: if(time1(T1) >= INtarget)																				AutoNextStep();break;
		case LIFTPOTEN: if((PIDLift.Error < INlift-100)!=(PIDLift.LastError < INlift-100))										AutoNextStep();break;
		case RELTRNGYR: if((INtarget > 0) ? ((SenGyro - StepStartGyro) > INtarget) : ((SenGyro - StepStartGyro) < INtarget))	AutoNextStep();break;
		case ENCODSTRA: if((INdr > 0) ? (DriveEncoderError > INtarget) : (DriveEncoderError < INtarget))			AutoNextStep();break;
		case ENCODTURN: if((DriveEncoderError < INtarget)!=(DriveEncoderErrorLast < INtarget))						AutoNextStep();break;
		case SPATPOTEN: if(abs(SenSpatPot-INtarget) <= 5)															AutoNextStep();break;
//		case WHITELINE: if(abs((SenLeftLine+SenRightLine)/2-LineEdge) <=5)											AutoNextStep();break;
		case WHITELINE: if(HaveFoundLeftEdge && HaveFoundRightEdge)													AutoNextStep();break;
		case SCREENBTN: if(nLCDButtons || (INtarget != 0 && (time1(T1) >= INtarget)))								AutoNextStep();break;
		case PIDSTRAIG: if((DriveEncoderError < INtarget)!=(DriveEncoderErrorLast < INtarget))						AutoNextStep();break;
		case CONVSWICH:	if(SenConveyerSwitch || time1(T1) >= INtarget)												AutoNextStep();break;
		case GYRSTRAFE: if((DriveEncoderError < INtarget)!=(DriveEncoderErrorLast < INtarget))						AutoNextStep();break;
		case LEFTULGYR: if((INstrafe > 0) ? (SenLeftUltrasonic  >= INtarget) : (SenLeftUltrasonic  <= INtarget))	AutoNextStep();break;
		case RIGTULGYR: if((INstrafe < 0) ? (SenRightUltrasonic >= INtarget) : (SenRightUltrasonic <= INtarget))	AutoNextStep();break;
		case BACKULSTR: if((INdr     > 0) ? (SenBackUltrasonic  >= INtarget) : (SenBackUltrasonic  <= INtarget))	AutoNextStep();break;
		case ABSTRNGYR: if((INtarget > 0) ? ((SenGyro % 3600) > INtarget) : ((SenGyro % 3600) < INtarget))			AutoNextStep();break;
		case SQUAREUPG: if(time1(T1) >= INstrafe && INstrafe != 0)																	AutoNextStep();break;
		default://nothing
	}
	if( time1(T1) >= FailsafeMS && INdurationType != RESETAUTO)								AutoNextStep();
	DriveEncoderErrorLast = DriveEncoderError;
}
#endif





/*
void AutonomousControl() //Errors with this one :(
{
	if      (DriverMode == DriverSubPyramid && !IsRobotInAutonomousMode)
		AutonomousStructure(AutoPyramid[AutonomousStep]);
	else if (DriverMode == DriverSubDescore && !IsRobotInAutonomousMode)
		AutonomousStructure(AutoDescore[AutonomousStep]);
	else switch (AutonomousRoutine)
	{
		case 1: AutonomousStructure(auto01[AutonomousStep]); break; // Left Autonomous (scores 21 or 22 (two greens, one yellow in trough))
		case 2: AutonomousStructure(auto02[AutonomousStep]); break; // Right Autonomous gets pyrimid plus the bonus(scores 40 ideally)
		case 3: AutonomousStructure(auto03[AutonomousStep]); break; // Position 3
		case 4: AutonomousStructure(auto04[AutonomousStep]); break; // Right Autonomous gets three green plus pyramid and preload (scores 45 ideally))
//		case 5: AutonomousStructure(auto05[AutonomousStep]); break; // Descorer test???
		case 6: AutonomousStructure(auto06[AutonomousStep]); break;
//		case 7: AutonomousStructure(auto07[AutonomousStep]); break;
		case 8: AutonomousStructure(auto08[AutonomousStep]); break;
		case 9: AutonomousStructure(auto09[AutonomousStep]); break; // Right Autonomous Skills (Scores 130 ideally)
		default: //nothing
	}
}
*/


void AutonomousControl() //No errors with this one :)
{
#ifdef ET
	#define n 10
#else
	#define n 9
#endif
	int tempArray[n];
	if      (DriverMode == DriverSubPyramid && !IsRobotInAutonomousMode)
		for (int j=0; j<n; j++) {tempArray[j] = AutoPyramid[AutonomousStep][j];}
	else if (DriverMode == DriverSubDescore && !IsRobotInAutonomousMode)
		for (int j=0; j<n; j++) {tempArray[j] = AutoDescore[AutonomousStep][j];}
	else switch (AutonomousRoutine)
	{
		case 1: for (int j=0; j<n; j++) {tempArray[j] = auto01[AutonomousStep][j];} break; // Left Autonomous  bite with yellow								(scores 022 ideally)
		case 2: for (int j=0; j<n; j++) {tempArray[j] = auto02[AutonomousStep][j];} break; // Right Autonomous gets pyrimid and a yellow						(scores 040 ideally)
		case 3: for (int j=0; j<n; j++) {tempArray[j] = auto03[AutonomousStep][j];} break; // Left Autonomous  Scoop up wall, and bite with yellow			(scores 060 ideally)
		case 4: for (int j=0; j<n; j++) {tempArray[j] = auto04[AutonomousStep][j];} break; // Right Autonomous gets pyramid, bite and preload				(scores 045 ideally)
		case 5: for (int j=0; j<n; j++) {tempArray[j] = auto05[AutonomousStep][j];} break;
		case 6: for (int j=0; j<n; j++) {tempArray[j] = auto06[AutonomousStep][j];} break; // Right Autonomous gets pyramid, bite and preload, then descores	(scores 045  ideally)
		case 7: for (int j=0; j<n; j++) {tempArray[j] = auto07[AutonomousStep][j];} break;
		case 8: for (int j=0; j<n; j++) {tempArray[j] = auto08[AutonomousStep][j];} break; // Right Autonomous Skills										(Scores 240 ideally)
		case 9: for (int j=0; j<n; j++) {tempArray[j] = auto09[AutonomousStep][j];} break; // Right Autonomous Skills										(Scores 175 ideally)
		default: //nothing
	}
	AutonomousStructure(tempArray);
}

/*int CheckForDriverSubroutine()
{
	if		(AutonomousSubroutine && JoystickCheck(true)) //AutonomousStructure();
	else if (DescoreSubroutine    && JoystickCheck(true)) AutonomousStructure();
	else if	(PyramidSubroutine    && JoystickCheck(true)) AutonomousStructure();
	else return true;
	return false;
}*/
//This portion of the code is intended to contain all of our variable declarations and definitions from the rest of our code.

//Definitions
	//#define BEEP
	#define LIFTCLICK
	#ifdef COMPETITION
		#define IsRobotInAutonomousMode bIfiAutonomousMode
		#define IsRobotDisabled bIfiRobotDisabled
	#else
		#define IsRobotInAutonomousMode bSimulatedAutonomousMode
		#define IsRobotDisabled bSimulatedRobotDisabled
	#endif

	#define CapValue(Min,Value,Max) Value = (Value<Min)? Min:Value; Value = (Value>Max)? Max:Value
	#define PotPosition(Max) (SenAutoPot/(4096/Max))

	//#define autonomous(n) auto##n
	/*
	#define SlopeFilter(Mtr,LMtr,Limit) \
	do{\
		if (Mtr-LMtr>Limit) Mtr= Limit;\
		if (Mtr-LMtr<Limit) Mtr=-Limit;\
	}while(0)
	*/
	/*
	#define SlopeFilter(LastValue,Value,Slew) \
		CapValue(LastValue-Slew,Value,LastValue+Slew)
	*/
	#define GYROSTRAFEP 2
	#define MinLoopMS 5
	#define NumOfAutoRoutines 9
	#define NumOfMenuItems 7
	#define NmOfAutNmStrs 3
	#define NumOfTimeRecords 100
	#define LowLiftKillTimeoutMS 6000
	#define JoystickDZ 20
	#define LineEdge 1800
	#define LeftLineFolTile  1280 //Low
	#define LeftLineFolLine  2400 //High
	#define RightLineFolTile 1460
	#define RightLineFolLine 3600
	//#define SenLeftLineHa 1290
	//#define SenRightLineHa 3000
	/*
	How our scaled values work:
		H = High = LINE
		L = Low  = TILE
		I = Input = SENSOR
	(2000*((I-L)/(H-L)))-1000
	{ 2000*(I-L)/(H-L) } -1000
	*/
	#define LeftLineFolScaled  ((2000*(SenLeftLine  - LeftLineFolTile))   / (LeftLineFolLine  - LeftLineFolTile)-1000)
	#define RightLineFolScaled ((2000*(SenRightLine - RightLineFolTile))  / (RightLineFolLine - RightLineFolTile)-1000)
	float IntLeftLineFolScaled = 1;
	float IntRightLineFolScaled = 1;
	#define FloorEdgeLineup 2700
	/* Dark	Light
	1400 - 2500
	1950 - middle */
//Directional definitions for the motors
	#define Up 127
	#define Down -127
	#define Fwd 127
	#define Rev -127
	#define Right 127
	#define Left -127
	//Autonomous definitions for easy creation of automomous code
	#define Start 0
	#define Finish 1
#ifndef ET
	#define RESETAUTO 0  // Autonomous Done (End of array)
	#define TIMELIMIT 1  // Time limit
	#define LIFTPOTEN 2  // Lift Potentiometer
	#define RELTRNGYR 3  // Turn Relative Gyroscope
	#define ENCODSTRA 4  // Encoder Straight
	#define ENCODTURN 5  // Encoder Turn
	#define SPATPOTEN 6  // Spatula Potentiometer
	#define	WHITELINE 7  // Until white Line
	#define SCREENBTN 8  // Screen Button
	#define PIDSTRAIG 9  // PID Straight
	#define CONVSWICH 10 // Conveyer switch
	#define GYRSTRAFE 11 // Gyro Strafe
	//#define TURNAGYRO 12 // Turn Absolute Gyroscope
	//#define RUSRSTRAF 13 // Right Ultrasonic Relative Strafe
	//#define BCKULTSTR 14 // Drive to PID Back Ultra
	#define LEFTULGYR 15 // Strafe until Ultrasonic Left with Gyro
	#define RIGTULGYR 16 // Strafe until Ultrasonic Right with Gyro
	#define BACKULSTR 17 // Straight until Ultrasonic Back
	#define ABSTRNGYR 18 // Absolute gyro turn
	#define SQUAREUPG 19 // Square up Gyro
	#define WALL_L	128
	#define WALL_R	129
	#define LINE	130
#else
//END TYPES
	#define ResetAuto	00	// Autonomous Done (End/Start of array)
	#define TimeLimit	01	// Time limit
	//#define DriveType	02	// Use the end type (RelGyrTrn)
	#define EncodStra	03	// Straight Encoder
	#define EncodTurn	04	// Turn     Encoder
	#define LiftPoten	05	// Lift    Potentiometer
	#define SpatPoten	06	// Spatula Potentiometer
	#define ScreenBtn	07	// Screen   Button
	#define ConvSwich	08	// Conveyer Button
	#define AbsLeftUS	09	// Absolute Left  Ultrasonic
	#define AbsRigtUS	10	// Absolute Right Ultrasonic
	#define AbsBackUS	11	// Absolute Back  Ultrasonic
	#define RelLeftUS	12	// Relative Left  Ultrasonic
	#define RelRigtUS	13	// Relative Right Ultrasonic
	#define RelBackUS	14	// Relative Back  Ultrasonic
	#define AbsGyrosc	15	// Turn Absolute Gyroscope
	#define RelGyrosc	16	// Turn Relative Gyroscope
	#define	LineUpWhi	17	// Line up on white line
//DRIVE TYPES
	#define NoDriving	00	// No Driving
	#define DriveNorm	01	// Drive
	#define PIDStraig	02	// PID Straight
	#define PIDGyrosc	03	// PID Gyroscope
	#define GyrSqreUp	04	// Gyro Square up
	#define GyrStrafe	05	// Gyro Strafe
	#define FllwWallL	06	// Follow the Left  Wall
	#define FllwWallR	07	// Follow the Right Wall
	#define FllwLineC   08	// Follow the Center Line
#endif

/*-------------Cheat Sheet-------------*\
|*  ResetAuto =	NoDriving,	ResetAuto  *|
|*  TimeLimit =	DriveNorm,	TimeLimit  *|
|*  EncodStra =	DriveNorm,	EncodStra  *|
|*  EncodTurn =	DriveNorm,	EncodTurn  *|
|*  ScreenBtn =	NoDriving,	ScreenBtn  *|
|*  AbsLeftUS =	GyrStrafe,	AbsLeftUS  *|
|*  RelGyrosc =	PIDGyrosc,	RelGyrosc  *|
\*-------------------------------------*/

	/*
	#define TL 1 // Time limit
	#define LP 2 // Lift Potentiometer
	#define DG 3 // Drive Gyroscope
	#define ES 4 // Encoder Straight
	#define ET 5 // Encoder Turn
	#define SP 6 // Spatula Potentiometer
	#define	WL 7 // Until white Line
	#define SB 8 // Screen Button
	#define PS 9 // PID Straight
	*/
//Preset lift heights
	#define GLPos 1100 //600 //270 //330
	#define MLPos 1745 //1539 //1235
	#define TLPos 2690 //2425 //3000 //3200
	#define ULPos 2866 //2600 //3000 //3200

	#define DriverGLPos 1130 //700 //270 //330
	#define DriverMLPos 1150 //820 //1235
	#define DriverTLPos 2689 //2400 //3000 //3200
	#define DriverULPos 2866 //2600 //3000 //3200

	#define LiftCatchPos 2700
	#define LiftHighSpatUp ((TLPos+MLPos)/2)
//Preset spatula heights
	#define LSPos 450 //2325 //2265 //720  //1510
	#define MSPos 1025 //2900 //2500 //1500 //2200
	#define HSPos 1895 //3770 //3580 //2480 //3921

//Preset decorer heights
	/*#define HDPos 3503 //2585
	#define TDPos 2300 //1200
	#define LDPos 1232 //479 */
//Wait Times
	#define FailsafeMS 4000
	#define NextMessageCharMS 250
	#define Cc 2

//Enums
typedef enum
{
	LiftUp,
	LiftDown
} TLiftDirection;

typedef enum
{
	Center,
	Left0,
	Left1
} TLCDPos;

typedef enum
{
	DispDriverMode,
	DispDisabledMode,
	DispAutonomousMode,
} TDisplayMode;

typedef enum
{
	DriverJoystickControl,
	DriverMotorTest,
	DriverSubPyramid,
	DriverSubDescore
} TDriverMode;

//Structs
typedef struct
{
	float Kp;
	float Ki;
	float Kd;
	int Error;
	int Integral;
	int Derivative;
	int LastError;
	int Output;
}	TPID;
/*
typedef struct //Setting means power setting if between -127 and 127, or else Potentiometer PID Target.
{
	int LiftSetting;
	int ConveyorPower;
	int SpatulaSetting;
	int DescorerSetting;
	int LeftDrivePower;
	int RightDrivePower;
	int StrafeDrivePower;
	int TriggerValue;
	int TriggerCondition;
	int TimeOut;
}	TAutonomousStep;
*/
TLiftDirection LastLiftDirection = LiftDown;
TLCDPos DisplayPosition = Left0;
TDriverMode DriverMode = DriverJoystickControl;

TPID PIDLineFollower;
TPID PIDDescorer;
TPID PIDWallFollower;
TPID PIDLift;
TPID PIDSpatula;
TPID PIDDriveStraight;
TPID PIDDriveGyro;

//Integer variables
//Controller 1
	int StkDrvX;
	int StkDrvY;
	int StkDrvZ;
	int StkMtrTest;
//Sensors
	int SenLiftPot;
	int SenAutoPot;
	int SenGyro;
	int SenDriveEncoderBackLeft = 0;
	int SenDriveEncoderBackRight = 0;
	int SenDrivenMotorEncoderBackLeft = 0;
	int SenDrivenMotorEncoderBackRight = 0;
	int SenDriveEncoderAvg;
	int SenDriveEncoderDif;
	int SenSpatPot;
	//int SenDescPot;
	int SenLeftLine  = 0;
	int SenRightLine = 0;
	int SenLeftEdge  = 0;
	int SenRightEdge = 0;
	int SenLeftUltrasonic; //SenLeftUSDistance;
	int SenRightUltrasonic; //SenRightUSDistance;
	int SenBackUltrasonic;
	int SenConveyerSwitch;
//Motors
	int MtrDrvFL;
	int MtrDrvBL;
	int MtrDrvFR;
	int MtrDrvBR;
	int MtrLift;
	int MtrSpatula;
	int MtrConveyor;
	int MtrDescorer;
//Computational
	int LastBtnDriveStyle;
	int AutonomousStep = 0;
	int LastAutonomousRoutine = 0; //Different
	int AutonomousRoutine = 1;
	int LiftTarget = 0;
	int SpatulaTarget = 0;
	int DescorerTarget;
	int DriveEncoderError;
	int DriveEncoderErrorLast;
	int DriveEncoderStartAvg;
	int DriveEncoderStartDif;
	int StepStartGyro = 0;
	int ScrollStringIndex = 0;
	int ScrollCharIndex = 0;
	int LastMenuItem=0;
	int MenuItem=0;
	int LastMotorSlewTime = nSysTime;
	int DeltaMotorSlewTime = 0;
	int MainLoopTime = 0;
	int MainNonDelayedLoopTime = 0;
	int LastGyro = 0;
	int AbsoluteGyro = 0;
	int AddToAbsGyro = 0;
	int StartTimeLiftLow = nSysTime;
//Float variables
//Computational
	float StkPower;
	float StkSin;
	float StkCos1;
	float StkCos2;
	float StkEstPower;
	float StkTheta;
	float AutonTimer = 0;
	float DriveSlewConstant    = 3;		//2; // 0.1; //2
	float LiftSlewConstant     = 10;	//1; //0.1; //1
	float SpatulaSlewConstant  = 10;	//3; //0.1; //3
	float ConveyorSlewConstant = 5;		//3; //0.1; //3
	float DescorerSlewConstant = 3;		//3; //0.1; //3
	float AutonDriveSlewConstant    = 3;	//2; // 0.1; //2
	float AutonLiftSlewConstant     = 10;	//1; //0.1; //1
	float AutonSpatulaSlewConstant  = 40;	//3; //0.1; //3
	float AutonConveyorSlewConstant = 5;	//3; //0.1; //3
	float AutonDescorerSlewConstant = 5;	//3; //0.1; //3
	/*float AutoDriveSlewConstant = 2;		//0.1; //2
	float AutoLiftSlewConstant = 1;			//0.1; //1
	float AutoSpatulaSlewConstant = 3;		//0.1; //3
	float AutoConveyorSlewConstant = 3;		//0.1; //3
	float AutoDescorerSlewConstant = 3;		//0.1; //3*/

//Boolean variables
//Controller 1
	bool BtnConveyorFwd;
	bool BtnConveyorRev;
	bool BtnDriveStyle = 0;
	bool BtnLiftHigh;
	bool BtnSubroutineSelect;
	bool BtnLiftUp;
	bool BtnLiftDown;
	bool LastBtnLiftUp;
	bool LastBtnLiftDown;
	bool BtnSpatulaUp;
	bool BtnSpatulaDown;
	bool BtnDescorerUp;
	bool BtnDescorerDown;
	bool BtnDisablePots;
	bool BtnAutonFromDriver;
	bool BtnHalfSpeed;
	//bool BtnLiftMidDescoreLow;
//Controller 2
	bool BtnConveyorFwd2;
	bool BtnConveyorRev2;
	bool BtnLiftUp2;
	bool BtnLiftDown2;
	bool LastBtnLiftUp2;
	bool LastBtnLiftDown2;
	bool BtnSpatulaUp2;
	bool BtnSpatulaDown2;
	bool BtnLiftHigh2;
	bool BtnLiftGround2;
	bool BtnDescorerUp2;
	bool BtnDescorerDown2;
//Screen buttons
	bool BtnScreenLeft = 0;
	bool LastBtnScreenLeft = 0;
	bool BtnScreenCenter = 0;
	bool LastBtnScreenCenter = 0;
	bool BtnScreenRight = 0;
	bool LastBtnScreenRight = 0;
//Computational
	bool bSimulatedAutonomousMode = true;
	bool bSimulatedRobotDisabled = true;
	bool LastRobotInAutonomousMode;
	bool LastRobotDisabled;
	//bool RefreshTopLCDLine = true;
	//bool RefreshBottomLCDLine = true;
	bool DriveStyle;
	bool MotorsAreEnabled = true;
	bool AutonIsOnTheClock = false;
	bool HaveFoundLeftEdge = false;
	bool HaveFoundRightEdge = false;
	bool bItemActivated = false;
	bool bSpatDownPressed = false;
	bool IsRobotInVirtualAutonomousMode = false;
	/*bool StartAutonFromDriver = false;
	bool AutonIsDone = true;
	bool DescoreSubroutine = false;
	bool PyramidSubroutine = false;
	bool TestMotorsSubroutine = false;*/
	//bool IsGoingUnderTrough = false;
//String variables
	string TopLCDLine = "";
	string LastTopLCDLine = "";
	string BottomLCDLine = "";
	string LastBottomLCDLine = "";

//ARRAYS
	//int AutoStep[9];
	int AutoTimeRecord[NumOfTimeRecords];
	float SlewedMotor[10];
	int TestMotorEnabled[10]={0,0,0,0,0,0,0,0,0,0};
	string BatteryLevel[2];
const string AutoName[NumOfAutoRoutines][NmOfAutNmStrs]={
	//Names of each of our Autonomous routines
	"Left--Under trou","gh in it; 2 wall"," on tile-27   ",		//1
	"Right-Pyramid & ","yellow in trough","-40   ",				//2
	"Left--8 Wall & u","nder trough in t","rough-65   ",		//3
	"Right-Pyramid & ","under trough in ","trough-45   ",		//4
	"TESTS   TESTS   ","TESTS   TESTS   ","TESTS   TESTS   ",	//5
	"Right-Pyramid & ","under trough in ","it, descore-45   ",	//6
	"Test--PID Straig","ht"				 ,"   ",				//7
	"Right-Autonomous","/Programming"," Skills-240   ",			//8
	"Right-Autonomous","/Programming Ski","lls-185   "};		//9
const string MenuItemName[NumOfMenuItems]={
	"Autonomous: ",		//1 (case 0:)
	"Dis/Enable Mtrs",
	"Battery Levels:",
	"Motor Test:",
	"Motor Test:",
	"Analog Value:",
	"Digital Value:"};
const int AutoDescore[][]={
	{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},
	{GLPos,	0,		0,		0,		Rev,	Rev,	0,		-300,	ENCODSTRA},	//straif left and drive forward
	{GLPos,	0,		0,		Down,	0,		0,		0,		500,	TIMELIMIT},	//straif left and drive forward
	{GLPos,	0,		0,		-50,	Rev,	Rev,	0,		-400,	ENCODSTRA},	//straif left and drive forward
	{GLPos,	0,		0,		-50,	-75,	-75,	0,		-300,	ENCODSTRA},	//straif left and drive forward
	{GLPos,	0,		0,		Up,		Fwd,	Fwd,	0,		550,	ENCODSTRA},
	{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//straif left and drive forward


const int AutoPyramid[][]={
	{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},
	{GLPos,	0,		Up,		0,		0,		0,		0,		500,	TIMELIMIT},	//scoop up bags in pyramid part 1
	{GLPos,	Rev,	LSPos,	0,		Rev,	Rev,	0,		-200,	ENCODSTRA},	//back up
	{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		300,	ENCODSTRA},	//drive forward
	{GLPos,	0,		Up,		0,		0,		0,		0,		500,	TIMELIMIT},	//scoop up bags in pyramid part 2
	{GLPos,	Rev,	LSPos,	0,		Rev,	Rev,	0,		-100,	ENCODSTRA},	//back up
	{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		300,	ENCODSTRA},	//drive forward
	{GLPos,	0,		Up,		0,		0,		0,		0,		500,	TIMELIMIT},
	{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//scoop up bags in pyramid part 3

/*
const int AutoTestMotors[][]={
	{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO},
	{GLPos,	0,		0,		HDPos,	Fwd,	Fwd,	0,		1000,	TIMELIMIT},	//Drive Forward
	{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		1000,	TIMELIMIT},	//Drive Backward
	{TLPos,	0,		0,		0,		0,		0,		0,		3000,	TIMELIMIT},	//Lift the lift
	{GLPos,	0,		0,		0,		0,		0,		0,		3000,	TIMELIMIT},
	{0,		0,		0,		0,		0,		0,		0,		0,		RESETAUTO}};	//Drop the lift
*/
void SubroutineCheck()
{
	if (BtnSubroutineSelect && BtnConveyorFwd)		DriverMode = DriverSubPyramid;//old code moved from below
	if (BtnSubroutineSelect && BtnDescorerUp)		DriverMode = DriverSubDescore;
	if (BtnSubroutineSelect && BtnAutonFromDriver)	IsRobotInVirtualAutonomousMode = true;
	//if (!JoystickCheck(true)){}
}

void DriveControl()
{
	StkCos1 = (float) StkDrvX/127.0;
	StkSin = (float) StkDrvY/127.0;
	StkCos2	= (float) StkDrvZ/127.0;
	StkTheta = radiansToDegrees(atan2(StkSin, StkCos1));
	StkEstPower = 137-(cos(StkTheta*4)*10);
	StkPower = sqrt((StkCos1*StkCos1)+(StkCos2*StkCos2)+(StkSin*StkSin))*(16129/StkEstPower);
	if (StkPower   <= JoystickDZ) StkPower = 0;

	if(DriveStyle) //Normal (Robot faces away from driver)
	{
		MtrDrvFL = -((StkSin*abs(StkSin))-(StkCos2*abs(StkCos2))+(StkCos1*abs(StkCos1)))*StkPower;
		MtrDrvBL = -((StkSin*abs(StkSin))-(StkCos2*abs(StkCos2))-(StkCos1*abs(StkCos1)))*StkPower;
		MtrDrvFR = -((StkSin*abs(StkSin))+(StkCos2*abs(StkCos2))-(StkCos1*abs(StkCos1)))*StkPower;
		MtrDrvBR = -((StkSin*abs(StkSin))+(StkCos2*abs(StkCos2))+(StkCos1*abs(StkCos1)))*StkPower;
	}
	else //Inverted (Robot faces driver)
	{
		MtrDrvFL = ((StkSin*abs(StkSin))+(StkCos2*abs(StkCos2))+(StkCos1*abs(StkCos1)))*StkPower;
		MtrDrvBL = ((StkSin*abs(StkSin))+(StkCos2*abs(StkCos2))-(StkCos1*abs(StkCos1)))*StkPower;
		MtrDrvFR = ((StkSin*abs(StkSin))-(StkCos2*abs(StkCos2))-(StkCos1*abs(StkCos1)))*StkPower;
		MtrDrvBR = ((StkSin*abs(StkSin))-(StkCos2*abs(StkCos2))+(StkCos1*abs(StkCos1)))*StkPower;
	}
	if(BtnDriveStyle==1 && LastBtnDriveStyle == 0) DriveStyle = !DriveStyle;//Toggle
	LastBtnDriveStyle = BtnDriveStyle;
}

void LiftControl()
{
	if (BtnDisablePots)
	{
		LiftTarget = 0;
		if		(BtnLiftUp == BtnLiftDown && BtnLiftUp2 == BtnLiftDown2)	MtrLift = 0;
		else if	(BtnLiftUp   || (BtnLiftUp2   && BtnLiftUp == BtnLiftDown))	MtrLift = Up;
		else if	(BtnLiftDown || (BtnLiftDown2 && BtnLiftUp == BtnLiftDown))	MtrLift = Down;
	}
	else
	{
		if ((BtnLiftUp  && !LastBtnLiftUp) ||			//UP
			(BtnLiftUp2 && !LastBtnLiftUp2 && BtnLiftUp == BtnLiftDown))
		{
			if (LastLiftDirection == LiftUp)	//If was at high (or ultra high) position...
			{
				LiftTarget = DriverULPos;			//then go to ultra high position.
				LastLiftDirection = LiftUp;			//Note the last lift direction.
			}
			else if (LiftTarget<DriverMLPos && SenSpatPot <= MSPos)	//If was at ground position (target might be 0), and if spatula is low enough
			{
				LiftTarget = DriverTLPos;			//then go to trough position.
				LastLiftDirection = LiftUp;			//Note the last lift direction.
			}
			else								//If the spatula is in the way
				if (bSoundActive==false)
					PlaySoundFile("Aah.wav");
		}
		else if ((BtnLiftDown  && !LastBtnLiftDown) ||	//DOWN
				 (BtnLiftDown2 && !LastBtnLiftDown2 && BtnLiftUp == BtnLiftDown))
		{
			if (LiftTarget>DriverTLPos)		//If was at ultra high position...
			{
				LiftTarget = DriverTLPos; 		//then go to trough position.
				LastLiftDirection = LiftDown; 	//and note the last lift direction.
			}
			else if (SenSpatPot<HSPos)		//If was at trough (or ground, or 0) position and the spatula is probably not in the way
			{
				LiftTarget = DriverGLPos;		//then go to ground position.
				LastLiftDirection = LiftDown; 	//and note the last lift direction.
			}
			if (SenSpatPot>=MSPos)			//If the spatula might be in the way
				if (bSoundActive==false)
					PlaySoundFile("Aah.wav");
		}
		if ((SenLiftPot<DriverMLPos && LiftTarget==DriverGLPos) || LiftTarget==0) MtrLift = 0;	// If Lift is low enough and target is ground position then stop motors
		else MtrLift = UpdatePIDController(PIDLift, LiftTarget-SenLiftPot);						// Otherwise, use the PID controller
	}
	LastBtnLiftUp	= BtnLiftUp;
	LastBtnLiftDown	= BtnLiftDown;
	LastBtnLiftUp2	= BtnLiftUp2;
	LastBtnLiftDown2= BtnLiftDown2;
}


void IntakeControl()
{
	if((BtnConveyorFwd == BtnConveyorRev)&&(BtnConveyorFwd2 == BtnConveyorRev2)) MtrConveyor = 0; //If no button is pressed
	else if(BtnConveyorFwd || BtnConveyorFwd2 && (BtnConveyorFwd == BtnConveyorRev)) MtrConveyor = Fwd;//Defaults to driver 1
	else if(BtnConveyorRev || BtnConveyorRev2 && (BtnConveyorFwd == BtnConveyorRev)) MtrConveyor = Rev;//Defaults to driver 1

	//if (BtnDisablePots)
	if (true)
	{
		if(BtnSpatulaUp == BtnSpatulaDown) MtrSpatula = 0;
		else if(BtnSpatulaUp) MtrSpatula = Up;
		else if(BtnSpatulaDown) MtrSpatula = Down;
	}
	else
	{
		if((BtnSpatulaUp == BtnSpatulaDown && BtnSpatulaUp2 == BtnSpatulaDown2) || (BtnSpatulaDown && SenSpatPot < LSPos)) //If both or neither
		{
			if(SenLiftPot <= 2000) {MtrSpatula = 0; bSpatDownPressed=false;}
			else
			{
				PIDSpatula.Kp = 0.1;
				if((SenLiftPot > LiftHighSpatUp) && (bSpatDownPressed == false)) SpatulaTarget = MSPos;
				else if((SenLiftPot <= LiftHighSpatUp) && (BtnLiftDown || BtnLiftDown2)) SpatulaTarget = LSPos;
				UpdatePIDController(PIDSpatula, SpatulaTarget-SenSpatPot);
			}
		}
		else if(BtnSpatulaUp   ||(BtnSpatulaUp2   && (BtnSpatulaUp == BtnSpatulaDown))) MtrSpatula = Up; //Defaults to driver 1
		else if((BtnSpatulaDown||(BtnSpatulaDown2 && (BtnSpatulaUp == BtnSpatulaDown))) && (SenSpatPot > LSPos)) {MtrSpatula = Down; bSpatDownPressed=true;}
	}
}

void DescorerControl()
{
	//if (BtnDescorerHighTrough || BtnDescorerHighTrough2)	DescorerTarget = HDPos;
	if (BtnDescorerUp == BtnDescorerDown && BtnDescorerUp2 == BtnDescorerDown2)
		MtrDescorer = 0;											// No descorer button pressed
	else if	(BtnDescorerUp || (BtnDescorerUp2 && BtnDescorerUp == BtnDescorerDown))
		{ MtrDescorer = Down;	DescorerTarget = 0; }				// Up descorer button pressed, defaults to driver 1
	else if	(BtnDescorerDown || (BtnDescorerDown2 && BtnDescorerUp == BtnDescorerDown))
		{ MtrDescorer = Up;		DescorerTarget = 0;	}				// Down descorer button pressed, defaults to driver 1
}


/*
void DriveControl()
{
	StkCos1 = (float) StkDrvX/127.0; //Forward
	StkSin = (float) StkDrvY/127.0;  //Strafe
	StkCos2	= (float) StkDrvZ/127.0; //Turn
	StkTheta = radiansToDegrees(atan2(StkSin, StkCos1));
	StkEstPower = 137-(cos(StkTheta*4)*10);
	StkPower = sqrt((pow(StkCos1,2))+(pow(StkCos2,2))+(pow(StkSin,2)))*(16129/StkEstPower);
	StkPower = (pow(StkPower,1.7)/28);
	if (StkPower   <= JoystickDZ) StkPower = 0;

	int tempForward = (StkSin* abs(StkSin));
	int tempStrafe =  (StkCos1*abs(StkCos1));
	int tempTurn =    (StkCos2*abs(StkCos2));
	if(DriveStyle) //Normal (Robot faces away from driver)
	{
		MtrDrvFL = -(tempForward-tempTurn+tempStrafe)*StkPower;
		MtrDrvBL = -(tempForward-tempTurn-tempStrafe)*StkPower;
		MtrDrvFR = -(tempForward+tempTurn-tempStrafe)*StkPower;
		MtrDrvBR = -(tempForward+tempTurn+tempStrafe)*StkPower;
	}
	else //Inverted (Robot faces driver)
	{
		MtrDrvFL = (tempForward+tempTurn+tempStrafe)*StkPower;
		MtrDrvBL = (tempForward+tempTurn-tempStrafe)*StkPower;
		MtrDrvFR = (tempForward-tempTurn-tempStrafe)*StkPower;
		MtrDrvBR = (tempForward-tempTurn+tempStrafe)*StkPower;
	}
	if(BtnDriveStyle==1 && LastBtnDriveStyle == 0) DriveStyle = !DriveStyle;//Toggle
	LastBtnDriveStyle = BtnDriveStyle;
}
//*/
const int AutoDescore[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},
{GLPos,	0,		0,		0,		Rev,	Rev,	0,		-300,	DriveNorm,	EncodStra},  //straif left and drive forward
{GLPos,	0,		0,		Down,	0,		0,		0,		500,	DriveNorm,	TimeLimit},  //straif left and drive forward
{GLPos,	0,		0,		-50,	Rev,	Rev,	0,		-400,	DriveNorm,	EncodStra},  //straif left and drive forward
{GLPos,	0,		0,		-50,	-75,	-75,	0,		-300,	DriveNorm,	EncodStra},  //straif left and drive forward
{GLPos,	0,		0,		Up,		Fwd,	Fwd,	0,		550,	DriveNorm,	EncodStra},
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto}}; //straif left and drive forward
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition

const int AutoPyramid[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},
{GLPos,	0,		Up,		0,		0,		0,		0,		500,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 1
{GLPos,	Rev,	LSPos,	0,		Rev,	Rev,	0,		-200,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		300,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		500,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 2
{GLPos,	Rev,	LSPos,	0,		Rev,	Rev,	0,		-100,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		300,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		500,	DriveNorm,	TimeLimit},
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto}}; //scoop up bags in pyramid part 3
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition

/*
const int AutoTestMotors[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},
{GLPos,	0,		0,		HDPos,	Fwd,	Fwd,	0,		1000,	DriveNorm,	TimeLimit},  //Drive Forward
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		1000,	DriveNorm,	TimeLimit},  //Drive Backward
{TLPos,	0,		0,		0,		0,		0,		0,		3000,	DriveNorm,	TimeLimit},  //Lift the lift
{GLPos,	0,		0,		0,		0,		0,		0,		3000,	DriveNorm,	TimeLimit},
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto}}; //Drop the lift
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition
*/









const int auto01[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},  //Reset
{GLPos,	0,		HSPos,	Up,		120,	120,	Left,	240,	DriveNorm,	EncodStra},  //strafe left and drive forward
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		1700,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop bags under trough
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-200,	DriveNorm,	EncodStra},  //back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		0100,	DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		0,		0,		0,		1300,	DriveNorm,	TimeLimit},  //dump bags in trough
{GLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		-10,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		800,	PIDGyrosc,	RelGyrosc},  //Gyro Spin //maybe lessen this
{GLPos,	0,		LSPos,	0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //Wait for lift to go down all the way
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0400,	DriveNorm,	EncodStra},  //drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 1
{GLPos,	Rev,	LSPos,	0,		-80,	-80,	0,		-100,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0150,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-70,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0150,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 3
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto}}; //Autonomous is done
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition










const int auto02[][]={ //New Two (not used, not working after picking up wall)
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},  //Reset
//{-100,0,		Up,		Up,		0,		0,		Left,	-001,	DriveNorm,	EncodTurn},  //strafe right, lower spatula
{-100,	0,		LSPos,	Up,		0,		0,		0,		0200,	DriveNorm,	TimeLimit},  //Descorer Up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0700,	DriveNorm,	EncodStra},  //drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-100,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	250,	GyrStrafe,	AbsRigtUS},  //strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0600,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-80,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	600,	GyrStrafe,	AbsRigtUS},  //strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		550,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-100,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		-1760,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	DriveNorm,	TimeLimit},  //scoop bags under trough
{0,		50,		LSPos,	0,		Rev,	Rev,	0,		-250,	DriveNorm,	EncodStra},  //back up and raise lift
{ULPos,	0,		MSPos,	0,		0,		0,		0,		3000,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		200,	DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	DriveNorm,	TimeLimit},  //Outtake
{TLPos,	Fwd,	0,		0,		Rev,	Fwd,	0,		100,	DriveNorm,	TimeLimit},  //back up
//{TLPos,-50,	0,		0,		Fwd,	Fwd,	0,		200,	DriveNorm,	TimeLimit},  //Push in
{GLPos,	Fwd,	LSPos,	0,		Rev,	Rev,	0,		-1100,	DriveNorm,	EncodStra},  //back up
//{GLPos,Fwd,	LSPos,	0,		0,		0,		Right,	900,	DriveNorm,	TimeLimit},  //strafe onto tile
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto}}; //Reset
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition










const int auto03[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},  //Reset
//{-100,0,		Up,		Up,	0,		0,		Left,	-001,	DriveNorm,	EncodTurn},  //strafe right, lower spatula
{-100,	0,		LSPos,	Up,	0,		0,		0,		0200,	DriveNorm,	TimeLimit},  //Descorer Up
{GLPos,	0,		LSPos,	0,		80,		127,	0,		0700,	DriveNorm,	EncodStra},  //drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-150,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	250,	GyrStrafe,	AbsLeftUS},  //strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0600,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-150,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	600,	GyrStrafe,	AbsLeftUS},  //strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		550,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		10,		DriveNorm,	TimeLimit},  //drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		860,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	DriveNorm,	TimeLimit},  //scoop bags under trough
{0,		50,		LSPos,	0,		Rev,	Rev,	0,		-250,	DriveNorm,	EncodStra},  //back up and raise lift
{ULPos,	0,		MSPos,	0,		0,		0,		0,		2500,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		200,	DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	DriveNorm,	TimeLimit},  //Outtake
{TLPos,	50,		MSPos,	0,		100,	100,	0,		200,	DriveNorm,	TimeLimit},  //drive forward to trough
{TLPos,	Fwd,	0,		0,		Rev,	Fwd,	0,		100,	DriveNorm,	TimeLimit},  //back up
//{TLPos,-50,	0,		0,		Fwd,	Fwd,	0,		200,	DriveNorm,	TimeLimit},  //Push in
{GLPos,	Fwd,	LSPos,	0,		Rev,	Rev,	0,		-1100,	DriveNorm,	EncodStra},  //back up
//{GLPos,Fwd,	LSPos,	0,		0,		0,		Right,	900,	DriveNorm,	TimeLimit},  //strafe onto tile

{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto}}; //Reset
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition
/*
//Autonomous 3:
  //Less UltraSonic sensors
  //More Time
  //More Encoders

{GLPos,	0,		Up,		Up,		0,		0,		Left,	-001,	DriveNorm,	EncodTurn},  //strafe right, lower spatula
{GLPos,	0,		LSPos,	Up,		0,		0,		0,		0200,	DriveNorm,	TimeLimit},  //Descorer Up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0800,	DriveNorm,	EncodStra},  //drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-250,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0720,	DriveNorm,	EncodTurn},  //strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		0500,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0600,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-300,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0500,	DriveNorm,	EncodTurn},  //strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		750,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0700,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		Fwd,	Rev,	0,		-920,	DriveNorm,	EncodTurn},  //turn
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		1050,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0500,	DriveNorm,	TimeLimit},  //scoop bags under trough
{TLPos,	50,		LSPos,	0,		Rev,	Rev,	0,		-250,	DriveNorm,	EncodStra},  //back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	50,		LSPos,	0,		Fwd,	Fwd,	0,		200,	DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		40,		1900,	DriveNorm,	TimeLimit},  //Outtake
{TLPos,	Rev,	0,		0,		Fwd,	Fwd,	0,		300,	DriveNorm,	TimeLimit},  //Push in
{TLPos,	Fwd,	0,		0,		Rev,	Rev,	0,		800,	DriveNorm,	TimeLimit},  //back up
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition
*/











const int auto04[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},  //Reset
{GLPos,	0,		HSPos,	Up,		110,	110,	Left,	700,	DriveNorm,	TimeLimit},  //strafe left and drive forward
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		600,	DriveNorm,	EncodStra},  //drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 1
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-100,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		100,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-250,	GyrStrafe,	EncodStra},  //strafe
{GLPos,	0,		MSPos,	0,		0,		0,		0,		200,	DriveNorm,	TimeLimit},  //pause for motor slew to rest
{GLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		180,	DriveNorm,	TimeLimit},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		50,		DriveNorm,	EncodStra},  //drive forward to trough           maybe make this longer
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags
{GLPos,	0,		MSPos,	0,		0,		0,		0,		200,	DriveNorm,	TimeLimit},  //back up, start lifting
{TLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		-125,	DriveNorm,	EncodStra},  //back up, start lifting
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2400,	DriveNorm,	TimeLimit},  //keep lifting
{TLPos,	0,		MSPos,	0,		100,	100,	0,		600,	DriveNorm,	TimeLimit},  //drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		20,		20,		0,		1800,	DriveNorm,	TimeLimit},  //dump sacks
{0,		Fwd,	2800,	0,		-40,	-40,	0,		-575,	DriveNorm,	EncodStra},  //output bags and backing up
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto}}; //Autonomous is done
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition











const int auto05[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},  //Reset
{0,		0,		0,		Rev,	Fwd,	0,		0,		900,	DriveNorm,	TimeLimit},  //square up gyro
{0,		0,		0,		0,		0,      0,		0,		0,		PIDGyrosc,	AbsGyrosc},
{0,		0,		0,		0,		0,      0,		0,		0,		NoDriving,	ResetAuto}}; //Reset
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition
/*
{0,		Rev,	0,		0,		0,		0,		0,		1000,	DriveNorm,	TimeLimit},  //strafe right, lower spatula
{0,		Fwd,	0,		0,		0,		0,		0,		1000,	DriveNorm,	TimeLimit},  //strafe right, lower spatula
{0,		0,		0,		0,		0,		0,		Left,	250,	GyrStrafe,	AbsRigtUS},  //strafe
{0,		0,		0,		0,		0,		0,		0,		-900,	PIDGyrosc,	RelGyrosc},  //square up gyro
{0,		0,		0,		0,		0,		0,		1000,	850,	gyrsqreup,	AbsGyrosc},  //square up gyro
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-450,	GyrStrafe,	EncodStra},  //strafe
{0,		0,		0,		0,		0,		0,		Left,	100,	GyrStrafe,	AbsRigtUS},  //drive forward
*/










const int auto06[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},  //Reset
{GLPos,	0,		HSPos,	Up,		110,	110,	Left,	700,	DriveNorm,	TimeLimit},  //strafe left and drive forward
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		600,	DriveNorm,	EncodStra},  //drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 1
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-100,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		100,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-250,	GyrStrafe,	EncodStra},  //strafe
{GLPos,	0,		MSPos,	0,		0,		0,		0,		200,	DriveNorm,	TimeLimit},  //pause for motor slew to rest
{GLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		180,	DriveNorm,	TimeLimit},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		50,		DriveNorm,	EncodStra},  //drive forward to trough           maybe make this longer
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags
{GLPos,	0,		MSPos,	0,		0,		0,		0,		200,	DriveNorm,	TimeLimit},  //back up, start lifting
{TLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		-125,	DriveNorm,	EncodStra},  //back up, start lifting
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2400,	DriveNorm,	TimeLimit},  //keep lifting
{TLPos,	0,		MSPos,	0,		100,	100,	0,		600,	DriveNorm,	TimeLimit},  //drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		20,		20,		0,		1800,	DriveNorm,	TimeLimit},  //dump sacks

{0,		Fwd,	2800,	0,		-40,	-40,	0,		-300,	DriveNorm,	EncodStra},  //output bags and backing up

{GLPos,	0,		MSPos,	0,		0,		0,		0,		800,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		1000,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		LSPos,	0,		0,		0,		0,		200,	DriveNorm,	TimeLimit},  //Wait
{GLPos,	0,		LSPos,	0,		0,		0,		0,		-880,	PIDGyrosc,	RelGyrosc},  //Gyro Spin

//{GLPos,0,		LSPos,	0,		0,		0,		0,		600,	DriveNorm,	TimeLimit},  //wait for lift
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		500,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		Down,	0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 2
{GLPos,	0,		MSPos,	0,		-90,	-90,	0,		1000,	DriveNorm,	TimeLimit},  //back up, start lifting

{0,		0,		     0,	0,	      0,      0,	0,	       0,	NoDriving,	ResetAuto}}; //Autonomous is done
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition










const int auto08[][]={ //New Programming Skills Start with 3 preloads in intake

{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},  //Reset


//{-100,0,		Up,		127,	0,		0,		Left,	-001,	DriveNorm,	EncodTurn},  //strafe right, lower spatula
{-100,	0,		LSPos,	127,	0,		0,		0,		0100,	DriveNorm,	TimeLimit},  //Descorer Up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0700,	DriveNorm,	EncodStra},  //drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{0,		Rev,	MSPos,	0,		-80,	-80,	0,		-100,	DriveNorm,	EncodStra},  //drive backward
{0,		0,		LSPos,	0,		0,		0,		Left,	270,	GyrStrafe,	AbsRigtUS},  //strafe left, lower spatula
{0,		0,		LSPos,	0,		100,	100,	0,		0550,	DriveNorm,	TimeLimit},  //drive forward
{0,		0,		Up, 	0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{0,		0,		MSPos,	0,		-100,	-100,	0,		-80,	DriveNorm,	EncodStra},  //drive backward
{0,		Rev,	LSPos,	0,		0,		0,		Left,	570,	GyrStrafe,	AbsRigtUS},  //strafe left, lower spatula
{0,		0,		LSPos,	0,		100,	100,	0,		560,	DriveNorm,	TimeLimit},  //drive forward
{0,		0,		100, 	0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up 2 sacks
//{0,	0,		MSPos,	0,		0,		-80,	-80,	300,	DriveNorm,	TimeLimit},
{0,		0,		MSPos,	0,		0,		0,		0,		-925,	PIDGyrosc,	RelGyrosc},  //Gyro Spin to trough
//{0,	0,		LSPos,	0,		0,		0,		Right,	50,		GyrStrafe,	EncodStra},  //strafe right, lower spatula
//{0,	Rev,	LSPos,	0,		0,		0,		Left,	300,	GyrStrafe,	AbsRigtUS},  //strafe left, lower spatula
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		920,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop bags under trough
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition
{0,		0,		LSPos,	0,		Rev,	Rev,	0,		-150,	DriveNorm,	EncodStra},  //back up and raise lift
{Up,	0,		MSPos,	0,		0,		0,		0,		2500,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	100,	MSPos,	0,		90,		90,		0,		800,	DriveNorm,	TimeLimit},  //drive forward to trough
{TLPos,	Fwd,	0,		0,		10,		10,		0,		2400,	DriveNorm,	TimeLimit},  //Outtake
{Up,	Fwd,	0,		0,		80,		80,		0,		120,	DriveNorm,	TimeLimit},  //Outtake
{0,		Fwd,	0,		0,		80,		80,		0,		80,		DriveNorm,	TimeLimit},  //Push sacks
{0,		Fwd,	MSPos,	0,		Rev,	Rev,	0,		340,	DriveNorm,	TimeLimit},  //back up
//{0,	Fwd,	MSPos,	0,		-50,	-50,	0,		-30,	backulstr},	//back up
//             SCORE                   SCORE                      score               SCORE
{GLPos,	0,		MSPos,	0,		0,		0,		0,		-860,	PIDGyrosc,	RelGyrosc},  //Gyro Spin to next stack
//{GLPos,0,		MSPos,	0,		Rev,	Rev,	0,		-50,	DriveNorm,	EncodStra},  //back up
//{GLPos,Fwd,	MSPos,	0,		Rev,	Rev,	0,		-800,	DriveNorm,	TimeLimit},  //back up
//{GLPos,Fwd,	0,		0,		Fwd,	Fwd,	0,		200,	DriveNorm,	EncodStra},  //Push sacks
//{GLPos,0,		0,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //Wait for lift
{GLPos,	0,		0,		0,		0,		0,		0,		1000,	DriveNorm,	TimeLimit},


{GLPos,	0,		LSPos,	0,		95,		127,	0,		350,	DriveNorm,	EncodStra},  //drive to first pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up pyramid take 1
{0,		-50,	LSPos,	0,		-80,	-80,	0,		-150,	DriveNorm,	EncodStra},  //back up

{0,		0,		LSPos,	0,		95,		127,	0,		165,	DriveNorm,	EncodStra},  //drive forward first pyramid 2
{0,		0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up pyramid take 2
{0,		0,		LSPos,	0,		-80,	-80,	0,		-10,	DriveNorm,	EncodStra},  //scoop up bags

{0,		0,		LSPos,	0,		95,		127,	0,		170,	DriveNorm,	EncodStra},  //drive forward yellow sack
{0,		0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up yellow
{0,		0,		LSPos,	0,		-95,	-100,	0,		150,	DriveNorm,	TimeLimit},  //hmm
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition
{0,		0,		LSPos,	0,		95,		127,	0,		360,	DriveNorm,	EncodStra},  //drive forward to second stack
{0,		0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up pyraid take 1
{0,		-50,	LSPos,	0,		-80,	-80,	0,		-150,	DriveNorm,	EncodStra},  //back up

{0,		0,		LSPos,	0,		95,		127,	0,		130,	DriveNorm,	EncodStra},  //drive to second pyramid
{0,		0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up pyramid take 2
{0,		-50,	LSPos,	0,		-80,	-80,	0,		-200,	DriveNorm,	EncodStra},  //back up

{0,		0,		LSPos,	0,		95,		120,	0,		175,	DriveNorm,	EncodStra},  //drive forward
{0,		0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up pyramid take 3
{0,		0,		LSPos,	0,		-100,	-100,	0,		-375,	DriveNorm,	EncodStra},  //back up to trough

{0,		0,		MSPos,	0,		0,		0,		0,		880,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
{GLPos,	-50,	LSPos,	0,		-80,	-80,	0,		-100,	DriveNorm,	EncodStra},  //back up
{0,		0,		LSPos,	0,		Fwd,	Fwd,	0,		400,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop bags under trough
{TLPos,	0,		LSPos,	0,		-100,	-100,	0,		-200,	DriveNorm,	EncodStra},  //flag ..... back up and raise lift
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2500,	DriveNorm,	TimeLimit},  //raise lift
{TLPos+50,50,	MSPos,	0,		100,	100,	0,		200,	DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	DriveNorm,	TimeLimit},  //Outtake
{Up,	Rev,	LSPos,	0,		100,	100,	0,		150,	DriveNorm,	TimeLimit},  //drive to trough
{0,		Fwd,	MSPos,	0,		Rev,	Rev,	0,		-200,	DriveNorm,	EncodStra},  //back up from trough
//             SCORE                   SCORE                      score               SCORE
{GLPos,		0,	MSPos,	0,		Fwd,	Rev,	0,		-200,	DriveNorm,	EncodTurn},  //turn
{GLPos,		0,	MSPos,	0,		Rev,	Rev,	0,		-900,	DriveNorm,	EncodStra},  //back up from trough
//{GLPos,	0,	MSPos,	0,		0,		0,	 	Left,	-1700,	DriveNorm,	EncodStra},  //drive back to blue left start tile
{GLPos,		0,	MSPos,	0,		Rev,	Fwd,	0,		10,		DriveNorm,	EncodTurn},  //turn
{GLPos,	0,		MSPos,	0,		Fwd,	Fwd,	0,		400,	DriveNorm,	TimeLimit},

//Robot is realigned on other starting tile

{GLPos,	0,		MSPos,	0,		0,		0,		0,		1300,	DriveNorm,	TimeLimit},  //Wait for Lift
{0,		0,		MSPos,	0,		0,		0,		0,		2700,	DriveNorm,	ScreenBtn},  //Wait for screen button

//Fourth Step
{-100,	0,		LSPos,	127,	0,		0,		0,		0200,	DriveNorm,	TimeLimit},  //Descorer Up
{GLPos,	0,		LSPos,	0,		70,		127,	0,		0700,	DriveNorm,	EncodStra},  //drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-150,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	250,	GyrStrafe,	AbsLeftUS},  //strafe right, lower spatula
{GLPos,	0,		LSPos,	0,		100,	100,	0,		0600,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-150,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	600,	GyrStrafe,	AbsLeftUS},  //strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		550,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up sacks
//{GLPos,0,		MSPos,	0,		-100,	-100,	0,		-1,		DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		860,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		900,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop bags under trough
{0,		50,		LSPos,	0,		Rev,	Rev,	0,		-250,	DriveNorm,	EncodStra},  //back up and raise lift
{ULPos,	0,		MSPos,	0,		0,		0,		0,		3000,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	50,		MSPos,	0,		Fwd,	Fwd,	0,		200,	DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		0,		2000,	DriveNorm,	TimeLimit},  //Outtake
{TLPos,	Fwd,	0,		0,		Rev,	Fwd,	0,		100,	DriveNorm,	TimeLimit},  //back up
{TLPos,	-50,	0,		0,		Fwd,	Fwd,	0,		200,	DriveNorm,	TimeLimit},  //Push in
{GLPos,	Fwd,	LSPos,	0,		Rev,	Rev,	0,		-1100,	DriveNorm,	EncodStra},  //back up
//{GLPos,Fwd,	LSPos,	0,		0,		0,		Right,	900,	DriveNorm,	TimeLimit},  //strafe onto tile

{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto}}; //Reset
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition









const int auto09[][]={
{0,		0,		0,		0,		0,		0,		0,		0,		NoDriving,	ResetAuto},  //Reset

{GLPos,	0,		HSPos,	Up,		100,	100,	Right,	500,	GyrStrafe,	EncodStra},  //strafe right and drive forward
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		2300,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop bags under trough
{TLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-200,	DriveNorm,	EncodStra},  //back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	50,		MSPos,	0,		100,	100,	0,		0120,	DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		0,		0,		0,		1300,	DriveNorm,	TimeLimit},  //dump bags in trough
{GLPos,	0,		MSPos,	0,		Rev,	Rev,	0,		-1600,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		MSPos,	0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //lower lift
{0,		0,		MSPos,	0,		0,		0,		0,		1000,	DriveNorm,	ScreenBtn},  //reposition


/*{GLPos,0,		MSPos,	0,		0,		0,		0,		-880,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
{GLPos,	0,		LSPos,	0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //Wait for lift to go down all the way
{GLPos,	0,		LSPos,	0,	Fwd,	Fwd,	0,		0400,	DriveNorm,	EncodStra},  //drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 1
{GLPos,	Rev,	LSPos,	0,		Rev,	Rev,	0,		-100,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0150,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		Rev,	Rev,	0,		-70,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0150,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		0800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 3*/


{GLPos,	0,		MSPos,	0,	110,	110,	Left,	800,	DriveNorm,	TimeLimit},  //strafe left and drive forward
{GLPos,	0,		LSPos,	0,	100,	100,	0,		500,	DriveNorm,	EncodStra},  //drive to pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 1
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-150,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		100,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-150,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-400,	DriveNorm,	EncodTurn},  //strafe
{GLPos,	0,		LSPos,	0,		100,	100,	0,		200,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags in pyramid part 2
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-200,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		0,		0,		Left,	-500,	DriveNorm,	EncodTurn},  //strafe
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		150,	DriveNorm,	EncodStra},  //drive forward to trough           maybe make this longer
{GLPos,	0,		Up,		0,		0,		0,		0,		800,	DriveNorm,	TimeLimit},  //scoop up bags
{TLPos,	Fwd,	MSPos,	0,		Rev,	Rev,	0,		-100,	DriveNorm,	EncodStra},  //back up, start lifting
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2400,	DriveNorm,	TimeLimit},  //keep lifting
{TLPos,	0,		MSPos,	0,		Fwd,	Fwd,	0,		80,		DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		0,		0,		0,		1800,	DriveNorm,	TimeLimit},  //dump sacks
{TLPos,	Fwd,	MSPos,	0,		Rev,	Rev,	0,		-100,	DriveNorm,	EncodStra},  //Reverse
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition
{GLPos,	Fwd,	MSPos,	0,		-40,	-40,	0,		-205,	DriveNorm,	EncodStra},  //output bags and backing up

// Second trough scored

{GLPos,	0,		MSPos,	0,		0,		0,		0,		-880,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
// Third Part

{GLPos,	0,		LSPos,	0,		0,		0,		0,		300,	DriveNorm,	TimeLimit},  //Wait for lift to go down all the way
{GLPos,	0,		LSPos,	0,		-100,	-100,	0,		150,	DriveNorm,	TimeLimit},  //back up to get yellow //This should be less
{GLPos,	0,		LSPos,	0,		100,	100,	0,		200,	DriveNorm,	EncodStra},  //drive forward to yellow
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up yellow bag
{GLPos,	Fwd,	LSPos,	0,		0,		0,		0,		400,	DriveNorm,	TimeLimit},  //put spatula down
{GLPos,	0,		LSPos,	0,		100,	100,	0,		250,	DriveNorm,	EncodStra},  //drive to second pyramid
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up pyramid take 1
{GLPos,	-50,	LSPos,	0,		-80,	-80,	0,		-200,	DriveNorm,	EncodStra},  //back up
{GLPos,	0,		LSPos,	0,		100,	100,	0,		150,	DriveNorm,	EncodStra},  //drive forward
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up pyramid take 2
{GLPos,	0,		LSPos,	0,		-80,	-80,	0,		-100,	DriveNorm,	EncodStra},  //scoop up bags
{GLPos,	0,		LSPos,	0,		100,	100,	0,		150,	DriveNorm,	EncodStra},  //drive forward
{0,		0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop up pyramid take 3
{0,		0,		LSPos,	0,		-100,	-100,	0,		-500,	DriveNorm,	EncodStra},  //back up to line up with trough
{0,		0,		MSPos,	0,		0,		0,		0,		880,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
{0,		0,		LSPos,	0,		Fwd,	Fwd,	0,		400,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		700,	DriveNorm,	TimeLimit},  //scoop bags under trough
{TLPos,	0,		LSPos,	0,		-80,	-80,	0,		-180,	DriveNorm,	EncodStra},  //flag ..... back up and raise lift
{TLPos,	0,		MSPos,	0,		0,		0,		0,		2400,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	Fwd,	MSPos,	0,		100,	100,	0,		100,	DriveNorm,	EncodStra},  //flag2 ..... if good bat maybe, change to 500 drive forward to trough
{TLPos,	Fwd,	MSPos,	0,		0,		0,		-30,	1500,	DriveNorm,	TimeLimit},  //dump bags in trough while straifing
{TLPos,	Rev,	LSPos,	0,		100,	100,	0,		150,	DriveNorm,	TimeLimit},  //drive to trough
{0,		Fwd,	MSPos,	0,		Rev,	Rev,	0,		-300,	DriveNorm,	EncodStra},  //back up from trough
{GLPos,	0,		MSPos,	0,		-20,	-127,	0,		-1700,	DriveNorm,	EncodStra},  //drive back to blue left start tile
{0,		0,		MSPos,	0,		Rev,	Fwd,	0,		10,		DriveNorm,	EncodTurn},  //turn

//Robot is realigned on other starting tile

{-127,	0,		MSPos,	0,		0,		0,		0,		300,	DriveNorm,	TimeLimit},  //Wait for screen button
{0,		0,		MSPos,	0,		0,		0,		0,		2000,	DriveNorm,	ScreenBtn},  //Wait for screen button

//Fourth Step
{GLPos,	0,		LSPos,	127,	0,		0,		0,		0200,	DriveNorm,	TimeLimit},  //Descorer Up
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		0800,	DriveNorm,	EncodStra},  //drive forward, spatula down
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-80,	-80,	0,		-250,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0310,	DriveNorm,	EncodTurn},  //strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		100,	100,	0,		0800,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0600,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-200,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	0,		LSPos,	0,		0,		0,		Right,	0280,	DriveNorm,	EncodTurn},  //strafe right, lower spatula
{GLPos,	Rev,	LSPos,	0,		Fwd,	Fwd,	0,		800,	DriveNorm,	TimeLimit},  //drive forward
{GLPos,	0,		Up, 	0,		0,		0,		0,		0700,	DriveNorm,	TimeLimit},  //scoop up sacks
{GLPos,	0,		MSPos,	0,		-100,	-100,	0,		-40,	DriveNorm,	EncodStra},  //drive backward
{GLPos,	Rev,	MSPos,	0,		0,		0,		0,		880,	PIDGyrosc,	RelGyrosc},  //Gyro Spin
{GLPos,	0,		LSPos,	0,		Fwd,	Fwd,	0,		850,	DriveNorm,	EncodStra},  //drive to trough
{GLPos,	0,		Up,		0,		0,		0,		0,		0700,	DriveNorm,	TimeLimit},  //scoop bags under trough
{TLPos,	50,		LSPos,	0,		Rev,	Rev,	0,		-250,	DriveNorm,	EncodStra},  //back up and raise lift
{TLPos,	0,		LSPos,	0,		0,		0,		0,		2500,	DriveNorm,	TimeLimit},  //raise lift
{TLPos,	50,		LSPos,	0,		Fwd,	Fwd,	0,		200,	DriveNorm,	EncodStra},  //drive forward to trough
{TLPos,	Fwd,	0,		0,		0,		0,		40,		2000,	DriveNorm,	TimeLimit},  //Outtake
//{TLPos,-50,	0,		0,		Fwd,	Fwd,	0,		200,	DriveNorm,	TimeLimit},  //Push in
{TLPos,	Fwd,	LSPos,	0,		Rev,	Rev,	0,		-1700,	DriveNorm,	EncodStra},  //back up
{GLPos,	Fwd,	LSPos,	0,		0,		0,		Right,	900,	DriveNorm,	TimeLimit},  //strafe onto tile

{0,		0,		0,		0,		0,      0,		0,		0,		NoDriving,	ResetAuto}}; //Autonomous is done
//Lift,Conveyor,Spatula,Descorer,Leftd,Rightd,Strafe,TargetValue,DriveType,EndCondition
void InitializePIDControllers()
{
	PIDLineFollower.Kp = 2;
	PIDLineFollower.Ki = 0; //0.02; //0.05;
	PIDLineFollower.Kd = 0; //2; //0.002;
	PIDDescorer.Kp = 0.04;
	PIDDescorer.Ki = 0.01;
	PIDDescorer.Kd = 0.03;
	PIDWallFollower.Kp = 0.1;
	PIDWallFollower.Ki = 0;
	PIDWallFollower.Kd = 0;
	PIDLift.Kp = 0.50;
	PIDLift.Ki = 0.04;
	PIDLift.Kd = 0.02;
	PIDSpatula.Kp = 0.15;
	PIDSpatula.Ki = 0.00;
	PIDSpatula.Kd = 0.05;
	PIDDriveStraight.Kp = 0.2;
	PIDDriveStraight.Ki = 0.0;
	PIDDriveStraight.Kd = 0;
	PIDDriveGyro.Kp = 0.5;
	PIDDriveGyro.Ki = 0.0;
	PIDDriveGyro.Kd = 0.5;
}

void InitializeEncoders()
{
	SensorValue[BackRightQuad] = 0;
}

void InitializeLCDScreen()
{
	bLCDBacklight = true;  //Turn on backlight
}

void InitializeTimers()
{
	ClearTimer(T1);
	ClearTimer(T2);
	ClearTimer(T3);
	ClearTimer(T4);
}

void InitializeDebugStream()
{
	writeDebugStreamLine("===============");
}
#if (1) //Normal - Overwrite variables
void Input()
{
//Controller readings
//Joystick
	StkDrvX = vexRT[Ch4];
	StkDrvY = vexRT[Ch3];
	StkDrvZ = vexRT[Ch1];
	StkMtrTest = vexRT[Ch2];

//Buttons
	BtnLiftHigh =		(bool)vexRT[Btn7U];
	BtnAutonFromDriver =(bool)vexRT[Btn7U];
	BtnSubroutineSelect=(bool)vexRT[Btn7L];
	//BtnDriveStyle =		vexRT[Btn7R];
	BtnDisablePots =	(bool)vexRT[Btn7D];

	BtnConveyorFwd =	(bool)vexRT[Btn8U];
	BtnConveyorRev =	(bool)vexRT[Btn8D];
	BtnDescorerUp =		(bool)vexRT[Btn8R];
	BtnDescorerDown =	(bool)vexRT[Btn8L];

	BtnLiftUp =			(bool)vexRT[Btn5U];
	BtnLiftDown =		(bool)vexRT[Btn5D];

	BtnSpatulaUp =		(bool)vexRT[Btn6U];
	BtnSpatulaDown =	(bool)vexRT[Btn6D];
	BtnHalfSpeed =		(bool)vexRT[Btn7R];
	//Buttons2
	BtnLiftUp2 =		(bool)vexRT[Btn5UXmtr2];
	BtnLiftDown2 =		(bool)vexRT[Btn5DXmtr2];
	BtnConveyorFwd2 =	(bool)vexRT[Btn8UXmtr2];
	BtnConveyorRev2 =	(bool)vexRT[Btn8DXmtr2];
	BtnSpatulaUp2 =		(bool)vexRT[Btn6UXmtr2];
	BtnSpatulaDown2 =	(bool)vexRT[Btn6DXmtr2];
	BtnLiftHigh2 =		(bool)vexRT[Btn7UXmtr2];
	BtnLiftGround2 =	(bool)vexRT[Btn7DXmtr2];
	BtnDescorerUp2 =	(bool)vexRT[Btn8RXmtr2];
	BtnDescorerDown2 =	(bool)vexRT[Btn8LXmtr2];

//Sensor readings
//Potetiometers
	SenSpatPot = SensorValue(SpatulaPotentiometer);
	SenLiftPot = 4095 - SensorValue(LiftPotentiometer);
	//SenDescPot = 4095 - SensorValue(DescorerPotetiometer);
	SenAutoPot = SensorValue(AutoSelector);
//Line Followers
	SenLeftLine =  4095 - SensorValue(LeftLineFollower);
	SenRightLine = 4095 - SensorValue(RightLineFollower);
	SenLeftEdge =  4095 - SensorValue(LeftLineEdgeDetector);
	SenRightEdge = 4095 - SensorValue(RightLineEdgeDetector);

//Gyroscopes
	SenGyro = 0 - SensorValue(Gyro);
	if (LastGyro>3000 && SenGyro<600) AddToAbsGyro+=3600;
	if (LastGyro<600 && SenGyro>3000) AddToAbsGyro-=3600;
	AbsoluteGyro = AddToAbsGyro + SenGyro;
	LastGyro = SenGyro;

//UltraSonic Sensors
	SenLeftUltrasonic  =	SensorValue(LeftSideUltrasonic);
	SenRightUltrasonic =	SensorValue(RightSideUltrasonic);
	SenBackUltrasonic  =	SensorValue(BackSideUltrasonic);
//Limit Switches
	SenConveyerSwitch = 	SensorValue(ConveyerSwitch);

//Screen buttons
	LastBtnScreenLeft =		BtnScreenLeft;
	LastBtnScreenCenter =	BtnScreenCenter;
	LastBtnScreenRight =	BtnScreenRight;
	BtnScreenLeft =		(nLCDButtons & 1)>0;
	BtnScreenCenter =	(nLCDButtons & 2)>0;
	BtnScreenRight =	(nLCDButtons & 4)>0;

//Encoders
	/*SenDriveEncoderBackLeft = SensorValue(BackLeftEncoder);
	SenDriveEncoderBackRight = SensorValue(BackRightEncoder);*/
	SenDrivenMotorEncoderBackLeft = nMotorEncoder[DriveBL];
	SenDrivenMotorEncoderBackRight = nMotorEncoder[DriveBR];
	SenDriveEncoderAvg = /*(SensorValue(BackLeftEncoder)+*/(0-SensorValue(BackRightQuad))*1.86;
	SenDriveEncoderDif = /*(0-SensorValue(BackLeftEncoder)+*/(0-SensorValue(BackRightQuad))*1.86;
	//SenDriveEncoderAvg = (SenDrivenMotorEncoderBackLeft+(SenDrivenMotorEncoderBackRight))/2;
	//SenDriveEncoderDif = (0-SenDrivenMotorEncoderBackLeft+(SenDrivenMotorEncoderBackRight))/2;

	LastRobotInAutonomousMode = IsRobotInAutonomousMode;
	LastRobotDisabled = IsRobotDisabled;
	IntLeftLineFolScaled = LeftLineFolScaled;
	IntRightLineFolScaled = RightLineFolScaled;
}

#else //Simulator - Don't overwrite variables

void Input()
{
	if (LastGyro>3000 && SenGyro<600) AddToAbsGyro+=3600;
	if (LastGyro<600 && SenGyro>3000) AddToAbsGyro-=3600;
	AbsoluteGyro = AddToAbsGyro + SenGyro;
	LastGyro = SenGyro;

	LastBtnScreenLeft =		BtnScreenLeft;
	LastBtnScreenCenter =	BtnScreenCenter;
	LastBtnScreenRight =	BtnScreenRight;
	BtnScreenLeft =		(nLCDButtons & 1)>0;
	BtnScreenCenter =	(nLCDButtons & 2)>0;
	BtnScreenRight =	(nLCDButtons & 4)>0;

	LastRobotInAutonomousMode = IsRobotInAutonomousMode;
	LastRobotDisabled = IsRobotDisabled;
}
#endif


void Output()
{
	//Motor slope commands
	if(IsRobotInAutonomousMode)
	{
		//Drive
		SlewedMotor[DriveFL] +=		SlopeFilter(MtrDrvFL,		SlewedMotor[DriveFL],	AutonDriveSlewConstant);
		SlewedMotor[DriveBL] +=		SlopeFilter(MtrDrvBL,		SlewedMotor[DriveBL],	AutonDriveSlewConstant);
		SlewedMotor[DriveFR] +=		SlopeFilter(MtrDrvFR,		SlewedMotor[DriveFR],	AutonDriveSlewConstant);
		SlewedMotor[DriveBR] +=		SlopeFilter(MtrDrvBR,		SlewedMotor[DriveBR],	AutonDriveSlewConstant);

		//Lift
		SlewedMotor[LiftL] +=		SlopeFilter(MtrLift,		SlewedMotor[LiftL],		AutonLiftSlewConstant);
		SlewedMotor[LiftR] +=		SlopeFilter(MtrLift,		SlewedMotor[LiftR],		AutonLiftSlewConstant);

		//Spatula
		SlewedMotor[SpatulaR] +=	SlopeFilter(MtrSpatula,		SlewedMotor[SpatulaR],	AutonSpatulaSlewConstant);
		SlewedMotor[SpatulaL] +=	SlopeFilter(MtrSpatula,		SlewedMotor[SpatulaL],	AutonSpatulaSlewConstant);

		//Conveyor
		SlewedMotor[Conveyor] +=	SlopeFilter(MtrConveyor,	SlewedMotor[Conveyor],	AutonConveyorSlewConstant);

		//Descorer
		SlewedMotor[Descorer] +=	SlopeFilter(MtrDescorer,	SlewedMotor[Descorer],	AutonDescorerSlewConstant);
	}
	else
	{
		if(BtnHalfSpeed)
		{
			//Drive
			SlewedMotor[DriveFL] +=		SlopeFilter(MtrDrvFL/2,		SlewedMotor[DriveFL],	DriveSlewConstant);
			SlewedMotor[DriveBL] +=		SlopeFilter(MtrDrvBL/2,		SlewedMotor[DriveBL],	DriveSlewConstant);
			SlewedMotor[DriveFR] +=		SlopeFilter(MtrDrvFR/2,		SlewedMotor[DriveFR],	DriveSlewConstant);
			SlewedMotor[DriveBR] +=		SlopeFilter(MtrDrvBR/2,		SlewedMotor[DriveBR],	DriveSlewConstant);

			//Lift
			SlewedMotor[LiftL] +=		SlopeFilter(MtrLift/2,		SlewedMotor[LiftL],		LiftSlewConstant);
			SlewedMotor[LiftR] +=		SlopeFilter(MtrLift/2,		SlewedMotor[LiftR],		LiftSlewConstant);

			//Spatula
			SlewedMotor[SpatulaR] +=	SlopeFilter(MtrSpatula/2,	SlewedMotor[SpatulaR],	SpatulaSlewConstant);
			SlewedMotor[SpatulaL] +=	SlopeFilter(MtrSpatula/2,	SlewedMotor[SpatulaL],	SpatulaSlewConstant);

			//Conveyor
			SlewedMotor[Conveyor] +=	SlopeFilter(MtrConveyor/2,	SlewedMotor[Conveyor],	ConveyorSlewConstant);

			//Descorer
			SlewedMotor[Descorer] +=	SlopeFilter(MtrDescorer/2,	SlewedMotor[Descorer],	DescorerSlewConstant);
		}
		else if (DriverMode == DriverMotorTest)
		{
			for (int j=0; j<10; j++)
				SlewedMotor[j] = (TestMotorEnabled[j]*StkMtrTest);
		}
		else
		{
			//Drive
			SlewedMotor[DriveFL] +=		SlopeFilter(MtrDrvFL,		SlewedMotor[DriveFL],	DriveSlewConstant);
			SlewedMotor[DriveBL] +=		SlopeFilter(MtrDrvBL,		SlewedMotor[DriveBL],	DriveSlewConstant);
			SlewedMotor[DriveFR] +=		SlopeFilter(MtrDrvFR,		SlewedMotor[DriveFR],	DriveSlewConstant);
			SlewedMotor[DriveBR] +=		SlopeFilter(MtrDrvBR,		SlewedMotor[DriveBR],	DriveSlewConstant);

			//Lift
			SlewedMotor[LiftL] +=		SlopeFilter(MtrLift,		SlewedMotor[LiftL],		LiftSlewConstant);
			SlewedMotor[LiftR] +=		SlopeFilter(MtrLift,		SlewedMotor[LiftR],		LiftSlewConstant);

			//Spatula
			SlewedMotor[SpatulaR] +=	SlopeFilter(MtrSpatula,		SlewedMotor[SpatulaR],	SpatulaSlewConstant);
			SlewedMotor[SpatulaL] +=	SlopeFilter(MtrSpatula,		SlewedMotor[SpatulaL],	SpatulaSlewConstant);

			//Conveyor
			SlewedMotor[Conveyor] +=	SlopeFilter(MtrConveyor,	SlewedMotor[Conveyor],	ConveyorSlewConstant);

			//Descorer
			SlewedMotor[Descorer] +=	SlopeFilter(MtrDescorer,	SlewedMotor[Descorer],	DescorerSlewConstant);
		}
	}

	//Range check and cap (Make sure motors are within the -127 to 127 range)
	for (int i=0; i<10; i++) {CapValue(-127, SlewedMotor[i], 127);}

	//Motor assign commands
	if (MotorsAreEnabled)
	{
		if(DriveStyle)
		{
			motor[DriveFL]	=	-SlewedMotor[DriveBR];
			motor[DriveBL]	= 	-SlewedMotor[DriveFR];
			motor[DriveFR]	= 	-SlewedMotor[DriveBL];
			motor[DriveBR]	= 	-SlewedMotor[DriveFL];
		}
		else
		{
			motor[DriveFL]	=	SlewedMotor[DriveFL];
			motor[DriveBL]	=	SlewedMotor[DriveBL];
			motor[DriveFR]	=	SlewedMotor[DriveFR];
			motor[DriveBR]	=	SlewedMotor[DriveBR];
		}
		motor[LiftL]		=	SlewedMotor[LiftL];
		motor[LiftR]		=	SlewedMotor[LiftR];
		motor[SpatulaR] 	=	SlewedMotor[SpatulaR];
		motor[SpatulaL] 	=	SlewedMotor[SpatulaL];
		motor[Conveyor] 	=	SlewedMotor[Conveyor];
		motor[Descorer] 	=	SlewedMotor[Descorer];
		#ifdef LIFTCLICK
			if (SlewedMotor[SpatulaL]>40)
			{
				if (bSoundActive==false)
					PlaySoundFile("GunLoad.wav");
			}
			if (SlewedMotor[Conveyor]>40)
			{
				if (bSoundActive==false)
					PlaySoundFile("LaserFire.wav");
			}
			if (SlewedMotor[Descorer]<-40)
			{
				if (bSoundActive==false)
					PlaySoundFile("Inception.wav");
			}
		#endif
	}
	else
	{
		motor[DriveFL]	= 0;
		motor[DriveBL]	= 0;
		motor[DriveFR]	= 0;
		motor[DriveBR]	= 0;
		motor[LiftL]	= 0;
		motor[LiftR]	= 0;
		motor[SpatulaR]	= 0;
		motor[SpatulaL]	= 0;
		motor[Conveyor]	= 0;
		motor[Descorer] = 0;
	}
}
void UpdateScrollingText(string *ShowMessage, int INNumOfStrings)
{
	if (LastAutonomousRoutine != AutonomousRoutine) //If we change autonomous routines
	{
		ScrollStringIndex = 0;
		ScrollCharIndex = 0;
	}
	if(time1(T3) >= NextMessageCharMS) //If it is time to scroll message
	{
		UpdateBatteryLevels();
		string TempString = "";
		string TempStringCat = "";
        TempString = (ShowMessage[ScrollStringIndex]);
        if (ScrollCharIndex > strlen(TempString))
        {
            ScrollCharIndex=1;
            ScrollStringIndex = ((ScrollStringIndex+1) % INNumOfStrings);
        }
        TempString = (ShowMessage[ScrollStringIndex]);	//Start the text
        StringDelete(TempString,0,ScrollCharIndex);		//Delete the beginning
		TempStringCat = (ShowMessage[((ScrollStringIndex+1) % INNumOfStrings)]);	//Get a string ready to be appended
        strcat(TempString, TempStringCat);				//Append
		TempStringCat = (ShowMessage[((ScrollStringIndex+2) % INNumOfStrings)]);	//Get a string ready to be appended
        strcat(TempString, TempStringCat);				//Append
        BottomLCDLine = TempString;
		ScrollCharIndex++; 		//Scroll the message
		ClearTimer(T3); 		//Reset Timer
	}
}


void ExecuteMenuActivated()
{
	bItemActivated = false;
	switch (MenuItem)
	{
		case 00: {IsRobotInVirtualAutonomousMode = true; bSimulatedRobotDisabled = false; bSimulatedAutonomousMode = false;} break;
		case 01: {MotorsAreEnabled = !MotorsAreEnabled;}	break; //Enable / Disable motors
		case 02: break; //View battery Levels
		case 03: {DriverMode = (DriverMode==DriverMotorTest)? DriverJoystickControl:DriverMotorTest;} break; //Run Motor Test/choose speed
		case 04: {TestMotorEnabled[PotPosition(10)] = (( TestMotorEnabled[PotPosition(10)]+2 )%3)-1;} break; //Toggle Motors between -1, 0 and 1
		case 05: break; //View Analog Value
		case 06: break; //View Digital Value
		default: break; //Execute nothing
	}
}


void ViewName()
{
	string TempString = MenuItemName[MenuItem];
	if (MenuItem==0)
	{
		string temp;
		StringFormat(temp,"%d",AutonomousRoutine);
		strcat(TempString, temp);
	}
	TopLCDLine = TempString;
}


void ViewValue()
{
	string TempString1="",TempString2="";
	bool ScrollingValue=false;
	switch (MenuItem) //BOTTOM LINE
	{
		case 00: {string temp[NmOfAutNmStrs];
					for (int j=0; j<NmOfAutNmStrs; j++) temp[j]=AutoName[AutonomousRoutine-1][j];
					UpdateScrollingText(temp,NmOfAutNmStrs); ScrollingValue=true;} break; //Scrolling Autonomous Name
		case 01: {TempString1 = (MotorsAreEnabled)?"Enabled":"Disabled";} break;
		case 02: {UpdateScrollingText(BatteryLevel,2); ScrollingValue=true;} break; //Scrolling Battery Levels
		case 03: {TempString1 = (DriverMode == DriverJoystickControl) ?"Off":"On";
					StringFormat(TempString2,"-Speed:%003d",StkMtrTest);} break;
		case 04: {int temp1=PotPosition(10); int temp2=TestMotorEnabled[temp1];
					StringFormat(TempString1,"Motor %02d:", temp1);
					TempString2=(temp2==-1)?"Rev": (temp2==1)?"Fwd":"Off"; } break;// -1 Rev    1 Fwd    0 Off
		case 05: StringFormat(TempString1,  "in%1d:%0004d", PotPosition(8)+1, SensorValue[PotPosition(8)   ]); break; //View Analog Value
		case 06: StringFormat(TempString1,"dgt%02d:%00005d",PotPosition(12)+1,SensorValue[PotPosition(12)+8]); break; //View Digital Value
		default: break;
	}
	if (ScrollingValue==false)
	{
		DisplayPosition=Center;
		strcat(TempString1,TempString2);
		BottomLCDLine = TempString1;
	}
	else
	{
		if (MenuItem==0)	DisplayPosition=Left0; //No   "<" at the beginning
		else				DisplayPosition=Left1; //With "<" at the beginning
	}
}

void RefreshLCD(TDisplayMode DispMode)
{
	if (TopLCDLine != LastTopLCDLine)
	{
		clearLCDLine(0);
		displayLCDCenteredString(0,TopLCDLine);
	}
	if (BottomLCDLine != LastBottomLCDLine)
	{
		clearLCDLine(1);
		if (DispMode==DispAutonomousMode)
			displayLCDCenteredString(1,BottomLCDLine);
		else
		{
			if      (DisplayPosition==Left0)	displayLCDString(1,0,BottomLCDLine);
			else if (DisplayPosition==Left1)	displayLCDString(1,1,BottomLCDLine);
			else if (DisplayPosition==Center)	displayLCDCenteredString(1,BottomLCDLine);
			if (MenuItem>0)					displayLCDString(1,0, "<");
			if (MenuItem<NumOfMenuItems-1)	displayLCDString(1,15,">");
		}
	}
	LastTopLCDLine = TopLCDLine;
	LastBottomLCDLine = BottomLCDLine;
}


void UpdateScreen(TDisplayMode DispMode)
{
	if(DispMode == DispDisabledMode || DispMode == DispDriverMode) //Show current routine and its name OR the menu
	{
		if (LastBtnScreenLeft  == 0 && BtnScreenLeft)  MenuItem--;
		if (LastBtnScreenRight == 0 && BtnScreenRight) MenuItem++;
		CapValue(0, MenuItem, NumOfMenuItems-1);
		if (LastBtnScreenCenter == 0 && BtnScreenCenter) bItemActivated = !bItemActivated; //Press
		if (bItemActivated)
			ExecuteMenuActivated();
		ViewName();  //TOP LINE
		ViewValue(); //BOTTOM LINE
		if (LastMenuItem != MenuItem)
		{
			ScrollStringIndex = 0;
			ScrollCharIndex = 0;
		}
		LastMenuItem = MenuItem;
	}
	else if(DispMode == DispAutonomousMode)
	{
		if (AutonIsOnTheClock)
			AutonTimer = time100[T2];
		StringFormat(TopLCDLine, "Time:%.1f Rout:%d", AutonTimer / 10, AutonomousRoutine);
		StringFormat(BottomLCDLine, "Step: %d", AutonomousStep);	//Show step
	}
	RefreshLCD(DispMode);
	LastAutonomousRoutine = AutonomousRoutine;
}
float SlopeFilter(int MotorValue, int LastMotorValue, float SlopeLimit)
{
	int Delta = MotorValue-LastMotorValue;
	if (Delta >=  SlopeLimit) Delta =  SlopeLimit;
	if (Delta <= -SlopeLimit) Delta = -SlopeLimit;
	return Delta;
}


void LogEncoders()
{
	writeDebugStreamLine(
	"SenLeft:%d , SenRight:%d , nMotEncLeft:%d , nMotEncRight:%d",
	SensorValue(BackLeftEncoder), SensorValue(BackRightEncoder), nMotorEncoder[DriveBR], nMotorEncoder[DriveBL] );
}


void UpdateAutonomousRoutine()
{
	AutonomousRoutine = PotPosition(NumOfAutoRoutines);
	AutonomousRoutine++;
	CapValue(1, AutonomousRoutine, NumOfAutoRoutines);
}


void UpdateBatteryLevels()
{
	StringFormat(BatteryLevel[0],  "Main:%1.3f  ",  (float)nAvgBatteryLevel/1000);
	//StringFormat(BatteryLevel[1],  "PwrExp:%1.3f  ",(float)X/1000);
	StringFormat(BatteryLevel[1],  "Backup:%1.3f   ",(float)BackupBatteryLevel/1000);
}


bool JoystickCheck(bool CheckCh1) //Check if no buttons are pressed and the joysticks are in their "Dead Zones"
{
	bool ControlActivated = true;
	if(vexRT[Btn5D]		||vexRT[Btn5U]		||vexRT[Btn6D]		||vexRT[Btn6U])			ControlActivated = false;
	if(vexRT[Btn5DXmtr2]||vexRT[Btn5UXmtr2]	||vexRT[Btn6DXmtr2]	||vexRT[Btn6UXmtr2])	ControlActivated = false;
//	if(vexRT[Btn7U]		||vexRT[Btn7L]		||vexRT[Btn7D]		||vexRT[Btn7R])			ControlActivated = false;
//	if(vexRT[Btn7UXmtr2]||vexRT[Btn7LXmtr2]	||vexRT[Btn7DXmtr2]	||vexRT[Btn7RXmtr2])	ControlActivated = false;
//	if(vexRT[Btn8U]		||vexRT[Btn8L]		||vexRT[Btn8D]		||vexRT[Btn8R])			ControlActivated = false;
//	if(vexRT[Btn8UXmtr2]||vexRT[Btn8LXmtr2]	||vexRT[Btn8DXmtr2]	||vexRT[Btn8RXmtr2])	ControlActivated = false;
	if(sqrt(pow(vexRT[Ch4],     2) + pow(vexRT[Ch3],     2)) > JoystickDZ) ControlActivated = false;
	if(sqrt(pow(vexRT[Ch4Xmtr2],2) + pow(vexRT[Ch3Xmtr2],2)) > JoystickDZ) ControlActivated = false;
	if(CheckCh1 && sqrt(pow(vexRT[Ch1],     2))				 > JoystickDZ) ControlActivated = false;

	return ControlActivated;
}


int UpdatePIDController(TPID &PIDController, int Error)
{
	PIDController.Error = Error;
	PIDController.Integral = (PIDController.Integral * (3 / 4)) + PIDController.Error;
	PIDController.Derivative = PIDController.Error - PIDController.LastError;
	PIDController.LastError = PIDController.Error;
	PIDController.Output = ((float) PIDController.Error * PIDController.Kp) //Added float typecasting
						 + (PIDController.Integral * PIDController.Ki)
						 + (PIDController.Derivative * PIDController.Kd);
	return (PIDController.Output);
}
