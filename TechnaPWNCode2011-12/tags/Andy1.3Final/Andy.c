#pragma config(UART_Usage, UART2, VEX_2x16_LCD, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro,                sensorGyro)
#pragma config(Sensor, dgtl1,  LeftDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  BottomLiftLimitSwitchPort, sensorTouch)
#pragma config(Sensor, dgtl12, AutonomousJumperPort,    sensorDigitalIn)
#pragma config(Motor,  port1,           IntakeLF,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port2,           IntakeRF,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           DriveLF,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           DriveRF,       tmotorNormal, openLoop)
#pragma config(Motor,  port5,           LiftL,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           LiftR,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           DriveLB,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           DriveRB,       tmotorNormal, openLoop)
#pragma config(Motor,  port9,           IntakeLB,      tmotorNormal, openLoop)
#pragma config(Motor,  port10,          IntakeRB,      tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
//#define _SIMULATED		// SIMULATOR SWITCH - FOR COMPETITION THIS SHOULD BE COMMENTED OUT!

//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//
//Code made with love by Josiah Krutz and Ryan Plummer. Addition support provided by:
//http://robotc.net/forums/viewtopic.php?f=52&t=1280
//Josh Duff


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#ifdef _SIMULATED
	#include "Vex_Techna_PWN_Debug_Includes.c"			//Debug code - enable
#else
	#include "Vex_Competition_Includes.c"				//Main competition background code...do not modify!
#endif

//Constants
#define numMessages 10
#define JOYSTICKDRIVEMAX 127
#define MOTORDRIVEMAX 127
#define JOYSTICKDEADZONE 20
#define JOYSTICKINPUTS 19
#define LIFTKP 0.2
#define LIFTOFFSET 2
#define IN 127
#define OUT -127
#define UP 127
#define DOWN -127
#define FORWARD 127
#define BACKWARD -127
#define STOP 128

//Enums
typedef enum
{
	STRAIGHT,
	LEFTONEWHEELTURN,
	RIGHTONEWHEELTURN,
	BOTHWHEELTURN
} TAutoDriveType;

typedef enum
{
	SIMPLE,
	TRIGONOMETRIC
} TDriveAlgorithm;

typedef enum
{
	NORMAL,
	REVERSED
} TRobotDirection;

//---------------------------------------------< Structs >-----------------------------------------------\\

typedef struct
{
	float Kp;
	float Ki;
	float Kd;
	int Integral;
	int Derivative;
	int Error;
	float LastError;
	int TargetValue;
	float Output;
	float Offset;

} TPidSystem;

typedef struct
{
	string StepName;
	//Outputs
	int LiftPower;
	int IntakePower;
	TAutoDriveType DriveType;
	int DrivePower;
	//Trip values
	int Timeout;
	int GyroDegrees;
	int EncoderTicks;
	//Functions
	char DigitalSensor;
	int JumpToStep;
} TAutonomous;


//-------------------------------------< Global Variable Declarations >-----------------------------------------\\
// btn = Button (Input), stk = Stick (Input), pneu = Pneumatics (Output), motor = Motor (Output)

//Inputs
float stkDriveX;									//Current X value of drive stick (-127 to 127)
float stkDriveY;							 		//Current Y value of drive stick (-127 to 127)
int stkLift;										//Lift Joystick Channel
int stkLift1;
int stkLift2;
float joystickDrivePower;							//Current distance of drive stick from center
int btnOldNewDrive;									//Old/New-Drive Joystick Button
int btnFrontBackDrive;
int gyrGyroscope;
int btnIntakeIn1;
int btnIntakeOut1;
int btnIntakeIn2;
int btnIntakeOut2;
int btnLiftRestBack1;
int btnLiftRestFront1;
int btnLiftRestBack2;
int btnLiftRestFront2;
float MainBatteryVoltageAverage;
float MainBatteryVoltageLevel;
int ButtonBitMap;
int LeftDisplayButton;
int CenterDisplayButton;
int RightDisplayButton;
int LeftDriveEncoder;
int RightDriveEncoder;
int BottomLiftLimitSwitch;

//Outputs
int motorLeftDriveTrain;							//Value assigned to motors on the left of the robot
int motorRightDriveTrain;							//Value assigned to motors on the right of the robot
int motorLiftLeft;									//Value assigned to left lift motors
int motorLiftRight;									//Value assigned to right lift motors
int motorIntakeFront;								//gets put into the font of the intake mechanism
int motorIntakeBack;								//Gets put into the beack of the intake mechanism

//Stuff that needs to remembered
int btnOldNewDrivePressed;							//Old/New-Drive Joystick Button Pressed Variable
TDriveAlgorithm OldNewDrive = TRIGONOMETRIC;
int btnFrontBackDrivePressed;
TRobotDirection FrontBackDrive = NORMAL;
int LeftDisplayButtonPressed;
int CenterDisplayButtonPressed;
int RightDisplayButtonPressed;
int ActivateMenuItem = 0;
int DisplayNeedsRefreshing = 1;
int CurrentMenu = 0;
int CurrentMenuItem = 0;
int TotalMenuItems;
//int MenuStack[64];
string MainMenu[7] = {"Run Autonomous", "Pick Autonomous", "Motor Test", "Show Variables", "Edit Autonomous", "Make Autonomous", "Show Errors"};
string AutonomousMenu[3] = {"LoadScoreReturn", "ObjectScorer", "No Autonomous"};
TPidSystem PIDLift;
TAutonomous AutonomousLoadScoreReturn[10];
TAutonomous AutonomousObjectScorer[10];
int AutonomousStep = 0;
int AutonomousRoutine = 0;
int EnableOutput = 1;

//----------------------------------------< Function Declarations >----------------------------------------------\\
//void pre_auton();
//task autonomous()
//task usercontrol();
void initializeTimers();
int initializeDisplay();
int initializePID();
int initializeGyro();
int initializeAutonomous();
int getInput();
int processAutonomous();
int processOperator();
int operatorDriveTrain();
int operatorLift();
int operatorIntake();
int PickAutonomous();
int Display();
void DisplayMainMenu();
void DisplayMenu(string MenuTitle, string MenuItem);
void DisplayButtonHandling();
int IsMenuItemActivated();
int CheckJoystick();
void ToggleCheck (int CurrentButtonState, int &WasAlreadyPressed, int &ToBeToggled);
void RangeCheck (int LowerLimit, int &Value, int UpperLimit);
void PIDController(TPidSystem &PIDObject);
void MotorTest();
int doOutput();

void pre_auton()
{
	initializeTimers();
	initializeDisplay();
	initializePID();
	//initializeGyro(); 							//Uncomment when we start using Gyro Sensor
	initializeAutonomous();
	PickAutonomous();
#ifdef _SIMULATED
	while (bSimulatedRobotDisabled);
#else
	while (bIfiRobotDisabled);						//Keep the message displayed while robot is disabled
#endif

}

//----------------------------------------------< Autonomous >-----------------------------------------------\\

task autonomous()
{
	AutonomousStep = 0;
	while (true)
	{
		getInput();
		processAutonomous();
		//doOutput() is in process Autonomous
	}
}

//-------------------------------------------< Operator Control >--------------------------------------------\\
task usercontrol()
{
#ifdef _SIMULATED
	while (!bSimulatedAutonomousMode)
#else
	while (!bIfiAutonomousMode)
#endif
	{
		getInput();
		processOperator();
		if (EnableOutput)
			doOutput();
	}

}
//---------------------------------------------< Initialize >---------------------------------------------------\\
void initializeTimers()
{
	ClearTimer(T1);
}

int initializeDisplay()
{
	//clearLCDLine(0);
    //clearLCDLine(1);
    bLCDBacklight = true;							//Turn Backlight on
	displayLCDPos(1, 0);							//Move "Cursor" to first spot
	displayNextLCDString("Ready to PWN :-D");		//Display motivational message
	return 0;
}

int initializePID()
{
	PIDLift.Kp = 1;
	PIDLift.Ki = 0.1;
	PIDLift.Kd = 5;
	PIDLift.Integral = 0;
	PIDLift.Derivative = 0;
	PIDLift.Error = 0;
	PIDLift.LastError = 0;
	PIDLift.TargetValue = 0;
	PIDLift.Output = 0;
	return 1;
}

int initializeGyro()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in1] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
	return 0;
}

int initializeAutonomous()
{
	// *** LoadScoreReturn ***
	AutonomousLoadScoreReturn[0].StepName = "Raise Lift";
	AutonomousLoadScoreReturn[0].LiftPower = UP;		//Lift Up
	AutonomousLoadScoreReturn[0].Timeout = 1100;

	//Repeat starting here
	AutonomousLoadScoreReturn[1].StepName = "DriveToGoal+Lift";
	AutonomousLoadScoreReturn[1].DriveType = STRAIGHT;	//Drive toward Goal and Lift
	AutonomousLoadScoreReturn[1].DrivePower = FORWARD;
	//AutonomousLoadScoreReturn[1].			//Add encoder stuff here
	AutonomousLoadScoreReturn[1].Timeout = 1700;

	AutonomousLoadScoreReturn[2].StepName = "WaitForStableBot";
	AutonomousLoadScoreReturn[2].LiftPower = 20;		//Stop the lift, and stablalize robot.
	AutonomousLoadScoreReturn[2].Timeout = 250;

	AutonomousLoadScoreReturn[3].StepName = "Release Elements";
	AutonomousLoadScoreReturn[3].IntakePower = OUT;	//Release the Barrels!
	AutonomousLoadScoreReturn[3].Timeout = 3000;

	AutonomousLoadScoreReturn[4].StepName = "StopIntake+Pause";
	AutonomousLoadScoreReturn[4].IntakePower = STOP;
	AutonomousLoadScoreReturn[4].Timeout = 250; //250
	AutonomousLoadScoreReturn[4].DigitalSensor = dgtl12;
	AutonomousLoadScoreReturn[4].JumpToStep = 6;

	AutonomousLoadScoreReturn[5].StepName = "Blue (Turn Left)";
	AutonomousLoadScoreReturn[5].DriveType = LEFTONEWHEELTURN;
	AutonomousLoadScoreReturn[5].DrivePower = BACKWARD;
	AutonomousLoadScoreReturn[5].Timeout = 250; //250
	AutonomousLoadScoreReturn[5].JumpToStep = 7;

	AutonomousLoadScoreReturn[6].StepName = "Red (Turn Right)";
	AutonomousLoadScoreReturn[6].DriveType = RIGHTONEWHEELTURN;
	AutonomousLoadScoreReturn[6].DrivePower = BACKWARD;
	AutonomousLoadScoreReturn[6].Timeout = 250; //250

	AutonomousLoadScoreReturn[7].StepName = "BackToStartTile";
	AutonomousLoadScoreReturn[7].DriveType = STRAIGHT;	//Drive toward Goal and Lift
	AutonomousLoadScoreReturn[7].DrivePower = BACKWARD;
	AutonomousLoadScoreReturn[7].Timeout = 1800;

	AutonomousLoadScoreReturn[8].StepName = "Finished!";
	AutonomousLoadScoreReturn[8].Timeout = -1;

	// *** ObjectScorer ***
	AutonomousObjectScorer[0].StepName = "HeightRaise Lift";
	AutonomousObjectScorer[0].LiftPower = UP;		//Lift Up
	AutonomousObjectScorer[0].Timeout = 1100;

	//Repeat starting here
	AutonomousObjectScorer[1].StepName = "DriveToGoal+Lift";
	AutonomousObjectScorer[1].DriveType = STRAIGHT;	//Drive toward Goal and Lift
	AutonomousObjectScorer[1].DrivePower = FORWARD;
	//AutonomousLoadScoreReturn[1].			//Add encoder stuff here
	AutonomousObjectScorer[1].Timeout = 1700;

	AutonomousObjectScorer[2].StepName = "WaitForStableBot";
	AutonomousObjectScorer[2].LiftPower = 20;		//Stop the lift, and stablalize robot.
	AutonomousObjectScorer[2].Timeout = 250;

	AutonomousObjectScorer[3].StepName = "Finished!";
	AutonomousObjectScorer[3].Timeout = -1;

	return 0;
}
//----------------------------------------------------< Get Input >---------------------------------------------\\

int getInput()
{
	//input code here
	//Joystick Inputs
	int errorcode = 0;
	stkDriveX = vexRT[Ch4];							//Left and Right Drive Joystick Channel
	stkDriveY = vexRT[Ch3];							//Up and Down Drive Joystick Channel
	stkLift1 = vexRT[Ch2];					//Lift Joystick Channel
	stkLift2 = vexRT[Ch2Xmtr2];					//Lift Joystick Channel
	//btnHoloStraight = vexRT[Btn7D];					//Holonomic/Straight-Drive Joystick Button
	//btnOldNewDrive = vexRT[Btn8D];
	btnFrontBackDrive = vexRT[Btn8U];
	gyrGyroscope = SensorValue[Gyro];
	btnIntakeIn1 = vexRT[Btn6U];
	btnIntakeOut1 = vexRT[Btn6D];
	btnIntakeIn2 = vexRT[Btn6UXmtr2];
	btnIntakeOut2 = vexRT[Btn6DXmtr2];
	btnLiftRestBack1 = vexRT[Btn5D];
	btnLiftRestFront1 = vexRT[Btn7U];
	btnLiftRestBack2 = vexRT[Btn5DXmtr2];
	btnLiftRestFront2 = vexRT[Btn7UXmtr2];
	//Digital Inputs
	//LeftLiftEncoder = SensorValue[LeftLiftEncoderPort];   //Uncomment when we get this installed
	//RightLiftEncoder = SensorValue[RightLiftEncoderPort]; //Uncomment when we get this installed
	LeftDriveEncoder = SensorValue[LeftDriveEncoderPort];
	RightDriveEncoder = SensorValue[RightDriveEncoderPort];
	BottomLiftLimitSwitch = SensorValue[BottomLiftLimitSwitchPort];
	MainBatteryVoltageAverage = nAvgBatteryLevel;
	MainBatteryVoltageLevel = nImmediateBatteryLevel;
	ButtonBitMap = nLCDButtons;
	LeftDisplayButton = (ButtonBitMap & 1) && 1;
	CenterDisplayButton = (ButtonBitMap & 2) && 1;
	RightDisplayButton = (ButtonBitMap & 4) && 1;
	return errorcode;
}

//-------------------------------------------< Processes >--------------------------------------------\\
int processAutonomous()
{
	int errorcode = 0;
	TAutonomous CurrentStep;
	if (AutonomousRoutine == 0)			//LoadScoreReturn
	{
		//CurrentStep = AutonomousLoadScoreReturn[AutonomousStep]; //This doesn't work in ROBOTC
		memcpy(CurrentStep, AutonomousLoadScoreReturn[AutonomousStep], sizeof(CurrentStep)); //This does
	}
	else if (AutonomousRoutine == 1)	//ObjectScorer
	{
		memcpy(CurrentStep, AutonomousObjectScorer[AutonomousStep], sizeof(CurrentStep)); //This does
	}
	else								//No Autonomous
	{
		CurrentStep.Timeout = -1;
		CurrentStep.StepName = "Preparing to PWN"
	}
	displayLCDNumber(0, 14, AutonomousStep, 1); //Debug line; implement in future
   	displayLCDString(1, 0, "                ");
   	displayLCDString(1, 0, CurrentStep.StepName);
	if (CurrentStep.Timeout != -1)			//If the trip statement isn't met
	{
		if (CurrentStep.LiftPower != 0 && CurrentStep.LiftPower >= -127 && CurrentStep.LiftPower <= 127)
		{
			motorLiftLeft = motorLiftRight = CurrentStep.LiftPower;
		}
		else if (CurrentStep.LiftPower == 128)
		{
			motorLiftLeft = motorLiftRight = 0;
		}
		if (CurrentStep.IntakePower  != 0 && CurrentStep.IntakePower >= -127 && CurrentStep.IntakePower <= 127)
		{
			motorIntakeBack = motorIntakeFront = CurrentStep.IntakePower;
		}
		else if (CurrentStep.IntakePower == 128)
		{
			motorIntakeBack = motorIntakeFront = 0;
		}
		if (CurrentStep.DriveType == STRAIGHT)
		{
			motorLeftDriveTrain = motorRightDriveTrain = CurrentStep.DrivePower;
		}
		else if (CurrentStep.DriveType == LEFTONEWHEELTURN)
		{
			motorLeftDriveTrain = 0;
			motorRightDriveTrain = CurrentStep.DrivePower;
		}
		else if (CurrentStep.DriveType == RIGHTONEWHEELTURN)
		{
			motorLeftDriveTrain = CurrentStep.DrivePower;
			motorRightDriveTrain = 0;
		}
		else if (CurrentStep.DriveType == BOTHWHEELTURN)
		{
			motorLeftDriveTrain = CurrentStep.DrivePower;
			motorRightDriveTrain = 0 - CurrentStep.DrivePower;
		}
		int StartTime = time1[T1];
		int StartGyro = gyrGyroscope;
		doOutput();
		int q = 0;
		while (q == 0)			// 'q' is the break variable
		{
			if (CurrentStep.Timeout != 0 && (time1[T1] - StartTime) >= CurrentStep.Timeout)
				q = 1;
			if (CurrentStep.GyroDegrees != 0 && (gyrGyroscope - StartGyro >= CurrentStep.GyroDegrees))
				q = 1;
			if (CurrentStep.EncoderTicks != 0 && (RightDriveEncoder >= CurrentStep.EncoderTicks))
				q = 1;
			if (CheckJoystick())
			{
				StartTask(usercontrol);
				StopTask(autonomous);
			}
		}
		if (CurrentStep.JumpToStep != 0 && ((CurrentStep.DigitalSensor != 0 && SensorValue[CurrentStep.DigitalSensor]) || CurrentStep.DigitalSensor == 0))
			AutonomousStep = CurrentStep.JumpToStep;
		else
			AutonomousStep++;
	}
	else
	{
		motorLiftLeft = motorLiftRight = 0;
		motorIntakeBack = motorIntakeFront = 0;
		motorLeftDriveTrain = motorRightDriveTrain = 0;
		if (CheckJoystick())
			{
				StartTask(usercontrol);
				StopTask(autonomous);
			}
	}
	return errorcode;
}

int processOperator()
{
	//Driver control code here
	int errorcode = 0;
	operatorDriveTrain();
	operatorLift();
	operatorIntake();
	Display();
	return errorcode;
}


//--------------------------------------------< Drive-train Code >-----------------------------------------------\\

int operatorDriveTrain()
{
	float JoystickAngleSin;			 					//Sine of the Drive Stick
	float JoystickAngleCos;								//Cosine of the Drive Stick

	ToggleCheck(btnOldNewDrive, btnOldNewDrivePressed, (int) OldNewDrive);
	ToggleCheck(btnFrontBackDrive, btnFrontBackDrivePressed, (int) FrontBackDrive);

	if (OldNewDrive == TRIGONOMETRIC)
	{
		joystickDrivePower = sqrt((stkDriveX*stkDriveX)+(stkDriveY*stkDriveY));	// Calculate Joystick Hypotenuse
		JoystickAngleSin = stkDriveY/JOYSTICKDRIVEMAX;							// Calculate Joystick Sin
		JoystickAngleCos = stkDriveX/JOYSTICKDRIVEMAX;							// Calculate Joystick Cosin
		motorLeftDriveTrain = (JoystickAngleSin + JoystickAngleCos) * joystickDrivePower;
		motorRightDriveTrain = (JoystickAngleSin - JoystickAngleCos) * joystickDrivePower;

		if(!(joystickDrivePower > JOYSTICKDEADZONE))	//If the Joystick hasn't been pushed far enough
		{
			motorLeftDriveTrain = 0;
			motorRightDriveTrain = 0;
		}
	}
	/*else //Old Drive
	{
		joystickDrivePower = sqrt((stkDriveX*stkDriveX)+(stkDriveY*stkDriveY));
		motorLeftDriveTrain = stkDriveY + stkDriveX;
		motorRightDriveTrain = stkDriveY - stkDriveX;

		if(joystickDrivePower > JOYSTICKDEADZONE)	//If the Joystick has been pushed far enough
		{
			motorLeftDriveTrain = (motorLeftDriveTrain > MOTORDRIVEMAX) ? MOTORDRIVEMAX : motorLeftDriveTrain;
			motorRightDriveTrain = (motorRightDriveTrain > MOTORDRIVEMAX) ? MOTORDRIVEMAX : motorRightDriveTrain;
			motorLeftDriveTrain = (motorLeftDriveTrain < (0-MOTORDRIVEMAX)) ? (0-MOTORDRIVEMAX) : motorLeftDriveTrain;
			motorRightDriveTrain = (motorRightDriveTrain < (0-MOTORDRIVEMAX)) ? (0-MOTORDRIVEMAX) : motorRightDriveTrain;
		}
		else
		{
			motorLeftDriveTrain = 0;
			motorRightDriveTrain = 0;
		}
	}*/ //*********Commented because we ran out of space on the brain!
	RangeCheck(0-MOTORDRIVEMAX, motorLeftDriveTrain, MOTORDRIVEMAX);
	RangeCheck(0-MOTORDRIVEMAX, motorRightDriveTrain, MOTORDRIVEMAX);

	//return errorcode;
	return 0;
}

//------------------------------------Lift Code-------------------------------------//

int operatorLift()
{
	/*PIDLift.Error = SensorValue[LeftLiftEncoderPort] - SensorValue[RightLiftEncoderPort];
	PIDLift.TargetValue = stkLift;
	motorLiftLeft = PIDLift.TargetValue + PIDLift.Output;
	motorLiftRight = PIDLift.TargetValue - PIDLift.Output;*/
	//motorLift = stkLift;
	if (btnLiftRestBack1 && btnLiftRestFront1)
	{
		stkLift = 0;
	}
	else if (btnLiftRestBack2 && btnLiftRestFront2)
	{
		stkLift = 0;
	}
	else if (abs(stkLift1) > JOYSTICKDEADZONE)
	{
		stkLift = stkLift1;
	}
	else if (abs(stkLift2) > JOYSTICKDEADZONE)
	{
		stkLift = stkLift2;
	}
	else if (BottomLiftLimitSwitch)
	{
		stkLift = 0;
	}
	else
	{
		stkLift = 10;
	}

	motorLiftLeft = stkLift;
	motorLiftRight = stkLift;
	return 0;
}

//------------------------------------Intake Code-------------------------------------//

int operatorIntake()
{
  	if(btnIntakeIn1 == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeOut1 == 1)
    {
	  motorIntakeFront = -127;
      motorIntakeBack = -127;
   }
    else if(btnIntakeIn2 == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeOut2 == 1)
    {
      motorIntakeFront = -127;
      motorIntakeBack = -127;
    }
    else
    {
      motorIntakeFront = 0;
      motorIntakeBack = 0;
    }
  return 1;
}

int PickAutonomous()
{
	TotalMenuItems = 3;
	CurrentMenuItem = 0;
	while(true)
	{
		getInput();
		if (DisplayNeedsRefreshing)
		{
			DisplayMenu("Pick Autonomous", AutonomousMenu[CurrentMenuItem]);
			DisplayNeedsRefreshing = 0;
		}
		DisplayButtonHandling();
		if (IsMenuItemActivated())
		{
			AutonomousRoutine = CurrentMenuItem;
			CurrentMenuItem = 0;
			CurrentMenu = 0;
			break;
		}
	}
	return 0;
}

int Display()
{
	switch(CurrentMenu)
	{
		case 1:
			CurrentMenu = 0;
			StartTask(autonomous);
			StopTask(usercontrol);
			break;
		case 2:
			PickAutonomous();
			CurrentMenu = 0;
			break;
		case 3:
			//StopTask(usercontrol);
			//EnableOutput = 0;
			allMotorsOff();
			MotorTest();
			//EnableOutput = 1;
			CurrentMenu = 0;
			break;
		default:
			DisplayMainMenu();
			break;
	}
	return 0;
}

void DisplayMainMenu()
{
	TotalMenuItems = 7;
	if (DisplayNeedsRefreshing)
	{
		DisplayMenu("Main Menu", MainMenu[CurrentMenuItem]);
		DisplayNeedsRefreshing = 0;
	}
	DisplayButtonHandling();
	if (IsMenuItemActivated())
	{
		CurrentMenu = CurrentMenuItem + 1;
	}
}

void DisplayMenu(string MenuTitle, string MenuItem)
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, MenuTitle);
	displayLCDCenteredString(1, MenuItem);
}

void DisplayButtonHandling()
{
	if (LeftDisplayButton && !LeftDisplayButtonPressed && CurrentMenuItem > 0)
	{
		CurrentMenuItem--;
		DisplayNeedsRefreshing = 1;
	}
	LeftDisplayButtonPressed = LeftDisplayButton;
	if (RightDisplayButton && !RightDisplayButtonPressed && CurrentMenuItem < TotalMenuItems - 1)
	{
		CurrentMenuItem++;
		DisplayNeedsRefreshing = 1;
	}
	RightDisplayButtonPressed = RightDisplayButton;
	if (CenterDisplayButton && !CenterDisplayButtonPressed)
	{
		ActivateMenuItem = 1;
		DisplayNeedsRefreshing = 1;
	}
	CenterDisplayButtonPressed = CenterDisplayButton;
}

int IsMenuItemActivated() //This function makes sure that the activate action happens only when it is supposed to
{
	int Dummy = ActivateMenuItem;
	ActivateMenuItem = 0;
	return Dummy;
}

int CheckJoystick()
{
	//Are the joystick tests
	if (abs(vexRT[Ch1]) > JOYSTICKDEADZONE || abs(vexRT[Ch2]) > JOYSTICKDEADZONE || abs(vexRT[Ch3]) > JOYSTICKDEADZONE || abs(vexRT[Ch4]) > JOYSTICKDEADZONE)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void ToggleCheck (int CurrentButtonState, int &WasAlreadyPressed, int &ToBeToggled)
{
	if (CurrentButtonState && !WasAlreadyPressed)
	{
		ToBeToggled = !ToBeToggled;			//If Old Drive, switch to New Drive. If New Drive, switch to Old Drive
	}
	WasAlreadyPressed = CurrentButtonState;
}

void RangeCheck (int LowerLimit, int &Value, int UpperLimit)
{
	if (Value > UpperLimit)
	{
		Value = UpperLimit;
	}
	if (Value < LowerLimit)
	{
		Value = LowerLimit;
	}
}

void PIDController(TPidSystem &PIDObject)
{
	PIDObject.Integral = ((2 / 3) * PIDObject.Integral) + PIDObject.Error;
	PIDObject.Derivative = PIDObject.Error - PIDObject.LastError;
	PIDObject.Output = (PIDObject.Error * PIDObject.Kp) + (PIDObject.Integral * PIDObject.Ki) +(PIDObject.Derivative * PIDObject.Kd);
}

void MotorTest()
{
	int i;
	displayLCDString(0, 0, "Motor Test      ");
	displayLCDString(1, 0, "MTR:   PWR:     ");
	for(i = 1; i <= 10; i++)
	{
		displayLCDString(1, 4, "   ");
		displayLCDNumber(1, 5, i, 0);
		displayLCDNumber(1, 12, 127);
		motor[i - 1] = 127;
		wait1Msec(750);
		displayLCDString(1, 12, "    ");
		displayLCDNumber(1, 12, 0, 0);
		motor[i - 1] = 0;
		wait1Msec(250);
		displayLCDString(1, 12, "    ");
		displayLCDNumber(1, 12, -127, 0);
		motor[i - 1] = -127;
		wait1Msec(750);
		displayLCDString(1, 12, "    ");
		displayLCDNumber(1, 12, 0, 0);
		motor[i - 1] = 0;
		wait1Msec(250);
	}
}
int doOutput()
{
	//output code here
	int errorcode = 0;
	if (FrontBackDrive == NORMAL)
	{
		motor[DriveLF] = motorLeftDriveTrain;
		motor[DriveLB] = motorLeftDriveTrain;
		motor[DriveRF] = motorRightDriveTrain;
		motor[DriveRB] = motorRightDriveTrain;

		motor[IntakeRF] = motorIntakeFront;
		motor[IntakeRB] = motorIntakeBack;
		motor[IntakeLF] = motorIntakeFront;
		motor[IntakeLB] = motorIntakeBack;
	}
	else
	{
		motor[DriveRF] = 0 - motorLeftDriveTrain;
		motor[DriveRB] = 0 - motorLeftDriveTrain;
		motor[DriveLF] = 0 - motorRightDriveTrain;
		motor[DriveLB] = 0 - motorRightDriveTrain;

		motor[IntakeLF] = 0 - motorIntakeBack;
		motor[IntakeLB] = 0 - motorIntakeFront;
		motor[IntakeRF] = 0 - motorIntakeBack;
		motor[IntakeRB] = 0 - motorIntakeFront;
	}
	motor[LiftL] = motorLiftLeft;
	motor[LiftR] = motorLiftRight;

	return errorcode;
}
