#pragma config(UART_Usage, UART2, VEX_2x16_LCD, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro,                sensorGyro)
#pragma config(Sensor, dgtl1,  LeftDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LeftLiftEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  RightLiftEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Holonomic1,          sensorDigitalOut)
#pragma config(Sensor, dgtl12, AutonomousJumper,    sensorDigitalIn)
#pragma config(Motor,  port1,           IntakeLF,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port2,           IntakeRF,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           DriveLF,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           DriveRF,       tmotorNormal, openLoop)
#pragma config(Motor,  port5,           LiftL,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           LiftR,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           DriveLB,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           DriveRB,       tmotorNormal, openLoop)
#pragma config(Motor,  port9,           IntakeLB,      tmotorNormal, openLoop)
#pragma config(Motor,  port10,          IntakeRB,      tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//
//Code made with love by Josiah Krutz and Ryan Plummer. Addition support provided by:
//http://robotc.net/forums/viewtopic.php?f=52&t=1280
//Josh Duff


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"				//Main competition background code...do not modify!


//Constants
#define numMessages 10
#define JOYSTICKDRIVEMAX 127
#define MOTORDRIVEMAX 127
#define JOYSTICKINPUTS 19
#define LIFTKP 0.2
#define LIFTOFFSET 2
#define IN 127
#define OUT -127
#define UP 127
#define DOWN -127
#define FORWARD 127
#define BACKWARD -127
#define STOP 0

//Enums
typedef enum
{
	STRAIGHT,
	LEFTONEWHEELTURN,
	RIGHTONEWHEELTURN,
	BOTHWHEELTURN
} TAutoDriveType;

typedef enum
{
	SIMPLE,
	TRIGONOMETRIC
} TDriveAlgorithm;

typedef enum
{
	NORMAL,
	REVERSED
} TRobotDirection;

//---------------------------------------------< Structs >-----------------------------------------------\\

typedef struct
{
	float Kp;
	float Ki;
	float Kd;
	int Integral;
	int Derivative;
	int Error;
	float LastError;
	int TargetValue;
	float Output;
	float Offset;

} TPidSystem;

typedef struct
{
	string Line1;
	string Line2;
	bool LeftButton;
	bool CenterButton;
	bool RightButton;
} TDisplay;

typedef struct
{
	//string StepName;
	//Outputs
	int LiftPower;
	int FrontIntakePower;
	int BackIntakePower;
	TAutoDriveType DriveType;
	int DrivePower;
	//Trip values
	int Timeout;
	int GyroDegrees;
	int EncoderTicks;
	int JumpToStep;
} TAutonomous;


//-------------------------------------< Global Variable Declarations >-----------------------------------------\\
// btn = Button (Input), stk = Stick (Input), pneu = Pneumatics (Output), motor = Motor (Output)

//Inputs
float stkDriveX;									//Current X value of drive stick (-127 to 127)
float stkDriveY;							 		//Current Y value of drive stick (-127 to 127)
int stkLift;										//Lift Joystick Channel
int stkLift1;
int stkLift2;
float joystickDrivePower;							//Current distance of drive stick from center
int joystickDriveDeadzone = 20;						//Distance to push stick before affecting robot
int btnHoloStraight;								//Holonomic/Straight-Drive Joystick Button
int btnOldNewDrive;									//Old/New-Drive Joystick Button
int btnFrontBackDrive;
int gyrGyroscope;
int btnIntakeFrontIn1;
int btnIntakeFrontOut1;
int btnIntakeBackIn1;
int btnIntakeBackOut1;
int btnIntakeFrontIn2;
int btnIntakeFrontOut2;
int btnIntakeBackIn2;
int btnIntakeBackOut2;
int btnIntakeIn1;
int btnIntakeOut1;
int btnIntakeIn2;
int btnIntakeOut2;
int btnFrontIntakeOnly1;
int btnFrontIntakeOnly2;
float MainBatteryVoltageAverage;
float MainBatteryVoltageLevel;
int ButtonBitMap;
int LeftDisplayButton;
int CenterDisplayButton;
int RightDisplayButton;
int LeftLiftEncoder;
int RightLiftEncoder;
int LeftDriveEncoder;
int RightDriveEncoder;

//Outputs
int motorLeftDriveTrain;							//Value assigned to motors on the left of the robot
int motorRightDriveTrain;							//Value assigned to motors on the right of the robot
int motorLiftLeft;									//Value assigned to left lift motors
int motorLiftRight;									//Value assigned to right lift motors
int motorIntakeFront;								//gets put into the font of the intake mechanism
int motorIntakeBack;								//Gets put into the beack of the intake mechanism
int pneuHoloStraight;								//Holonomic/Straight-Drive Pneumatic Variable

//Stuff that needs to remembered
int btnHoloStraightPressed;							//Holonomic/Straight-Drive Joystick Button Pressed Variable
int btnOldNewDrivePressed;							//Old/New-Drive Joystick Button Pressed Variable
int bOldNewDrive;									//Old/New-Drive Boolean Variable (0 = Straight, 1 = Holo)
int btnFrontBackDrivePressed;
int bFrontBackDrive;
int LeftDisplayButtonPressed;
int CenterDisplayButtonPressed;
int RightDisplayButtonPressed;
int ActivateMenuItem = 0;
int DisplayNeedsRefreshing = 1;
int CurrentMenu = 0;
int CurrentMenuItem = 0;
int TotalMenuItems = 7;
int MenuStack[64];
string MainMenu[6] = {"Show Variables", "Run Autonomous", "Edit Autonomous", "Make Autonomous", "Show Errors", "Shutdown"};
TPidSystem PIDLift;
TAutonomous AutonomousLoadScoreReturn[10];
int AutonomousStep = 0;

//void pre_auton();
//task autonomous()
//task usercontrol();
int initializeDisplay();
int initializePID();
int initializeGyro();
int initializeAutonomous();
int getInput();
int processAutonomous();
int processOperator();
int CheckJoystick();
int Display();
int operatorDriveTrain();
int operatorLift();
int doOutput();
int operatorIntake();

void pre_auton()
{
	initializeDisplay();
	//initializeGyro(); 							//Uncomment when we start using Gyro Sensor
	initializePID();
	initializeAutonomous();
	while (bIfiRobotDisabled);						//Keep the message displayed while robot is disabled
}

//----------------------------------------------< Autonomous >-----------------------------------------------\\

void Drive(int Power)
{
	//motorLeftDriveTrain = motorRightDriveTrain = Power;
	motor[DriveRF] = Power;
	motor[DriveRB] = Power;
	motor[DriveLF] = Power;
	motor[DriveLB] = Power;
}

void SingleTurnRight(int Power)
{
	motor[DriveRF] = 0;
	motor[DriveRB] = 0;
	motor[DriveLF] = Power;
	motor[DriveLB] = Power;
}

void SingleTurnLeft(int Power)
{
	motor[DriveRF] = Power;
	motor[DriveRB] = Power;
	motor[DriveLF] = 0;
	motor[DriveLB] = 0;
}

void GyroTurnLeft(int TenthOfDegrees)
{
	int Power = 127;
	motor[DriveRF] = Power;
	motor[DriveRB] = Power;
	motor[DriveLF] = 0 - Power;
	motor[DriveLB] = 0 - Power;
	while(abs(SensorValue[Gyro]) < TenthOfDegrees);
	motor[DriveRF] = 0;
	motor[DriveRB] = 0;
	motor[DriveLF] = 0;
	motor[DriveLB] = 0;
}

void GyroTurnRight(int TenthOfDegrees)
{
	int Power = 127;
	motor[DriveRF] = 0 - Power;
	motor[DriveRB] = 0 - Power;
	motor[DriveLF] = Power;
	motor[DriveLB] = Power;
	while(abs(SensorValue[Gyro]) < TenthOfDegrees);
	motor[DriveRF] = 0;
	motor[DriveRB] = 0;
	motor[DriveLF] = 0;
	motor[DriveLB] = 0;
}

void Lift(int Power)
{
	motor[LiftL] = Power;
	motor[LiftR] = Power;
}

void Intake(int Power)
{
	motor[IntakeLF] = Power;
	motor[IntakeRF] = Power;
	motor[IntakeLB] = Power;
	motor[IntakeRB] = Power;
}

task autonomous()
{
	int AutonJump = SensorValue[AutonomousJumper];
	if(true)
	{
		Lift(UP);				//Raise Lift
		wait1Msec(1100);
		while(true)
		{
			Drive(FORWARD);			//Drive
			wait1Msec(1700);
			Drive(STOP);
			Lift(20);				//Hold the cage up
			wait1Msec(500);
			Intake(OUT);			//Release the Muffins!
			wait1Msec(4000);
			Intake(STOP);
			if (AutonJump)
			{
				SingleTurnLeft(-127);
			}
			else
			{
				SingleTurnRight(-127);
			}
			wait1Msec(250);
			Drive(BACKWARD);
			wait1Msec(1800);
			Drive(STOP);
		  	while (nLCDButtons == 0) //Again again!
		  	{
		  	}
	 	  	wait1Msec(200);
		}
	}
}

/*
task autonomous()
{
	while (true)
	{
		getInput();
		processAutonomous();
		//doOutput();
	}
}*/

//-------------------------------------------< Operator Control >--------------------------------------------\\
task usercontrol()
{
	while (!bIfiAutonomousMode)
	{
		getInput();
		processOperator();
		doOutput();
	}

}
//---------------------------------------------< Initialize >---------------------------------------------------\\
int initializeDisplay()
{
	//clearLCDLine(0);
    //clearLCDLine(1);
    bLCDBacklight = true;							//Turn Backlight on
	displayLCDPos(1, 0);							//Move "Cursor" to first spot
	displayNextLCDString("Ready to PWN :-D");		//Display motivational message
	return 0;
}

int initializePID()
{
	PIDLift.Kp = 1;
	PIDLift.Ki = 0.1;
	PIDLift.Kd = 5;
	PIDLift.Integral = 0;
	PIDLift.Derivative = 0;
	PIDLift.Error = 0;
	PIDLift.LastError = 0;
	PIDLift.TargetValue = 0;
	PIDLift.Output = 0;
	return 1;
}

int initializeGyro()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in1] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
	return 0;
}

int initializeAutonomous()
{
	//LoadScoreReturn
	AutonomousLoadScoreReturn[0].LiftPower = UP;		//Lift Up
	AutonomousLoadScoreReturn[0].Timeout = 1100;
	//Repeat starting here
	AutonomousLoadScoreReturn[1].DriveType = STRAIGHT;	//Drive toward Goal and Lift
	AutonomousLoadScoreReturn[1].DrivePower = FORWARD;
	//AutonomousLoadScoreReturn[1].			//Add encoder stuff here
	AutonomousLoadScoreReturn[1].Timeout = 1500;
	AutonomousLoadScoreReturn[2].Timeout = 500; 		//Wait for cage to reach final height
	AutonomousLoadScoreReturn[3].LiftPower = STOP;		//Stop the lift, and stablalize robot.
	AutonomousLoadScoreReturn[3].Timeout = 500;
	AutonomousLoadScoreReturn[4].FrontIntakePower = OUT;	//Release the Barrells!
	AutonomousLoadScoreReturn[4].BackIntakePower = OUT;
	AutonomousLoadScoreReturn[4].Timeout = 4000;
	AutonomousLoadScoreReturn[5].FrontIntakePower = STOP;	//Release the Barrells!
	AutonomousLoadScoreReturn[5].BackIntakePower = STOP;
	//AutonomousLoadScoreReturn[6].

	AutonomousLoadScoreReturn[9].Timeout = -1;
	return 0;
}
//----------------------------------------------------< Get Input >---------------------------------------------\\

int getInput()
{
	//input code here
	//Joystick Inputs
	int errorcode = 0;
	stkDriveX = vexRT[Ch4];							//Left and Right Drive Joystick Channel
	stkDriveY = vexRT[Ch3];							//Up and Down Drive Joystick Channel
	stkLift1 = vexRT[Ch2];					//Lift Joystick Channel
	stkLift2 = vexRT[Ch2Xmtr2];					//Lift Joystick Channel
	if ((stkLift1 < (0 - joystickDriveDeadzone)) || (stkLift1 > (joystickDriveDeadzone)) )
	{
		stkLift = stkLift1;
	}
	else if ((stkLift2 < (0 - joystickDriveDeadzone)) || (stkLift2 > (joystickDriveDeadzone)) )
	{
		stkLift = stkLift2;
	}
	else
	{
		stkLift = 10;
	}

	//btnHoloStraight = vexRT[Btn7D];					//Holonomic/Straight-Drive Joystick Button
	//btnOldNewDrive = vexRT[Btn8D];
	btnFrontBackDrive = vexRT[Btn8U];
	gyrGyroscope = SensorValue[Gyro];
	btnIntakeFrontIn1 = vexRT[Btn6U];
	btnIntakeFrontOut1 = vexRT[Btn6D];
	btnIntakeBackIn1 = vexRT[Btn5U];
	btnIntakeBackOut1 = vexRT[Btn5D];
	btnIntakeFrontIn2 = vexRT[Btn6UXmtr2];
	btnIntakeFrontOut2 = vexRT[Btn6DXmtr2];
	btnIntakeBackIn2 = vexRT[Btn5UXmtr2];
	btnIntakeBackOut2 = vexRT[Btn5DXmtr2];
	//Digital Inputs
	LeftLiftEncoder = SensorValue[LeftLiftEncoderPort];
	//RightLiftEncoder = SensorValue[RightLiftEncoderPort]; //Uncomment when we get this installed
	LeftDriveEncoder = SensorValue[LeftDriveEncoderPort];
	RightDriveEncoder = SensorValue[RightDriveEncoderPort];
	MainBatteryVoltageAverage = nAvgBatteryLevel;
	MainBatteryVoltageLevel = nImmediateBatteryLevel;
	ButtonBitMap = nLCDButtons;
	LeftDisplayButton = (ButtonBitMap & 1) && 1;
	CenterDisplayButton = (ButtonBitMap & 2) && 1;
	RightDisplayButton = (ButtonBitMap & 4) && 1;
	return errorcode;
}

//-------------------------------------------< Processes >--------------------------------------------\\
int processAutonomous()
{
	int errorcode = 0;
	TAutonomous CurrentStep;
	//CurrentStep = AutonomousLoadScoreReturn[AutonomousStep]; //This doesn't work in ROBOTC
	memcpy(CurrentStep, AutonomousLoadScoreReturn[AutonomousStep], sizeof(CurrentStep)); //This does
	//displayLCDNumber(1, 0, AutonomousStep, nPrecision); //Debug line; implement in future
    //displayLCDString(1, 0, sString);
	if (CurrentStep.Timeout != -1)			//If the trip statement isn't met
	{
		if (CurrentStep.LiftPower != 0)
		{
			motorLiftLeft = motorLiftRight = CurrentStep.LiftPower;
		}
		if (CurrentStep.DriveType == STRAIGHT)
		{
			motorLeftDriveTrain = CurrentStep.DrivePower;
			motorRightDriveTrain = CurrentStep.DrivePower;
		}
		ClearTimer(T1);
		while (time1[T1] < CurrentStep.Timeout);
		AutonomousStep++;
		//writeDebugStream("LiftHeight1: %d\n", CurrentStep.LiftPower);
	}
	//writeDebugStreamLine("Check Joystick: %d", CheckJoystick());

	if (CheckJoystick())
	{
		StartTask(usercontrol);
		StopTask(autonomous);
	}
	return errorcode;
}

int processOperator()
{
	//Driver control code here
	int errorcode = 0;
	operatorDriveTrain();
	operatorLift();
	operatorIntake();
	Display();
	return errorcode;
}


void PIDController(TPidSystem &PIDObject)
{
	PIDObject.Integral = ((2 / 3) * PIDObject.Integral) + PIDObject.Error;
	PIDObject.Derivative = PIDObject.Error - PIDObject.LastError;
	PIDObject.Output = (PIDObject.Error * PIDObject.Kp) + (PIDObject.Integral * PIDObject.Ki) +(PIDObject.Derivative * PIDObject.Kd);
}

int IsMenuItemActivated() //This function makes sure that the activate action happens only when it is supposed to
{
	int Dummy = ActivateMenuItem;
	ActivateMenuItem = 0;
	return Dummy;
}
void DisplayButtonHandling()
{
	if (LeftDisplayButton && !LeftDisplayButtonPressed && CurrentMenuItem > 0)
	{
		CurrentMenuItem--;
		DisplayNeedsRefreshing = 1;
	}
	LeftDisplayButtonPressed = LeftDisplayButton;
	if (RightDisplayButton && !RightDisplayButtonPressed && CurrentMenuItem < TotalMenuItems - 1)
	{
		CurrentMenuItem++;
		DisplayNeedsRefreshing = 1;
	}
	RightDisplayButtonPressed = RightDisplayButton;
	if (CenterDisplayButton && !CenterDisplayButtonPressed)
	{
		ActivateMenuItem = 1;
		DisplayNeedsRefreshing = 1;
	}
	CenterDisplayButtonPressed = CenterDisplayButton;
}

void DisplayMenu(string MenuTitle, string MenuItem)
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, MenuTitle);
	displayLCDCenteredString(1, MenuItem);
}

int CheckJoystick()
{
	//Are the joystick tests
	if (vexRT[Ch1] > 20 || vexRT[Ch1] < -20 || vexRT[Ch2] > 20 || vexRT[Ch2] < -20 || vexRT[Ch3] > 20 || vexRT[Ch3] < -20 || vexRT[Ch4] > 20 || vexRT[Ch4] < -20)
		return true;
	else
		return false;
}

void DisplayMainMenu()
{
	TotalMenuItems = 6;
	if (DisplayNeedsRefreshing)
	{
		DisplayMenu("Main Menu", MainMenu[CurrentMenuItem]);
		DisplayNeedsRefreshing = 0;
	}
	DisplayButtonHandling();
	if (IsMenuItemActivated())
	{
		CurrentMenu = CurrentMenuItem + 1;
	}
}

int Display()
{

	switch(CurrentMenu)
	{
		case 2:
			CurrentMenu = 0;
			StartTask(autonomous);
			StopTask(usercontrol);
			break;
		default:
			DisplayMainMenu();
			break;
	}
	return 0;
}

void ToggleCheck (int CurrentButtonState, int &WasAlreadyPressed, int &ToBeToggled)
{
	if (CurrentButtonState && !WasAlreadyPressed)
	{
		ToBeToggled = !ToBeToggled;			//If Old Drive, switch to New Drive. If New Drive, switch to Old Drive
	}
	WasAlreadyPressed = CurrentButtonState;
}

void RangeCheck (int LowerLimit, int &Value, int UpperLimit)
{
	if (Value > UpperLimit)
	{
		Value = UpperLimit;
	}
	if (Value < LowerLimit)
	{
		Value = LowerLimit;
	}
}

//--------------------------------------------< Drive-train Code >-----------------------------------------------\\

int operatorDriveTrain()
{
	int joystickDriveMax = 127;			 				//Maximum distance of drive stick from center
	int motorDriveMax = 127;							//Maximum power we want our motors to go
	float JoystickAngleSin;			 					//Sine of the Drive Stick
	float JoystickAngleCos;								//Cosine of the Drive Stick

	ToggleCheck(btnOldNewDrive, btnOldNewDrivePressed, bOldNewDrive);
	ToggleCheck(btnFrontBackDrive, btnFrontBackDrivePressed, bFrontBackDrive);

	if (!bOldNewDrive)
	{
		joystickDrivePower = sqrt((stkDriveX*stkDriveX)+(stkDriveY*stkDriveY));	// Calculate Joystick Hypotenuse
		JoystickAngleSin = stkDriveY/joystickDriveMax;							// Calculate Joystick Sin
		JoystickAngleCos = stkDriveX/joystickDriveMax;							// Calculate Joystick Cosin
		motorLeftDriveTrain = (JoystickAngleSin + JoystickAngleCos) * joystickDrivePower;
		motorRightDriveTrain = (JoystickAngleSin - JoystickAngleCos) * joystickDrivePower;

		if(!(joystickDrivePower > joystickDriveDeadzone))	//If the Joystick hasn't been pushed far enough
		{
			motorLeftDriveTrain = 0;
			motorRightDriveTrain = 0;
		}
	}
	/*else //Old Drive
	{
		joystickDrivePower = sqrt((stkDriveX*stkDriveX)+(stkDriveY*stkDriveY));
		motorLeftDriveTrain = stkDriveY + stkDriveX;
		motorRightDriveTrain = stkDriveY - stkDriveX;

		if(joystickDrivePower > joystickDriveDeadzone)	//If the Joystick has been pushed far enough
		{
			motorLeftDriveTrain = (motorLeftDriveTrain > motorDriveMax) ? motorDriveMax : motorLeftDriveTrain;
			motorRightDriveTrain = (motorRightDriveTrain > motorDriveMax) ? motorDriveMax : motorRightDriveTrain;
			motorLeftDriveTrain = (motorLeftDriveTrain < (0-motorDriveMax)) ? (0-motorDriveMax) : motorLeftDriveTrain;
			motorRightDriveTrain = (motorRightDriveTrain < (0-motorDriveMax)) ? (0-motorDriveMax) : motorRightDriveTrain;
		}
		else
		{
			motorLeftDriveTrain = 0;
			motorRightDriveTrain = 0;
		}
	}*/ //*********Commented because we ran out of space on the brain!
	RangeCheck(0-motorDriveMax, motorLeftDriveTrain, motorDriveMax);
	RangeCheck(0-motorDriveMax, motorRightDriveTrain, motorDriveMax);

	//return errorcode;
	return 0;
}

int operatorLift()
{
	PIDLift.Error = SensorValue[LeftLiftEncoderPort] - SensorValue[RightLiftEncoderPort];
	PIDLift.TargetValue = stkLift;
	motorLiftLeft = PIDLift.TargetValue + PIDLift.Output;
	motorLiftRight = PIDLift.TargetValue - PIDLift.Output;
	//motorLift = stkLift;
	return 0;
}

//------------------------------------Intake Code-------------------------------------//

int operatorIntake()
{
	//Front Intake
  	if(btnIntakeFrontIn1 == 1)
    {
    	motorIntakeFront = 127;
    }
    else if(btnIntakeFrontOut1 == 1)
    {
		motorIntakeFront = -127;
    }
    else if(btnIntakeFrontIn2 == 1)
    {
    	motorIntakeFront = 127;
    }
    else if(btnIntakeFrontOut2 == 1)
    {
	  	motorIntakeFront = -127;
    }
    else
    {
    	motorIntakeFront = 0;
    }

    //Back Intake
    if(btnIntakeBackIn1 == 1)
    {
    	motorIntakeBack = 127;
    }
    else if(btnIntakeBackOut1 == 1)
    {
		motorIntakeBack = -127;
    }
    else if(btnIntakeBackIn2 == 1)
    {
    	motorIntakeBack = 127;
    }
    else if(btnIntakeBackOut2 == 1)
    {
	  	motorIntakeBack = -127;
    }
    else
    {
    	motorIntakeBack = 0;
    }
  return 1;
}

int doOutput()
{
	//output code here
	int errorcode = 0;
	if(bFrontBackDrive)
	{
		motor[DriveRF] = 0 - motorLeftDriveTrain;
		motor[DriveRB] = 0 - motorLeftDriveTrain;
		motor[DriveLF] = 0 - motorRightDriveTrain;
		motor[DriveLB] = 0 - motorRightDriveTrain;

		motor[IntakeLF] = 0 - motorIntakeBack;
		motor[IntakeLB] = 0 - motorIntakeFront;
		motor[IntakeRF] = 0 - motorIntakeBack;
		motor[IntakeRB] = 0 - motorIntakeFront;

	}
	else
	{
		motor[DriveLF] = motorLeftDriveTrain;
		motor[DriveLB] = motorLeftDriveTrain;
		motor[DriveRF] = motorRightDriveTrain;
		motor[DriveRB] = motorRightDriveTrain;

		motor[IntakeRF] = motorIntakeFront;
		motor[IntakeRB] = motorIntakeBack;
		motor[IntakeLF] = motorIntakeFront;
		motor[IntakeLB] = motorIntakeBack;
	}
	motor[LiftL] = motorLiftLeft;
	motor[LiftR] = motorLiftRight;

	return errorcode;
}
