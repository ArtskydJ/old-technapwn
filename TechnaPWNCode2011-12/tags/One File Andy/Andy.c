#pragma config(UART_Usage, UART2, VEX_2x16_LCD, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, in2,    LeftLightSensorPort, sensorReflection)
#pragma config(Sensor, in3,    RightLightSensorPort, sensorReflection)
#pragma config(Sensor, dgtl1,  RightLiftEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LeftLiftEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  LeftDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, BottomLeftLiftLimitSwitchPort, sensorTouch)
#pragma config(Sensor, dgtl11, BottomRightLiftLimitSwitchPort, sensorTouch)
#pragma config(Sensor, dgtl12, AutonomousJumperPort, sensorDigitalIn)
#pragma config(Motor,  port1,           DriveBL,       tmotorNormal, openLoop)
#pragma config(Motor,  port2,           IntakeL,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           LiftBR,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           LiftBL,        tmotorNormal, openLoop)
#pragma config(Motor,  port5,           DriveFR,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           DriveFL,       tmotorNormal, openLoop)
#pragma config(Motor,  port7,           LiftFL,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           LiftFR,        tmotorNormal, openLoop)
#pragma config(Motor,  port9,           IntakeR,       tmotorNormal, openLoop)
#pragma config(Motor,  port10,          DriveBR,       tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#define _SIMULATED		// SIMULATOR SWITCH - FOR COMPETITION THIS SHOULD BE COMMENTED OUT!

//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

// ************************************************************************************
// * The following code was creatively composed by Josiah Krutz and Ryan Plummer.
// * Addition support provided by:
// *  - http://robotc.net/forums/viewtopic.php?f=52&t=1280
// *  - Josh Duff
// ************************************************************************************


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#ifdef _SIMULATED
	#include "Vex_Techna_PWN_Debug_Includes.c"			//Debug code - enable
#else
	#include "Vex_Competition_Includes.c"				//Main competition background code...do not modify!
#endif

//Constants
#define LIFTENCODERCONSTANT 1
#define DRIVEENCODERCONSTANT 1
#define FLOORHEIGHT 10
#define LOWGOALHEIGHT 100
#define MIDDLEGOALHEIGHT 200
#define HIGHGOALHEIGHT 300
#define JOYSTICKDRIVEMAX 127
#define MOTORDRIVEMAX 127
#define JOYSTICKDEADZONE 20
#define RIGHTDRIVESLOWDOWNCONSTANT 1
#define MOTORRAMPCONSTANT 0.3
#define IN 127
#define OUT -127
#define UP 127
#define DOWN -127
#define FORWARD 127
#define BACKWARD -127
#define LEFT -127
#define RIGHT 127
#define STOP 128

//Enums
typedef enum
{
	STRAIGHT,
	LEFTONEWHEELTURN,
	RIGHTONEWHEELTURN,
	BOTHWHEELTURN,
	STRAFESIDEWAYS
} TAutoDriveType;

typedef enum
{
	PLAIN,
	EXPERIMENT
} TDriveAlgorithm;

typedef enum
{
	NORMAL,
	REVERSED
} TRobotDirection;

typedef enum
{
	NOGOALBUTTON,
	LOWGOALBUTTON,
	MIDDLEGOALBUTTON,
	HIGHGOALBUTTON
} TGoalHeightButton;

typedef enum
{
  ANALOG1 = -1,
  NOCONDITION = 0,
  ANALOG2 = 1,
  ANALOG3 = 2,
  ANALOG4 = 3,
  ANALOG5 = 4,
  ANALOG6 = 5,
  ANALOG7 = 6,
  ANALOG8 = 7,
  DIGITAL1 = 8,
  DIGITAL2 = 9,
  DIGITAL3 = 10,
  DIGITAL4 = 11,
  DIGITAL5 = 12,
  DIGITAL6 = 13,
  DIGITAL7 = 14,
  DIGITAL8 = 15,
  DIGITAL9 = 16,
  DIGITAL10 = 17,
  DIGITAL11 = 18,
  DIGITAL12 = 19,
  LEFTDISPLAYBUTTON = 20,
  CENTERDISPLAYBUTTON = 21,
  RIGHTDISPLAYBUTTON = 22,
  ANYDISPLAYBUTTON = 23
} TJumpCondition;

//---------------------------------------------< Structs >-----------------------------------------------

typedef struct
{
	float Kp;
	float Ki;
	float Kd;
	float Integral;
	float Derivative;
	float Error;
	float LastError;
	float TargetValue;
	float TargetPower;
	float Output;
} TPidSystem;

typedef struct
{
	string StepName;
	//Outputs
	int LiftPower;
	//int LiftHeight;
	int IntakePower;
	TAutoDriveType DriveType;
	int DrivePower;
	//Trip values
	int Timeout;
	int GyroDegrees;
	int EncoderTicks;
	//Functions
	TJumpCondition JumpCondition;
	int JumpToStep;
} TAutonomous;


//-------------------------------------< Global Variable Declarations >-----------------------------------------
// btn = Button (Input), stk = Stick (Input), pneu = Pneumatics (Output), motor = Motor (Output)

//Inputs
float stkDriveX;									//Current X value of drive stick (-127 to 127)
float stkDriveY;							 		//Current Y value of drive stick (-127 to 127)
float stkDriveS;
int stkLift;										//Lift Joystick Channel
int stkLift1;
int stkLift2;
int btnLiftTopUp2;
int btnLiftTopDown2;
int btnLiftBottomUp2;
int btnLiftBottomDown2;
int btnLiftUp1;
int btnLiftDown1;
int btnOldNewDrive;								//Old/New-Drive Joystick Button
int btnFrontBackDrive;
int gyrGyroscope;
int btnIntakeIn1;
int btnIntakeOut1;
int btnIntakeIn2;
int btnIntakeOut2;
int btnLiftEncoderReset1;
int btnLiftEncoderReset2;
int btnLiftLowGoal1;
int btnLiftMiddleGoal1;
int btnLiftHighGoal1;
int btnLiftLowGoal2;
int btnLiftMiddleGoal2;
int btnLiftHighGoal2;
float MainBatteryVoltageAverage;
float MainBatteryVoltageLevel;
int ButtonBitMap;
int LeftDisplayButton;
int CenterDisplayButton;
int RightDisplayButton;
int LeftLiftEncoder;
int RightLiftEncoder;
int LeftDriveEncoder;
int RightDriveEncoder;
int BottomLeftLiftLimitSwitch;
int BottomRightLiftLimitSwitch;

//Outputs
int motorLeftFrontDrive;
int motorLeftBackDrive;
int motorRightFrontDrive;
int motorRightBackDrive;
int old_motorLeftFrontDrive;
int old_motorLeftBackDrive;
int old_motorRightFrontDrive;
int old_motorRightBackDrive;
int motorRampedLeftFrontDrive;
int motorRampedLeftBackDrive;
int motorRampedRightFrontDrive;
int motorRampedRightBackDrive;
int motorLiftLeftTop;                  //Value assigned to left lift motors
int motorLiftLeftBottom;
int motorLiftRightTop;									//Value assigned to right lift motors
int motorLiftRightBottom;
int motorIntakeFront;								//gets put into the front of the intake mechanism
int motorIntakeBack;								//Gets put into the back of the intake mechanism
int LiftUp;
int LiftDown;

//Stuff that needs to remembered
int btnOldNewDrivePressed;							//Old/New-Drive Joystick Button Pressed Variable
TDriveAlgorithm OldNewDrive = PLAIN;
int btnFrontBackDrivePressed;
TRobotDirection FrontBackDrive = NORMAL;
int btnLiftLowGoal1Pressed;
int btnLiftMiddleGoal1Pressed;
int btnLiftHighGoal1Pressed;
int btnLiftLowGoal2Pressed;
int btnLiftMiddleGoal2Pressed;
int btnLiftHighGoal2Pressed;
TGoalHeightButton LastGoalHeightButton1;
TGoalHeightButton LastGoalHeightButton2;
int LiftTargetHeight;
int LiftToPresetHeight;
int LeftDisplayButtonPressed;
int CenterDisplayButtonPressed;
int RightDisplayButtonPressed;
int ActivateMenuItem = 0;
int DisplayNeedsRefreshing = 1;
int CurrentMenu = 0;
int CurrentMenuItem = 0;
int TotalMenuItems;
//int MenuStack[64];
string MainMenu[7] = {"Run Autonomous", "Pick Autonomous", "Motor Test", "Show Variables", "Edit Autonomous", "Make Autonomous", "Show Errors"};
string AutonomousMenu[4] = {"LoadScoreReturn", "ProgrammingSklls", "BlueIsolation", "No Autonomous"};
TPidSystem PIDLift;
TAutonomous AutonomousArray[3][21];
TAutonomous CurrentStep;
int ReadyForNextAutonomousStep = 1;
int NumOfAutonomusRoutines = 3;
int AutonomousStep = 0;
int AutonomousRoutine = 0;
int LockInAutonomous = 0;
int EnableOutput = 1;
int LiftButtonsAreControlling = 0;
float RightDriveSlowDownVariable = RIGHTDRIVESLOWDOWNCONSTANT;

//----------------------------------------< Function Declarations >----------------------------------------------\\
//void pre_auton();
//task autonomous()
//task usercontrol();
void initializeTimers();
int initializeDisplay();
int initializePID();
int initializeGyro();
int initializeAutonomousArray();
int initializeAutonomous();
int initializeOperator();
int getInput();
int processAutonomous();
int processOperator();
int operatorDriveTrain();
int operatorLift();
int operatorIntake();
int UpdatePIDControllers();
int PickAutonomous();
int Display();
void DisplayMainMenu();
void DisplayMenu(string MenuTitle, string MenuItem);
void DisplayButtonHandling();
int IsMenuItemActivated();
int CheckJoystick();
void ToggleCheck (int CurrentButtonState, int &WasAlreadyPressed, int &ToBeToggled);
void RangeCheck (int LowerLimit, int &Value, int UpperLimit);
void PIDController(TPidSystem &PIDObject);
void MotorTest();
int doOutput();

void pre_auton()
{
	initializeTimers();
	initializeDisplay();
	initializePID();
	//initializeGyro(); 							//Uncomment when we start using Gyro Sensor
	initializeAutonomousArray();
#ifdef _SIMULATED
	while (bSimulatedRobotDisabled)
#else
	while (bIfiRobotDisabled)						//Keep letting Autonomous be selected while robot is disabled
#endif
  {
    getInput();
		if (!LockInAutonomous)
		{
		  PickAutonomous();
		}
  }
	AutonomousRoutine = CurrentMenuItem;
	CurrentMenuItem = 0;
	CurrentMenu = 0;
	DisplayNeedsRefreshing = 1;
}

//----------------------------------------------< Autonomous >-----------------------------------------------\\

task autonomous()
{
  initializeAutonomous();
	while (true)
	{
		getInput();
		processAutonomous();
		doOutput();
	}
	/*motor[LiftBL] = 90;
	motor[LiftBR] = 90;
	wait1Msec(4000);
	motor[LiftBL] = 0;
	motor[LiftBR] = 0;*/

}

//-------------------------------------------< Operator Control >--------------------------------------------\\
task usercontrol()
{
  initializeOperator();
	#ifdef _SIMULATED
		while (!bSimulatedAutonomousMode)
	#else
		while (!bIfiAutonomousMode)
	#endif
		{
			getInput();
			processOperator();
			if (EnableOutput)
				doOutput();
		}
}
//---------------------------------------------< Initialize >---------------------------------------------------\\
void initializeTimers()
{
	ClearTimer(T1);
	ClearTimer(T2);
}

int initializeDisplay()
{
	//clearLCDLine(0);
    //clearLCDLine(1);
    bLCDBacklight = true;							//Turn Backlight on
	displayLCDPos(1, 0);							//Move "Cursor" to first spot
	displayNextLCDString("Ready to PWN :-D");		//Display motivational message
	return 0;
}

int initializePID()
{
	PIDLift.Kp = 1.5; //.75
	PIDLift.Ki = 0;
	PIDLift.Kd = 0.0; //0.5;
	PIDLift.Integral = 0;
	PIDLift.Derivative = 0;
	PIDLift.Error = 0;
	PIDLift.LastError = 0;
	PIDLift.TargetValue = 0;
	PIDLift.TargetPower = 0;
	PIDLift.Output = 0;
	return 0;
}

int initializeGyro()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in1] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
	return 0;
}

int initializeAutonomousArray()
{
  //memset(AutonomousArray, 0, sizeof(AutonomousArray));
	// *** LoadScoreReturn ***
AutonomousArray[0][0].StepName = "Blue Isolation";
	AutonomousArray[0][1].StepName = "FetchBall";
	AutonomousArray[0][1].LiftPower = 0;
	AutonomousArray[0][1].IntakePower = 0;
	AutonomousArray[0][1].DriveType = STRAIGHT;
	AutonomousArray[0][1].DrivePower = FORWARD;
	AutonomousArray[0][1].Timeout = 1300;
	AutonomousArray[0][1].EncoderTicks = 0;
	AutonomousArray[0][1].JumpCondition = NOCONDITION;
	AutonomousArray[0][1].JumpToStep = 0;

	AutonomousArray[0][2].StepName = "BackUp";
	AutonomousArray[0][2].LiftPower = 0;
	AutonomousArray[0][2].IntakePower = 0;
	AutonomousArray[0][2].DriveType = LEFTONEWHEELTURN;
	AutonomousArray[0][2].DrivePower = BACKWARD;
	AutonomousArray[0][2].Timeout = 200;
	AutonomousArray[0][2].EncoderTicks = 0;
	AutonomousArray[0][2].JumpCondition = NOCONDITION;
	AutonomousArray[0][2].JumpToStep = 0;

	AutonomousArray[0][3].StepName = "Lift";
	AutonomousArray[0][3].LiftPower = UP;
	AutonomousArray[0][3].IntakePower = 0;
	AutonomousArray[0][3].DriveType = STRAIGHT;
	AutonomousArray[0][3].DrivePower = 0;
	AutonomousArray[0][3].Timeout = 4500;
	AutonomousArray[0][3].EncoderTicks = 0;
	AutonomousArray[0][3].JumpCondition = NOCONDITION;
	AutonomousArray[0][3].JumpToStep = 0;

	AutonomousArray[0][4].StepName = "StrafeLeft";
	AutonomousArray[0][4].LiftPower = 0;
	AutonomousArray[0][4].IntakePower = 0;
	AutonomousArray[0][4].DriveType = STRAFESIDEWAYS;
	AutonomousArray[0][4].DrivePower = LEFT;
	AutonomousArray[0][4].Timeout = 300;
	AutonomousArray[0][4].EncoderTicks = 0;
	AutonomousArray[0][4].JumpCondition = NOCONDITION;
	AutonomousArray[0][4].JumpToStep = 0;

	AutonomousArray[0][5].StepName = "DriveIntoGoal";
	AutonomousArray[0][5].LiftPower = 0;
	AutonomousArray[0][5].IntakePower = 0;
	AutonomousArray[0][5].DriveType = STRAIGHT;
	AutonomousArray[0][5].DrivePower = 127;
	AutonomousArray[0][5].Timeout = 1200;
	AutonomousArray[0][5].EncoderTicks = 0;
	AutonomousArray[0][5].JumpCondition = NOCONDITION;
	AutonomousArray[0][5].JumpToStep = 0;

	AutonomousArray[0][6].StepName = "LiftMore";
	AutonomousArray[0][6].LiftPower = 0;
	AutonomousArray[0][6].IntakePower = 0;
	AutonomousArray[0][6].DriveType = STRAIGHT;
	AutonomousArray[0][6].DrivePower = 0;
	AutonomousArray[0][6].Timeout = 0;
	AutonomousArray[0][6].EncoderTicks = 0;
	AutonomousArray[0][6].JumpCondition = NOCONDITION;
	AutonomousArray[0][6].JumpToStep = 0;

	AutonomousArray[0][7].StepName = "ReleaseTheMffins";
	AutonomousArray[0][7].LiftPower = STOP;
	AutonomousArray[0][7].IntakePower = OUT;
	AutonomousArray[0][7].DriveType = STRAIGHT;
	AutonomousArray[0][7].DrivePower = 0;
	AutonomousArray[0][7].Timeout = 1200;
	AutonomousArray[0][7].EncoderTicks = 0;
	AutonomousArray[0][7].JumpCondition = NOCONDITION;
	AutonomousArray[0][7].JumpToStep = 0;

	AutonomousArray[0][8].StepName = "BackUp";
	AutonomousArray[0][8].LiftPower = 0;
	AutonomousArray[0][8].IntakePower = 0;
	AutonomousArray[0][8].DriveType = STRAIGHT;
	AutonomousArray[0][8].DrivePower = BACKWARD;
	AutonomousArray[0][8].Timeout = 500;
	AutonomousArray[0][8].EncoderTicks = 0;
	AutonomousArray[0][8].JumpCondition = NOCONDITION;
	AutonomousArray[0][8].JumpToStep = 0;

	AutonomousArray[0][9].StepName = "StrafeRight";
	AutonomousArray[0][9].LiftPower = 0;
	AutonomousArray[0][9].IntakePower = 0;
	AutonomousArray[0][9].DriveType = STRAFESIDEWAYS;
	AutonomousArray[0][9].DrivePower = RIGHT;
	AutonomousArray[0][9].Timeout = 400;
	AutonomousArray[0][9].EncoderTicks = 0;
	AutonomousArray[0][9].JumpCondition = NOCONDITION;
	AutonomousArray[0][9].JumpToStep = 0;

	AutonomousArray[0][10].StepName = "MoreMuffins";
	AutonomousArray[0][10].LiftPower = 0;
	AutonomousArray[0][10].IntakePower = OUT;
	AutonomousArray[0][10].DriveType = STRAIGHT;
	AutonomousArray[0][10].DrivePower = 0;
	AutonomousArray[0][10].Timeout = 500;
	AutonomousArray[0][10].EncoderTicks = 0;
	AutonomousArray[0][10].JumpCondition = NOCONDITION;
	AutonomousArray[0][10].JumpToStep = 0;

	AutonomousArray[0][11].StepName = "TurnLeft";
	AutonomousArray[0][11].LiftPower = 0;
	AutonomousArray[0][11].IntakePower = STOP;
	AutonomousArray[0][11].DriveType = BOTHWHEELTURN;
	AutonomousArray[0][11].DrivePower = LEFT;
	AutonomousArray[0][11].Timeout = 700;
	AutonomousArray[0][11].EncoderTicks = 0;
	AutonomousArray[0][11].JumpCondition = NOCONDITION;
	AutonomousArray[0][11].JumpToStep = 0;

	AutonomousArray[0][12].StepName = "BackUp";
	AutonomousArray[0][12].LiftPower = 0;
	AutonomousArray[0][12].IntakePower = 0;
	AutonomousArray[0][12].DriveType = STRAIGHT;
	AutonomousArray[0][12].DrivePower = BACKWARD;
	AutonomousArray[0][12].Timeout = 200;
	AutonomousArray[0][12].EncoderTicks = 0;
	AutonomousArray[0][12].JumpCondition = NOCONDITION;
	AutonomousArray[0][12].JumpToStep = 0;

	AutonomousArray[0][13].StepName = "StrafBrlIntoCrnr";
	AutonomousArray[0][13].LiftPower = DOWN;
	AutonomousArray[0][13].IntakePower = 0;
	AutonomousArray[0][13].DriveType = STRAFESIDEWAYS;
	AutonomousArray[0][13].DrivePower = LEFT;
	AutonomousArray[0][13].Timeout = 3500;
	AutonomousArray[0][13].EncoderTicks = 0;
	AutonomousArray[0][13].JumpCondition = NOCONDITION;
	AutonomousArray[0][13].JumpToStep = 0;

	AutonomousArray[0][14].StepName = "Pause";
	AutonomousArray[0][14].LiftPower = 0;
	AutonomousArray[0][14].IntakePower = 0;
	AutonomousArray[0][14].DriveType = STRAIGHT;
	AutonomousArray[0][14].DrivePower = 0;
	AutonomousArray[0][14].Timeout = 200;
	AutonomousArray[0][14].EncoderTicks = 0;
	AutonomousArray[0][14].JumpCondition = NOCONDITION;
	AutonomousArray[0][14].JumpToStep = 0;

	AutonomousArray[0][15].StepName = "Rotate";
	AutonomousArray[0][15].LiftPower = 0;
	AutonomousArray[0][15].IntakePower = 0;
	AutonomousArray[0][15].DriveType = BOTHWHEELTURN;
	AutonomousArray[0][15].DrivePower = RIGHT;
	AutonomousArray[0][15].Timeout = 100;
	AutonomousArray[0][15].EncoderTicks = 0;
	AutonomousArray[0][15].JumpCondition = NOCONDITION;
	AutonomousArray[0][15].JumpToStep = 0;

	AutonomousArray[0][16].StepName = "StrafeBack";
	AutonomousArray[0][16].LiftPower = 0;
	AutonomousArray[0][16].IntakePower = 0;
	AutonomousArray[0][16].DriveType = STRAFESIDEWAYS;
	AutonomousArray[0][16].DrivePower = RIGHT;
	AutonomousArray[0][16].Timeout = 2300;
	AutonomousArray[0][16].EncoderTicks = 0;
	AutonomousArray[0][16].JumpCondition = NOCONDITION;
	AutonomousArray[0][16].JumpToStep = 0;

	AutonomousArray[0][17].StepName = "RotateMore";
	AutonomousArray[0][17].LiftPower = 0;
	AutonomousArray[0][17].IntakePower = 0;
	AutonomousArray[0][17].DriveType = BOTHWHEELTURN;
	AutonomousArray[0][17].DrivePower = LEFT;
	AutonomousArray[0][17].Timeout = 0;
	AutonomousArray[0][17].EncoderTicks = 0;
	AutonomousArray[0][17].JumpCondition = NOCONDITION;
	AutonomousArray[0][17].JumpToStep = 0;

	AutonomousArray[0][18].StepName = "IntakeBall";
	AutonomousArray[0][18].LiftPower = STOP;
	AutonomousArray[0][18].IntakePower = IN;
	AutonomousArray[0][18].DriveType = STRAIGHT;
	AutonomousArray[0][18].DrivePower = FORWARD;
	AutonomousArray[0][18].Timeout = 700;
	AutonomousArray[0][18].EncoderTicks = 0;
	AutonomousArray[0][18].JumpCondition = NOCONDITION;
	AutonomousArray[0][18].JumpToStep = 0;

	AutonomousArray[0][19].StepName = "IntakeBarrel";
	AutonomousArray[0][19].LiftPower = 0;
	AutonomousArray[0][19].IntakePower = 0;
	AutonomousArray[0][19].DriveType = STRAIGHT;
	AutonomousArray[0][19].DrivePower = FORWARD;
	AutonomousArray[0][19].Timeout = 1000;
	AutonomousArray[0][19].EncoderTicks = 0;
	AutonomousArray[0][19].JumpCondition = NOCONDITION;
	AutonomousArray[0][19].JumpToStep = 0;

	AutonomousArray[0][20].StepName = "Done!";
	AutonomousArray[0][20].LiftPower = 0;
	AutonomousArray[0][20].IntakePower = STOP;
	AutonomousArray[0][20].DriveType = STRAIGHT;
	AutonomousArray[0][20].DrivePower = 0;
	AutonomousArray[0][20].Timeout = -1;
	AutonomousArray[0][20].EncoderTicks = 0;
	AutonomousArray[0][20].JumpCondition = NOCONDITION;
	AutonomousArray[0][20].JumpToStep = 0;

	return 0;
}

int initializeAutonomous()
{
 	AutonomousStep = 0;
	ReadyForNextAutonomousStep = 1;
  RightDriveSlowDownVariable = 1;
  return 0;
}

int initializeOperator()
{
 	RightDriveSlowDownVariable = RIGHTDRIVESLOWDOWNCONSTANT;
 	return 0;
}

//----------------------------------------------------< Get Input >---------------------------------------------\\

int getInput()
{
	//input code here
	//Joystick Inputs
	int ErrorCode = 0;
	stkDriveX = vexRT[Ch4];							//Turn Left and Right Drive Joystick Channel
	stkDriveY = vexRT[Ch3];							//Up and Down Drive Joystick Channel
	stkDriveS = vexRT[Ch1];							//Strafe Left and Right Drive Joystick Channel
	//stkLift1 = vexRT[Ch2];						//Lift Joystick Channel
	stkLift2 = vexRT[Ch2Xmtr2];					//Lift Joystick Channel
	btnLiftTopUp2 = vexRT[Btn7UXmtr2];
	btnLiftTopDown2 = vexRT[Btn7RXmtr2];
	btnLiftBottomUp2 = vexRT[Btn7LXmtr2];
	btnLiftBottomDown2 = vexRT[Btn7DXmtr2];

	btnLiftUp1 = vexRT[Btn5U];
	btnLiftDown1 = vexRT[Btn5D];
	//btnOldNewDrive = vexRT[Btn8D];    //Uncomment to try new drive systems
	btnFrontBackDrive = vexRT[Btn8U];
	gyrGyroscope = SensorValue[Gyro];
	btnIntakeIn1 = vexRT[Btn6U];
	btnIntakeOut1 = vexRT[Btn6D];
	btnIntakeIn2 = vexRT[Btn6UXmtr2];
	btnIntakeOut2 = vexRT[Btn6DXmtr2];
	btnLiftEncoderReset1 = vexRT[Btn7U];
	btnLiftEncoderReset2 = vexRT[Btn7UXmtr2];
	btnLiftLowGoal1 = vexRT[Btn8L];
  btnLiftMiddleGoal1 = vexRT[Btn8D];
  btnLiftHighGoal1 = vexRT[Btn8R];
  btnLiftLowGoal2  = vexRT[Btn8LXmtr2];
  btnLiftMiddleGoal2 = vexRT[Btn8DXmtr2];
  btnLiftHighGoal2 = vexRT[Btn8RXmtr2];
	//Digital Inputs
	LeftLiftEncoder = SensorValue[LeftLiftEncoderPort] * LIFTENCODERCONSTANT;
	RightLiftEncoder = SensorValue[RightLiftEncoderPort] * LIFTENCODERCONSTANT;
	LeftDriveEncoder = SensorValue[LeftDriveEncoderPort] * DRIVEENCODERCONSTANT;
	RightDriveEncoder = SensorValue[RightDriveEncoderPort] * DRIVEENCODERCONSTANT;
	BottomLeftLiftLimitSwitch = SensorValue[BottomLeftLiftLimitSwitchPort];
	BottomRightLiftLimitSwitch = SensorValue[BottomRightLiftLimitSwitchPort];
	MainBatteryVoltageAverage = nAvgBatteryLevel;
	MainBatteryVoltageLevel = nImmediateBatteryLevel;
	ButtonBitMap = nLCDButtons;
	LeftDisplayButton = (ButtonBitMap & 1) && 1;
	CenterDisplayButton = (ButtonBitMap & 2) && 1;
	RightDisplayButton = (ButtonBitMap & 4) && 1;
	return ErrorCode;
}

//-------------------------------------------< Processes >--------------------------------------------
int processAutonomous()
{
	int ErrorCode = 0;
	int StartGyro = 0;
	int WillJump = 0;
	if (ReadyForNextAutonomousStep)
	{
		if (AutonomousRoutine < NumOfAutonomusRoutines)			//LoadScoreReturn
		{
			//CurrentStep = AutonomousArray[AutonomousStep]; //This doesn't work in ROBOTC
			memcpy(CurrentStep, AutonomousArray[AutonomousRoutine][AutonomousStep], sizeof(CurrentStep)); //This does
		}
		else								//No Autonomous
		{
			CurrentStep.Timeout = -1;
			CurrentStep.StepName = "Preparing to PWN";
		}
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0, 0, AutonomousArray[AutonomousRoutine][0].StepName);
		displayLCDNumber(0, 14, AutonomousStep, 1); //Debug line; implement in future
	  displayLCDString(1, 0, CurrentStep.StepName);

		if (CurrentStep.LiftPower != 0 && CurrentStep.LiftPower >= -127 && CurrentStep.LiftPower <= 127)
		{
			motorLiftLeftTop = motorLiftLeftBottom = motorLiftRightTop = motorLiftRightBottom = CurrentStep.LiftPower;
		}
		else if (CurrentStep.LiftPower == 128)
		{
			motorLiftLeftTop = motorLiftLeftBottom = motorLiftRightTop = motorLiftRightBottom = 0;
		}
		if (CurrentStep.IntakePower  != 0 && CurrentStep.IntakePower >= -127 && CurrentStep.IntakePower <= 127)
		{
			motorIntakeBack = motorIntakeFront = CurrentStep.IntakePower;
		}
		else if (CurrentStep.IntakePower == 128)
		{
			motorIntakeBack = motorIntakeFront = 0;
		}
		if (CurrentStep.DriveType == STRAIGHT)
		{
			motorLeftFrontDrive = CurrentStep.DrivePower;
			motorLeftBackDrive = CurrentStep.DrivePower;
			motorRightFrontDrive = CurrentStep.DrivePower;
			motorRightBackDrive = CurrentStep.DrivePower;
		}
		else if (CurrentStep.DriveType == LEFTONEWHEELTURN)
		{
			motorLeftFrontDrive = 0;
			motorLeftBackDrive = 0;
			motorRightFrontDrive = CurrentStep.DrivePower;
			motorRightBackDrive = CurrentStep.DrivePower;

		}
		else if (CurrentStep.DriveType == RIGHTONEWHEELTURN)
		{
			motorLeftFrontDrive = CurrentStep.DrivePower;
			motorLeftBackDrive = CurrentStep.DrivePower;
			motorRightFrontDrive = 0;
			motorRightBackDrive = 0;
		}
		else if (CurrentStep.DriveType == BOTHWHEELTURN)
		{
			motorLeftFrontDrive = CurrentStep.DrivePower;
			motorLeftBackDrive = CurrentStep.DrivePower;
			motorRightFrontDrive = 0 - CurrentStep.DrivePower;
			motorRightBackDrive = 0 - CurrentStep.DrivePower;
		}
		else if (CurrentStep.DriveType == STRAFESIDEWAYS)
		{
			motorLeftFrontDrive = CurrentStep.DrivePower;
			motorLeftBackDrive = 0 - CurrentStep.DrivePower;
			motorRightFrontDrive = 0 - CurrentStep.DrivePower;
			motorRightBackDrive = CurrentStep.DrivePower;
		}
		ReadyForNextAutonomousStep = 0;
		ClearTimer(T2);
		StartGyro = gyrGyroscope;
	}
	if (CurrentStep.Timeout != -1)			//If the trip statement isn't met
	{
		if (CurrentStep.Timeout != 0 && ((time1[T2]) >= CurrentStep.Timeout))
			ReadyForNextAutonomousStep = 1;
		if (CurrentStep.GyroDegrees != 0 && (gyrGyroscope - StartGyro >= CurrentStep.GyroDegrees))
			ReadyForNextAutonomousStep = 1;
		if (CurrentStep.EncoderTicks != 0 && (RightDriveEncoder >= CurrentStep.EncoderTicks))
			ReadyForNextAutonomousStep = 1;
	  if (CurrentStep.Timeout == 0)
	    ReadyForNextAutonomousStep = 1;
  }
  else
	{
		motorLiftLeftTop = motorLiftLeftBottom = motorLiftRightTop = motorLiftRightBottom = 0;
		motorIntakeBack = motorIntakeFront = 0;
		motorLeftFrontDrive = 0;
		motorLeftBackDrive = 0;
		motorRightFrontDrive = 0;
		motorRightBackDrive = 0;
	}
	if (CheckJoystick())
	{
		StartTask(usercontrol);
		StopTask(autonomous);
	}

	if (ReadyForNextAutonomousStep)
  {
    if (CurrentStep.JumpToStep != 0)
    {
      if (CurrentStep.JumpCondition == 0)
        WillJump = 1;
      else if ((CurrentStep.JumpCondition >= 8) && CurrentStep.JumpCondition <= 19)
      {
        if (SensorValue[CurrentStep.JumpCondition])
          WillJump = 1;
      }
      else if(CurrentStep.JumpCondition == LEFTDISPLAYBUTTON && LeftDisplayButton)
        WillJump = 1;
      else if(CurrentStep.JumpCondition == CENTERDISPLAYBUTTON && CenterDisplayButton)
        WillJump = 1;
      else if(CurrentStep.JumpCondition == RIGHTDISPLAYBUTTON && RightDisplayButton)
        WillJump = 1;
      else if((CurrentStep.JumpCondition == ANYDISPLAYBUTTON) && (LeftDisplayButton || CenterDisplayButton || RightDisplayButton))
	    {
	      writeDebugStreamLine("Hi");
	      WillJump = 1;
	    }
	  }

	  if (WillJump)
	  {
      if (CurrentStep.JumpToStep == -1)
		  	AutonomousStep = 0;
		  else
		    AutonomousStep = CurrentStep.JumpToStep;
		}
		else
		{
			AutonomousStep++;
	  }
	}
	return ErrorCode;
}

int processOperator()
{
	//Driver control code here
	int ErrorCode = 0;
	operatorDriveTrain();
	operatorLift();
	operatorIntake();
	Display();
	UpdatePIDControllers();
	return ErrorCode;
}


//--------------------------------------------< Drive-train Code >-----------------------------------------------\\

int operatorDriveTrain()
{
  int ErrorCode;

	//ToggleCheck(btnOldNewDrive, btnOldNewDrivePressed, (int) OldNewDrive);
	ToggleCheck(btnFrontBackDrive, btnFrontBackDrivePressed, (int) FrontBackDrive);

	if (OldNewDrive == PLAIN)
	{
	  if(!(abs(stkDriveX) > JOYSTICKDEADZONE))
	  {
	    stkDriveX = 0;
	  }
	  if(!(abs(stkDriveY) > JOYSTICKDEADZONE))
	  {
	    stkDriveY = 0;
	  }
	  if(!(abs(stkDriveS) > JOYSTICKDEADZONE * 2))
	  {
	    stkDriveS = 0;
	  }
	  /*if((abs(stkDriveY) > JOYSTICKDEADZONE) || (abs(stkDriveX) > JOYSTICKDEADZONE) || (abs(stkDriveS) > JOYSTICKDEADZONE))	//If the Joystick hasn't been pushed far enough
		{*/
			motorLeftFrontDrive = stkDriveY + stkDriveX + stkDriveS;
			motorLeftBackDrive =  stkDriveY + stkDriveX - stkDriveS;
			motorRightFrontDrive = stkDriveY - stkDriveX - stkDriveS;
			motorRightBackDrive =  stkDriveY - stkDriveX + stkDriveS;
		/*}*/
		/*else
		{
			motorLeftFrontDrive = 0;
			motorLeftBackDrive = 0;
			motorRightFrontDrive = 0;
			motorRightBackDrive = 0;
		}*/
	}
	else
	{
		if((abs(stkDriveY) > JOYSTICKDEADZONE) || (abs(stkDriveX) > JOYSTICKDEADZONE))	//If the Joystick has been pushed far enough
		{
		  motorLeftFrontDrive = stkDriveY + stkDriveX;
		  motorLeftBackDrive = stkDriveY + stkDriveX;
		  motorRightFrontDrive = stkDriveY - stkDriveX;
		  motorRightBackDrive = stkDriveY - stkDriveX;
		}
		else
		{
			motorLeftFrontDrive = 0;
			motorLeftBackDrive = 0;
			motorRightFrontDrive = 0;
			motorRightBackDrive = 0;
		}
	}
	RangeCheck(0-MOTORDRIVEMAX, motorLeftFrontDrive, MOTORDRIVEMAX);
	RangeCheck(0-MOTORDRIVEMAX, motorLeftBackDrive, MOTORDRIVEMAX);
	RangeCheck(0-MOTORDRIVEMAX, motorRightFrontDrive, MOTORDRIVEMAX);
	RangeCheck(0-MOTORDRIVEMAX, motorRightBackDrive, MOTORDRIVEMAX);

	return ErrorCode;
}

//------------------------------------Lift Code-------------------------------------//

int operatorLift()
{
  int ErrorCode = 0;
	/*//Direct Lift
	if (btnLiftRestBack1 && btnLiftRestFront1)
	{
		stkLift = 0;
	}
	else if (btnLiftRestBack2 && btnLiftRestFront2)
	{
		stkLift = 0;
	}
	else if (abs(stkLift1) > JOYSTICKDEADZONE)
	{
		stkLift = stkLift1;
	}
	else if (abs(stkLift2) > JOYSTICKDEADZONE)
	{
		stkLift = stkLift2;
	}
	else if (BottomLiftLimitSwitch)
	{
		stkLift = 0;
	}
	else
	{
		stkLift = 10;
	}

	motorLiftLeft = stkLift;
	motorLiftRight = stkLift;*/

	//PID Lift

	//Main Joystick Low Goal Button
	if (btnLiftLowGoal1 && !btnLiftLowGoal1Pressed)
	{
	  if (LastGoalHeightButton1 == LOWGOALBUTTON)
	  {
  	  LastGoalHeightButton1 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
      LastGoalHeightButton1 = LOWGOALBUTTON;
  	  LiftTargetHeight = LOWGOALHEIGHT;
  	}
	  LiftToPresetHeight = 1;
	}
	btnLiftLowGoal1Pressed = btnLiftLowGoal1;

	//Main Joystick Middle Goal Button
	if (btnLiftMiddleGoal1 && !btnLiftMiddleGoal1Pressed)
	{
	  if (LastGoalHeightButton1 == MIDDLEGOALBUTTON)
	  {
  	  LastGoalHeightButton1 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
      LastGoalHeightButton1 = MIDDLEGOALBUTTON;
  	  LiftTargetHeight = MIDDLEGOALHEIGHT;
  	}
	  LiftToPresetHeight = 1;
	}
	btnLiftMiddleGoal1Pressed = btnLiftMiddleGoal1;

	//Main Joystick High Goal Button
	if (btnLiftHighGoal1 && !btnLiftHighGoal1Pressed)
	{
	  if (LastGoalHeightButton1 == HIGHGOALBUTTON)
	  {
  	  LastGoalHeightButton1 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
  	  LastGoalHeightButton1 = HIGHGOALBUTTON;
  	  LiftTargetHeight = HIGHGOALHEIGHT;
  	}
	  LiftToPresetHeight = 1;
	}
	btnLiftHighGoal1Pressed = btnLiftHighGoal1;


	//Second Joystick Low Goal Button
	if (btnLiftLowGoal2 && !btnLiftLowGoal2Pressed)
	{
	  if (LastGoalHeightButton2 == LOWGOALBUTTON)
	  {
  	  LastGoalHeightButton2 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
      LastGoalHeightButton2 = LOWGOALBUTTON;
  	  LiftTargetHeight = LOWGOALHEIGHT;
  	}
	  LiftToPresetHeight = 2;
	}
	btnLiftLowGoal2Pressed = btnLiftLowGoal2;

	//Second Joystick Middle Goal Button
	if (btnLiftMiddleGoal2 && !btnLiftMiddleGoal2Pressed)
	{
	  if (LastGoalHeightButton2 == MIDDLEGOALBUTTON)
	  {
  	  LastGoalHeightButton2 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
      LastGoalHeightButton2 = MIDDLEGOALBUTTON;
  	  LiftTargetHeight = MIDDLEGOALHEIGHT;
  	}
	  LiftToPresetHeight = 2;
	}
	btnLiftMiddleGoal2Pressed = btnLiftMiddleGoal2;

	//Second Joystick High Goal Button
	if (btnLiftHighGoal2 && !btnLiftHighGoal2Pressed)
	{
	  if (LastGoalHeightButton2 == HIGHGOALBUTTON)
	  {
  	  LastGoalHeightButton2 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
  	  LastGoalHeightButton2 = HIGHGOALBUTTON;
  	  LiftTargetHeight = HIGHGOALHEIGHT;
  	}
	  LiftToPresetHeight = 2;
	}
	btnLiftHighGoal2Pressed = btnLiftHighGoal2;

	/*else if (btnLiftMiddleGoal1 && !btnLiftMiddleGoal1Pressed)
	  LiftTargetHeight = MIDDLEGOALHEIGHT;
	else if (btnLiftHighGoal1 && !btnLiftHighGoal1Pressed)
	  LiftTargetHeight = HIGHGOALHEIGHT;
	else if (btnLiftLowGoal2 && !btnLiftLowGoal2Pressed)
	  LiftTargetHeight = LOWGOALHEIGHT;
	else if (btnLiftMiddleGoal2 && !btnLiftMiddleGoal2Pressed)
	  LiftTargetHeight = MIDDLEGOALHEIGHT;
	else if (btnLiftHighGoal2 && !btnLiftHighGoal2Pressed)
	  LiftTargetHeight = HIGHGOALHEIGHT;*/


	PIDLift.Error = RightLiftEncoder - LeftLiftEncoder;

	if (btnLiftEncoderReset1 || btnLiftEncoderReset2)
	{
		SensorValue[LeftLiftEncoderPort] = 0;
		SensorValue[RightLiftEncoderPort] = 0;
	}


	if(btnLiftUp1)
	{
	  PIDLift.TargetPower = 127;
	}
	else if (btnLiftDown1)
	{
	  PIDLift.TargetPower = -127;
	}
	else if (abs(stkLift1) > JOYSTICKDEADZONE)
	{
		PIDLift.TargetPower = stkLift1;
	}
	else if (abs(stkLift2) > JOYSTICKDEADZONE)
	{
		PIDLift.TargetPower = stkLift2;
	}
	else if (BottomLeftLiftLimitSwitch && BottomRightLiftLimitSwitch)
	{
	  PIDLift.TargetPower = 0;
		SensorValue[LeftLiftEncoderPort] = 0;
		SensorValue[RightLiftEncoderPort] = 0;
	}
	else			//Joysticks are Centered, the encoder reset buttons and the bottom lift switches are not pressed
	{
		PIDLift.TargetPower = 0;
	}

	//BUTTON LIFT CODE
	if(btnLiftTopUp2)
	{
	  LiftUp = UP;
	}
	else if(btnLiftTopDown2)
	{
	  LiftUp = DOWN;
	}
	else
	{
	  LiftUp = 0;
	}

  if(btnLiftBottomUp2)
	{
	  LiftDown = UP;
	}
	else if(btnLiftBottomDown2)
	{
	  LiftDown = DOWN;
	}
	else
	{
		LiftDown = 0;
	}

  if (LiftUp == 0 && LiftDown == 0)
    LiftButtonsAreControlling = 0;
  else
    LiftButtonsAreControlling = 1;

	//motorLiftLeft = PIDLift.TargetPower + PIDLift.Output;
	//motorLiftRight = PIDLift.TargetPower - PIDLift.Output;
	if (LiftButtonsAreControlling)
	{
		motorLiftLeftTop = motorLiftRightTop = LiftUp;
		motorLiftLeftBottom = motorLiftRightBottom = LiftDown;
	}
	else
	{
		motorLiftLeftTop = motorLiftRightTop = PIDLift.TargetPower;
		motorLiftLeftBottom = motorLiftRightBottom = PIDLift.TargetPower;
	}
	/*if ((PIDLift.TargetPower + PIDLift.Output) < 0)   //If Left Lift is going down, slow it down
	{
		motorLiftLeft = (PIDLift.TargetPower + PIDLift.Output)*.5;  //.75
	}
	if ((PIDLift.TargetPower - PIDLift.Output) < 0)   //If Right Lift is going down, slow it down
	{
		motorLiftRight = (PIDLift.TargetPower + PIDLift.Output)*.5;  //.75
	}*/

	return ErrorCode;
}

//------------------------------------Intake Code-------------------------------------//

int operatorIntake()
{
  int ErrorCode = 0;
  	if(btnIntakeIn1 == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeOut1 == 1)
    {
	  motorIntakeFront = -127;
      motorIntakeBack = -127;
   }
    else if(btnIntakeIn2 == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeOut2 == 1)
    {
      motorIntakeFront = -127;
      motorIntakeBack = -127;
    }
    else
    {
      motorIntakeFront = 0;
      motorIntakeBack = 0;
    }
  return ErrorCode;
}

int UpdatePIDControllers()
{
	PIDController(PIDLift);
	return 0;
}

int PickAutonomous()
{
  LockInAutonomous = 0;
	TotalMenuItems = NumOfAutonomusRoutines;
		if (DisplayNeedsRefreshing)
		{
			DisplayMenu("Pick Autonomous", AutonomousArray[CurrentMenuItem][0].StepName);
			DisplayNeedsRefreshing = 0;
		}
		DisplayButtonHandling();
		if (IsMenuItemActivated())
		{
			AutonomousRoutine = CurrentMenuItem;
			CurrentMenuItem = 0;
			CurrentMenu = 0;
			LockInAutonomous = 1;
		}
	return 0;
}

int Display()
{
	switch(CurrentMenu)
	{
		case 1:   //Start Autonomous
			CurrentMenu = 0;
			StartTask(autonomous);
			StopTask(usercontrol);
			break;
		case 2:   //Pick Autonomous
		  CurrentMenuItem = AutonomousRoutine;
		  allMotorsOff();
		  do
		  {
		    getInput();
			  PickAutonomous();
			} while (!LockInAutonomous);
			while(nLCDButtons);
			break;
		case 3:
			//StopTask(usercontrol);
			//EnableOutput = 0;
			allMotorsOff();
			MotorTest();
			//EnableOutput = 1;
			CurrentMenu = 0;
			break;
		default:
			DisplayMainMenu();
			break;
	}
	return 0;
}

void DisplayMainMenu()
{
	TotalMenuItems = 7;
	if (DisplayNeedsRefreshing)
	{
		DisplayMenu("Main Menu", MainMenu[CurrentMenuItem]);
		DisplayNeedsRefreshing = 0;
	}
	DisplayButtonHandling();
	if (IsMenuItemActivated())
	{
		CurrentMenu = CurrentMenuItem + 1;
	}
}

void DisplayMenu(string MenuTitle, string MenuItem)
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, MenuTitle);
	displayLCDCenteredString(1, MenuItem);
}

void DisplayButtonHandling()
{
	if (LeftDisplayButton && !LeftDisplayButtonPressed && CurrentMenuItem > 0)
	{
		CurrentMenuItem--;
		DisplayNeedsRefreshing = 1;
	}
	LeftDisplayButtonPressed = LeftDisplayButton;
	if (RightDisplayButton && !RightDisplayButtonPressed && CurrentMenuItem < TotalMenuItems - 1)
	{
		CurrentMenuItem++;
		DisplayNeedsRefreshing = 1;
	}
	RightDisplayButtonPressed = RightDisplayButton;
	if (CenterDisplayButton && !CenterDisplayButtonPressed)
	{
		ActivateMenuItem = 1;
		DisplayNeedsRefreshing = 1;
	}
	CenterDisplayButtonPressed = CenterDisplayButton;
}

int IsMenuItemActivated() //This function makes sure that the activate action happens only when it is supposed to
{
	int Dummy = ActivateMenuItem;
	ActivateMenuItem = 0;
	return Dummy;
}

int CheckJoystick()
{
	//Are the joystick tests
	if (abs(vexRT[Ch1]) > JOYSTICKDEADZONE || abs(vexRT[Ch2]) > JOYSTICKDEADZONE || abs(vexRT[Ch3]) > JOYSTICKDEADZONE || abs(vexRT[Ch4]) > JOYSTICKDEADZONE)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void ToggleCheck (int CurrentButtonState, int &WasAlreadyPressed, int &ToBeToggled)
{
	if (CurrentButtonState && !WasAlreadyPressed)
	{
		ToBeToggled = !ToBeToggled;			//If Old Drive, switch to New Drive. If New Drive, switch to Old Drive
	}
	WasAlreadyPressed = CurrentButtonState;
}

void RangeCheck (int LowerLimit, int &Value, int UpperLimit)
{
	if (Value > UpperLimit)
	{
		Value = UpperLimit;
	}
	if (Value < LowerLimit)
	{
		Value = LowerLimit;
	}
}

void PIDController(TPidSystem &PIDObject)
{
	PIDObject.Integral = ((3 / 4) * PIDObject.Integral) + PIDObject.Error;
	PIDObject.Derivative = PIDObject.Error - PIDObject.LastError;
	PIDObject.Output = (PIDObject.Error * PIDObject.Kp) + (PIDObject.Integral * PIDObject.Ki) + (PIDObject.Derivative * PIDObject.Kd);
	PIDObject.LastError = PIDObject.Error;
}

int WasPressedOnce(int CurrentButtonState, int &WasAlreadyPressed)
{
  int Pressed = 0;
	if (CurrentButtonState && !WasAlreadyPressed)
		Pressed = 1;
	WasAlreadyPressed = CurrentButtonState;
	return Pressed;
}

void MotorTest()
{
  int MotorNumber1 = 4;
	int ButtonBitMap = nLCDButtons;
	int LeftDisplayButton1;
	int CenterDisplayButton1 = 0;
  int RightDisplayButton1;
  int LeftJoystickButton1;
  int RightJoystickButton1;
  int LeftDisplayButton2;
  int RightDisplayButton2;
  int LeftJoystickButton2;
  int RightJoystickButton2;
  int LeftDisplayButtonPressed1;
  int RightDisplayButtonPressed1;
  int LeftJoystickButtonPressed1;
  int RightJoystickButtonPressed1;
  int LeftDisplayButtonPressed2;
  int RightDisplayButtonPressed2;
  int LeftJoystickButtonPressed2;
  int RightJoystickButtonPressed2;
  displayLCDString(0, 0, "Motor           ");
  displayLCDNumber(1, 0, MotorNumber1);
  while (!CheckJoystick())
	{
		ButtonBitMap = nLCDButtons;
	  LeftDisplayButton1 = (ButtonBitMap & 1) && 1;
	  CenterDisplayButton1 = (ButtonBitMap & 2) && 1;
	  RightDisplayButton1 = (ButtonBitMap & 4) && 1;
	  LeftJoystickButton1 = vexRT[Btn8L];
	  RightJoystickButton1 = vexRT[Btn8R];

		if ((WasPressedOnce(LeftJoystickButton1, LeftJoystickButtonPressed1) || WasPressedOnce(LeftDisplayButton1, LeftDisplayButtonPressed1)) && MotorNumber1 > 1)
		{
		  MotorNumber1--;
		  clearLCDLine(1);
		  displayLCDNumber(1, 0, MotorNumber1);
		}
		if ((WasPressedOnce(RightJoystickButton1, RightJoystickButtonPressed1) || WasPressedOnce(RightDisplayButton1, RightDisplayButtonPressed1)) && MotorNumber1 < 10)
		{
		  MotorNumber1++;
		  clearLCDLine(1);
		  displayLCDNumber(1, 0, MotorNumber1);
		}
		if (vexRT[Btn5U])
			motor[MotorNumber1 - 1] = 127;
		else if (vexRT[Btn5D])
			motor[MotorNumber1 - 1] = -127;
		else
			motor[MotorNumber1 - 1] = 0;
  }
}
int doOutput()
{
	//output code here
	int ErrorCode = 0;

	/*motorRampedLeftFrontDrive += ((motorLeftFrontDrive - motorRampedLeftFrontDrive) * MOTORRAMPCONSTANT);
	motorRampedLeftBackDrive += ((motorLeftFrontDrive - motorRampedLeftBackDrive) * MOTORRAMPCONSTANT);
	motorRampedRightFrontDrive += ((motorLeftFrontDrive - motorRampedRightFrontDrive) * MOTORRAMPCONSTANT);
	motorRampedRightBackDrive += ((motorLeftFrontDrive - motorRampedRightBackDrive) * MOTORRAMPCONSTANT);*/

	if (FrontBackDrive == NORMAL)
	{
		motor[DriveFL] = motorLeftFrontDrive;
		motor[DriveBL] = motorLeftBackDrive;
		motor[DriveFR] = motorRightFrontDrive * RightDriveSlowDownVariable;
		motor[DriveBR] = motorRightBackDrive * RightDriveSlowDownVariable;

		motor[IntakeL] = motorIntakeFront;
		motor[IntakeR] = motorIntakeFront;
	}
	else
	{
		motor[DriveBR] = 0 - motorLeftFrontDrive * RightDriveSlowDownVariable;
		motor[DriveFR] = 0 - motorLeftBackDrive * RightDriveSlowDownVariable;
		motor[DriveBL] = 0 - motorRightFrontDrive;
		motor[DriveFL] = 0 - motorRightBackDrive;

		motor[IntakeL] = 0 - motorIntakeFront;
		motor[IntakeR] = 0 - motorIntakeBack;

	}
	motor[LiftFL] = motorLiftLeftTop;
	motor[LiftBL] = motorLiftLeftBottom;
	motor[LiftFR] = motorLiftRightTop;
	motor[LiftBR] = motorLiftRightBottom;

	return ErrorCode;
}
