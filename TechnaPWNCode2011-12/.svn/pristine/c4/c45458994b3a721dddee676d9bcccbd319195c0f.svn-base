#pragma config(UART_Usage, UART2, VEX_2x16_LCD, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro,                sensorGyro)
#pragma config(Sensor, dgtl1,  LeftDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LeftLiftEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  RightLiftEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Holonomic1,          sensorDigitalOut)
#pragma config(Sensor, dgtl12, Holonomic2,          sensorDigitalOut)
#pragma config(Motor,  port1,           IntakeLF,      tmotorNormal, openLoop)
#pragma config(Motor,  port2,           IntakeRF,      tmotorNormal, openLoop)
#pragma config(Motor,  port3,           DriveLF,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           DriveRF,       tmotorNormal, openLoop)
#pragma config(Motor,  port5,           LiftL,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           LiftR,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           DriveLB,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           DriveRB,       tmotorNormal, openLoop)
#pragma config(Motor,  port9,           IntakeLB,      tmotorNormal, openLoop)
#pragma config(Motor,  port10,          IntakeRB,      tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//
//Code made with love by Josiah Krutz and Ryan Plummer. Addition support provided by:
//http://robotc.net/forums/viewtopic.php?f=52&t=1280
//Josh Duff


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"				//Main competition background code...do not modify!


//Constants
#define numMessages 10
#define JOYSTICKDRIVEMAX 127
#define MOTORDRIVEMAX 127
#define JOYSTICKINPUTS 19
#define LIFTKP 0.2
#define LIFTOFFSET 2
#define IN 127
#define OUT -127
#define UP 127
#define DOWN -127
#define FORWARD 127
#define BACKWARD -127
#define STOP 0

//Enums
typedef enum
{
	HOLONOMIC,
	STRAIGHT
} TWheelConfiguration;


typedef enum
{
	SIMPLE,
	TRIGONOMETRIC
} TDriveAlgorithm;

typedef enum
{
	NORMAL,
	REVERSED
} TRobotDirection;

//---------------------------------------------< Structs >-----------------------------------------------\\

typedef struct
{
	float Kp;
	float Ki;
	float Kd;
	int Integral;
	int Derivative;
	int Error;
	float LastError;
	int TargetValue;
	float Output;
	float Offset;

} TPidSystem;

typedef struct
{
	string Line1;
	string Line2;
	bool LeftButton;
	bool CenterButton;
	bool RightButton;
} TDisplay;

typedef struct
{
	//Outputs
	int LiftHeight;
	int BackIntakePower;
	int FrontIntakePower;
	int DrivePower;
	int DriveDirection;
	//Trip values
	int Timeout;
	int GyroDegrees;
} TAutonomous;


//-------------------------------------< Global Variable Declarations >-----------------------------------------\\
// btn = Button (Input), stk = Stick (Input), pneu = Pneumatics (Output), motor = Motor (Output)

//Inputs
float stkDriveX;									//Current X value of drive stick (-127 to 127)
float stkDriveY;							 		//Current Y value of drive stick (-127 to 127)
int stkLift;										//Lift Joystick Channel
int stkLift1;
int stkLift2;
float joystickDrivePower;							//Current distance of drive stick from center
int joystickDriveDeadzone = 20;						//Distance to push stick before affecting robot
int btnHoloStraight;								//Holonomic/Straight-Drive Joystick Button
int btnOldNewDrive;									//Old/New-Drive Joystick Button
int btnFrontBackDrive;
int gyrGyroscope;
int btnIntakeIn;
int btnIntakeOut;
int btnIntakeIn1;
int btnIntakeOut1;
int btnIntakeIn2;
int btnIntakeOut2;
float MainBatteryVoltageAverage;
float MainBatteryVoltageLevel;
int ButtonBitMap;
int LeftDisplayButton;
int CenterDisplayButton;
int RightDisplayButton;
int LeftLiftEncoder;
int RightLiftEncoder;
int LeftDriveEncoder;
int RightDriveEncoder;

//Outputs
int motorLeftDriveTrain;							//Value assigned to motors on the left of the robot
int motorRightDriveTrain;							//Value assigned to motors on the right of the robot
int motorLiftLeft;									//Value assigned to left lift motors
int motorLiftRight;									//Value assigned to right lift motors
int motorIntakeFront;								//gets put into the font of the intake mechanism
int motorIntakeBack;								//Gets put into the beack of the intake mechanism
int pneuHoloStraight;								//Holonomic/Straight-Drive Pneumatic Variable

//Stuff that needs to remembered
TWheelConfiguration HolonomicMode;				//Holonomic/Straight-Drive Boolean Variable (0 = Straight, 1 = Holo)
int btnHoloStraightPressed;							//Holonomic/Straight-Drive Joystick Button Pressed Variable
int btnOldNewDrivePressed;							//Old/New-Drive Joystick Button Pressed Variable
int bOldNewDrive;									//Old/New-Drive Boolean Variable (0 = Straight, 1 = Holo)
int btnFrontBackDrivePressed;
int bFrontBackDrive;
int CurrentMenuItem;
int TotalMenuItems;
TPidSystem PIDLift;
//TAutonomous AutonomousFleeFlicker[10];
int AutonomousStep = 0;

//Functions
//void pre_auton();
//task autonomous()
//task usercontrol();
int initializeDisplay();
int initializePID();
int initializeGyro();
int initializeAutonomous();
int getInput();
int processAutonomous();
int processOperator();
int Display();
int operatorDriveTrain();
int operatorLift();
int doOutput();
int operatorIntake();

void pre_auton()
{
	initializeDisplay();
	initializeGyro(); 							//Uncomment when we start using Gyro Sensor
	initializePID();
	initializeAutonomous();
	while (bIfiRobotDisabled);						//Keep the message displayed while robot is disabled
}

//----------------------------------------------< Autonomous >-----------------------------------------------\\

void Drive(int Power)
{
	//motorLeftDriveTrain = motorRightDriveTrain = Power;
	motor[DriveRF] = Power;
	motor[DriveRB] = Power;
	motor[DriveLF] = Power;
	motor[DriveLB] = Power;
}

void SingleTurnRight(int Power)
{
	motor[DriveRF] = 0;
	motor[DriveRB] = 0;
	motor[DriveLF] = Power;
	motor[DriveLB] = Power;
}

void SingleTurnLeft(int Power)
{
	motor[DriveRF] = Power;
	motor[DriveRB] = Power;
	motor[DriveLF] = 0;
	motor[DriveLB] = 0;
}

void GyroTurnLeft(int TenthOfDegrees)
{
	int Power = 127;
	motor[DriveRF] = Power;
	motor[DriveRB] = Power;
	motor[DriveLF] = 0 - Power;
	motor[DriveLB] = 0 - Power;
	while(abs(SensorValue[Gyro]) < TenthOfDegrees);
	motor[DriveRF] = 0;
	motor[DriveRB] = 0;
	motor[DriveLF] = 0;
	motor[DriveLB] = 0;
}

void GyroTurnRight(int TenthOfDegrees)
{
	int Power = 127;
	motor[DriveRF] = 0 - Power;
	motor[DriveRB] = 0 - Power;
	motor[DriveLF] = Power;
	motor[DriveLB] = Power;
	while(abs(SensorValue[Gyro]) < TenthOfDegrees);
	motor[DriveRF] = 0;
	motor[DriveRB] = 0;
	motor[DriveLF] = 0;
	motor[DriveLB] = 0;
}

void Lift(int Power)
{
	motor[LiftL] = Power;
	motor[LiftR] = Power;
}

void Intake(int Power)
{
	motor[IntakeLF] = Power;
	motor[IntakeRF] = Power;
	motor[IntakeLB] = Power;
	motor[IntakeRB] = Power;
}

task autonomous()
{
	/*while (bIfiAutonomousMode)
	{
		getInput();
		processAutonomous();
		//doOutput();
	}*/
	/*Drive(FORWARD);			//Drive
	Lift(UP);				//Raise Lift
	wait1Msec(2000);
	SingleTurnRight(127);	//Wiggle Right
	wait1Msec(700);
	Drive(STOP);
	wait1Msec(100);
	SingleTurnLeft(127);	//Wiggle Left
	wait1Msec(900);
	SingleTurnRight(127);	//Wiggle Back Right
	wait1Msec(200);
	Drive(FORWARD);			//Drive
	wait1Msec(700);
	SingleTurnRight(127);	//Turn More Right
	wait1Msec(500);
	Drive(FORWARD);			//Drive into goal
	wait1Msec(1500);
	Drive(BACKWARD);		//Back up a bit
	wait1Msec(500);
	Drive(STOP);
	Intake(OUT);			//Release the Muffins!
	wait1Msec(1500);
	wait1Msec(1500);
	Intake(OUT);
	wait1Msec(1500);

	Intake(STOP);*/

	Lift(UP);				//Raise Lift
	wait1Msec(1100);
	while(true)
	{
	Drive(FORWARD);			//Drive
	wait1Msec(1500);
	Drive(STOP);
  wait1Msec(500);
	Lift(20);				//Hold the cage up
	wait1Msec(500);
	Intake(OUT);			//Release the Muffins!
	wait1Msec(5000);
	Intake(STOP);
  Drive(BACKWARD);
  wait1Msec(1800);
  Drive(STOP);
                    //Again again!
  while (nLCDButtons == 0)
  {
  }
  wait1Msec(200);
  }

}

//-------------------------------------------< Operator Control >--------------------------------------------\\
task usercontrol()
{
	while (!bIfiAutonomousMode)
	{
		getInput();
		processOperator();
		doOutput();
	}
}

//---------------------------------------------< Initialize >---------------------------------------------------\\
int initializeDisplay()
{
	//clearLCDLine(0);
    //clearLCDLine(1);
    bLCDBacklight = true;							//Turn Backlight on
	displayLCDPos(1, 0);							//Move "Cursor" to first spot
	displayNextLCDString("Ready to PWN :-D");		//Display motivational message
	return 0;
}

int initializePID()
{
	PIDLift.Kp = 1;
	PIDLift.Ki = 0.1;
	PIDLift.Kd = 5;
	PIDLift.Integral = 0;
	PIDLift.Derivative = 0;
	PIDLift.Error = 0;
	PIDLift.LastError = 0;
	PIDLift.TargetValue = 0;
	PIDLift.Output = 0;
	return 1;
}

int initializeGyro()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in1] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
	return 0;
}

int initializeAutonomous()
{
	//FleeFlicker
	/*AutonomousFleeFlicker[0].LiftHeight = 20;
	AutonomousFleeFlicker[0].Timeout = 300;
	AutonomousFleeFlicker[1].LiftHeight = 10;
	AutonomousFleeFlicker[1].Timeout = 300;
	AutonomousFleeFlicker[2].LiftHeight = 20;
	AutonomousFleeFlicker[2].Timeout = 300;
	AutonomousFleeFlicker[3].Timeout = -1;*/
	return 0;
}
//----------------------------------------------------< Get Input >---------------------------------------------\\

int getInput()
{
	//input code here
	//Joystick Inputs
	int errorcode = 0;
	stkDriveX = vexRT[Ch4];							//Left and Right Drive Joystick Channel
	stkDriveY = vexRT[Ch3];							//Up and Down Drive Joystick Channel
	stkLift1 = vexRT[Ch2];					//Lift Joystick Channel
	stkLift2 = vexRT[Ch2Xmtr2];					//Lift Joystick Channel
	if ((stkLift1 < (0 -joystickDriveDeadzone)) || (stkLift1 > (joystickDriveDeadzone)) )
	{
		stkLift = stkLift1;
	}
	else if ((stkLift2 < (0 -joystickDriveDeadzone)) || (stkLift2 > (joystickDriveDeadzone)) )
	{
		stkLift = stkLift2;
	}
	else
	{
		stkLift = 10;
	}
	//btnHoloStraight = vexRT[Btn7D];					//Holonomic/Straight-Drive Joystick Button
	btnOldNewDrive = vexRT[Btn8D];
	btnFrontBackDrive = vexRT[Btn8U];
	gyrGyroscope = SensorValue[Gyro];
	btnIntakeIn1 = vexRT[Btn6U];
	btnIntakeOut1 = vexRT[Btn6D];
	btnIntakeIn2 = vexRT[Btn6UXmtr2];
	btnIntakeOut2 = vexRT[Btn6DXmtr2];
	//Digital Inputs
	LeftLiftEncoder = SensorValue[LeftLiftEncoderPort];
	//RightLiftEncoder = SensorValue[RightLiftEncoderPort]; //Uncomment when we get this installed
	LeftDriveEncoder = SensorValue[LeftDriveEncoderPort];
	RightDriveEncoder = SensorValue[RightDriveEncoderPort];
	MainBatteryVoltageAverage = nAvgBatteryLevel;
	MainBatteryVoltageLevel = nImmediateBatteryLevel;
	ButtonBitMap = nLCDButtons;
	LeftDisplayButton = ButtonBitMap & 4;
	CenterDisplayButton = ButtonBitMap & 2;
	RightDisplayButton = ButtonBitMap & 1;
	return errorcode;
}

//-------------------------------------------< Processes >--------------------------------------------\\
int processAutonomous()
{
	//autonomous code here
	int errorcode = 0;
	/*TAutonomous CurrentStep;
	//CurrentStep = AutonomousFleeFlicker[AutonomousStep];
	memcpy(CurrentStep, AutonomousFleeFlicker[AutonomousStep], sizeof(CurrentStep));
	if (CurrentStep.LiftHeight != 10)
	{
		if (CurrentStep.LiftHeight != 0)
		{
			motorLiftLeft = motorLiftRight = (LeftLiftEncoder - CurrentStep.LiftHeight) * LIFTKP + LIFTOFFSET;
		}
		ClearTimer(T1);
		while (time1[T1] < CurrentStep.Timeout);
		AutonomousStep++;
		writeDebugStream("LiftHeight1: %d\n", CurrentStep.Timeout);
	}*/

	return errorcode;
}

int processOperator()
{
	//Driver control code here
	int errorcode = 0;
	operatorDriveTrain();
	operatorLift();
	operatorIntake();
	return errorcode;
}


void PIDController(TPidSystem &PIDObject)
{
	PIDObject.Integral = ((2 / 3) * PIDObject.Integral) + PIDObject.Error;
	PIDObject.Derivative = PIDObject.Error - PIDObject.LastError;
	PIDObject.Output = (PIDObject.Error * PIDObject.Kp) + (PIDObject.Integral * PIDObject.Ki) +(PIDObject.Derivative * PIDObject.Kd);
}

int Display()
{
	if (LeftDisplayButton)
	{
		CurrentMenuItem = (CurrentMenuItem + 1) % TotalMenuItems;
	}
	if (RightDisplayButton)
	{
		CurrentMenuItem = (CurrentMenuItem + 1) % TotalMenuItems;
	}
	return 0;
}

void ToggleCheck (int CurrentButtonState, int &WasAlreadyPressed, int &ToBeToggled)
{
	if (CurrentButtonState && !WasAlreadyPressed)
	{
		ToBeToggled = !ToBeToggled;			//If Old Drive, switch to New Drive. If New Drive, switch to Old Drive
	}
	WasAlreadyPressed = CurrentButtonState;
}

void RangeCheck (int LowerLimit, int &Value, int UpperLimit)
{
	if (Value > UpperLimit)
	{
		Value = UpperLimit;
	}
	if (Value < LowerLimit)
	{
		Value = LowerLimit;
	}
}

//--------------------------------------------< Drive-train Code >-----------------------------------------------\\

int operatorDriveTrain()
{
	int joystickDriveMax = 127;			 				//Maximum distance of drive stick from center
	int motorDriveMax = 127;							//Maximum power we want our motors to go
	float JoystickAngleSin;			 					//Sine of the Drive Stick
	float JoystickAngleCos;								//Cosine of the Drive Stick

	ToggleCheck(btnHoloStraight, btnHoloStraightPressed, (int) HolonomicMode);
	ToggleCheck(btnOldNewDrive, btnOldNewDrivePressed, bOldNewDrive);
	ToggleCheck(btnFrontBackDrive, btnFrontBackDrivePressed, bFrontBackDrive);

	if(HolonomicMode == STRAIGHT)
	{
	}
	else
	{
		if (!bOldNewDrive)
		{
			joystickDrivePower = sqrt((stkDriveX*stkDriveX)+(stkDriveY*stkDriveY));	// Calculate Joystick Hypotenuse
			JoystickAngleSin = stkDriveY/joystickDriveMax;							// Calculate Joystick Sin
			JoystickAngleCos = stkDriveX/joystickDriveMax;							// Calculate Joystick Cosin
			motorLeftDriveTrain = (JoystickAngleSin + JoystickAngleCos) * joystickDrivePower;
			motorRightDriveTrain = (JoystickAngleSin - JoystickAngleCos) * joystickDrivePower;

			if(joystickDrivePower > joystickDriveDeadzone)	//If the Joystick has been pushed far enough
			{
				RangeCheck(0-motorDriveMax, motorLeftDriveTrain, motorDriveMax);
				RangeCheck(0-motorDriveMax, motorRightDriveTrain, motorDriveMax);
			    /*motorLeftDriveTrain = (motorLeftDriveTrain > motorDriveMax) ? motorDriveMax : motorLeftDriveTrain;
				motorRightDriveTrain = (motorRightDriveTrain > motorDriveMax) ? motorDriveMax : motorRightDriveTrain;
				motorLeftDriveTrain = (motorLeftDriveTrain < (0-motorDriveMax)) ? (0-motorDriveMax) : motorLeftDriveTrain;
				motorRightDriveTrain = (motorRightDriveTrain < (0-motorDriveMax)) ? (0-motorDriveMax) : motorRightDriveTrain;*/
			}
			else
			{
				motorLeftDriveTrain = 0;
				motorRightDriveTrain = 0;
			}
		}
		/*else //Old Drive
		{
			joystickDrivePower = sqrt((stkDriveX*stkDriveX)+(stkDriveY*stkDriveY));
			motorLeftDriveTrain = stkDriveY + stkDriveX;
			motorRightDriveTrain = stkDriveY - stkDriveX;

			if(joystickDrivePower > joystickDriveDeadzone)	//If the Joystick has been pushed far enough
			{
				motorLeftDriveTrain = (motorLeftDriveTrain > motorDriveMax) ? motorDriveMax : motorLeftDriveTrain;
				motorRightDriveTrain = (motorRightDriveTrain > motorDriveMax) ? motorDriveMax : motorRightDriveTrain;
				motorLeftDriveTrain = (motorLeftDriveTrain < (0-motorDriveMax)) ? (0-motorDriveMax) : motorLeftDriveTrain;
				motorRightDriveTrain = (motorRightDriveTrain < (0-motorDriveMax)) ? (0-motorDriveMax) : motorRightDriveTrain;
			}
			else
			{
				motorLeftDriveTrain = 0;
				motorRightDriveTrain = 0;
			}
		}*/ //*********Commented because we ran out of space on the brain!
	}
	//return errorcode;
	return 0;
}

int operatorLift()
{
	PIDLift.Error = SensorValue[LeftLiftEncoderPort] - SensorValue[RightLiftEncoderPort];
	PIDLift.TargetValue = stkLift;
	/*if (PIDLift.TargetValue < 20 && PIDLift.TargetValue > -20)
	{
		PIDLift.TargetValue = 20;
	}*/
	motorLiftLeft = PIDLift.TargetValue + PIDLift.Output;
	motorLiftRight = PIDLift.TargetValue - PIDLift.Output;
	//motorLift = stkLift;
	return 0;
}

//------------------------------------Intake Code-------------------------------------//

int operatorIntake()
{
  /*if(joystickDrivePower < joystickDriveDeadzone)
  {
    //Dispense
    if(btnIntakeUp == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeDown == 1)
    {
      motorIntakeFront = -127;
      motorIntakeBack = -127;
    }
    else
    {
      motorIntakeFront = 0;
      motorIntakeBack = 0;
    }
  }
  else
  {
    if(stkDriveY > 0)
    {
      //intake while driving forward
      if(btnIntakeUp == 1 || btnIntakeDown == 1)
      {
        motorIntakeFront = 127;
        motorIntakeBack = 0;
      }
      else
      {
        motorIntakeFront = 0;
        motorIntakeBack = 0;
      }
    }
    else
    {
      //intake while driving backward
      if(btnIntakeUp == 1 || btnIntakeDown == 1)
      {
        motorIntakeFront = 127;
        motorIntakeBack = 0;
      }
      else
      {
        motorIntakeFront = 0;
        motorIntakeBack = 0;
      }
    }
  }*/
  	if(btnIntakeIn1 == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeOut1 == 1)
    {
      motorIntakeFront = -127;
      motorIntakeBack = -127;
    }
    else if(btnIntakeIn2 == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeOut2 == 1)
    {
      motorIntakeFront = -127;
      motorIntakeBack = -127;
    }
    else
    {
      motorIntakeFront = 0;
      motorIntakeBack = 0;
    }
  return 1;
}

int doOutput()
{
	//output code here
	int errorcode = 0;
	if(bFrontBackDrive)
	{
		motor[DriveRF] = 0 - motorLeftDriveTrain;
		motor[DriveRB] = 0 - motorLeftDriveTrain;
		motor[DriveLF] = 0 - motorRightDriveTrain;
		motor[DriveLB] = 0 - motorRightDriveTrain;
		motor[IntakeLF] = 0 - motorIntakeFront;
		motor[IntakeRF] = 0 - motorIntakeFront;
		motor[IntakeLB] = 0 - motorIntakeBack;
		motor[IntakeRB] = 0 - motorIntakeBack;
	}
	else
	{
		motor[DriveLF] = motorLeftDriveTrain;
		motor[DriveLB] = motorLeftDriveTrain;
		motor[DriveRF] = motorRightDriveTrain;
		motor[DriveRB] = motorRightDriveTrain;
		motor[IntakeLF] = motorIntakeFront;
		motor[IntakeRF] = motorIntakeFront;
		motor[IntakeLB] = motorIntakeBack;
		motor[IntakeRB] = motorIntakeBack;
	}
	motor[LiftL] = motorLiftLeft;
	motor[LiftR] = motorLiftRight;

	return errorcode;
}
