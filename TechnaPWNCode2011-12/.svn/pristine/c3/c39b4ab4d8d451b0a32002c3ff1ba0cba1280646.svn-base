#pragma config(UART_Usage, UART2, VEX_2x16_LCD, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro,                sensorGyro)
#pragma config(Sensor, dgtl1,  RightLiftEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LeftLiftEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  LeftDriveEncoderPort, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, BottomLeftLiftLimitSwitchPort, sensorTouch)
#pragma config(Sensor, dgtl11, BottomRightLiftLimitSwitchPort, sensorTouch)
#pragma config(Sensor, dgtl12, AutonomousJumperPort, sensorDigitalIn)
#pragma config(Motor,  port1,           DriveBL,       tmotorNormal, openLoop)
#pragma config(Motor,  port2,           IntakeL,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           LiftBR,        tmotorNormal, openLoop)
#pragma config(Motor,  port4,           LiftFL,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port5,           DriveFR,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           DriveFL,       tmotorNormal, openLoop)
#pragma config(Motor,  port7,           LiftBL,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port8,           LiftFR,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port9,           IntakeR,       tmotorNormal, openLoop)
#pragma config(Motor,  port10,          DriveBR,       tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#define _SIMULATED		// SIMULATOR SWITCH - FOR COMPETITION THIS SHOULD BE COMMENTED OUT!

//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//
// Code creatively composed by Josiah Krutz and Ryan Plummer. Addition support provided by:
// http://robotc.net/forums/viewtopic.php?f=52&t=1280
// Josh Duff


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#ifdef _SIMULATED
	#include "Vex_Techna_PWN_Debug_Includes.c"			//Debug code - enable
#else
	#include "Vex_Competition_Includes.c"			    	//Main competition background code...do not modify!
#endif

//Constants
#define LIFTENCODERCONSTANT 1
#define DRIVEENCODERCONSTANT 1
#define FLOORHEIGHT 10
#define LOWGOALHEIGHT 100
#define MIDDLEGOALHEIGHT 200
#define HIGHGOALHEIGHT 300
#define JOYSTICKDRIVEMAX 127
#define MOTORDRIVEMAX 127
#define JOYSTICKDEADZONE 20
#define IN 127
#define OUT -127
#define UP 127
#define DOWN -127
#define FORWARD 127
#define BACKWARD -127
#define STOP 128

//Enums
typedef enum
{
	STRAIGHT,
	LEFTONEWHEELTURN,
	RIGHTONEWHEELTURN,
	BOTHWHEELTURN
} TAutoDriveType;

typedef enum
{
	PLAIN,
	EXPERIMENT
} TDriveAlgorithm;

typedef enum
{
	NORMAL,
	REVERSED
} TRobotDirection;

typedef enum
{
	NOGOALBUTTON,
	LOWGOALBUTTON,
	MIDDLEGOALBUTTON,
	HIGHGOALBUTTON
} TGoalHeightButton;

typedef enum
{
  ANALOG1 = -1,
  NOCONDITION = 0,
  ANALOG2 = 1,
  ANALOG3 = 2,
  ANALOG4 = 3,
  ANALOG5 = 4,
  ANALOG6 = 5,
  ANALOG7 = 6,
  ANALOG8 = 7,
  DIGITAL1 = 8,
  DIGITAL2 = 9,
  DIGITAL3 = 10,
  DIGITAL4 = 11,
  DIGITAL5 = 12,
  DIGITAL6 = 13,
  DIGITAL7 = 14,
  DIGITAL8 = 15,
  DIGITAL9 = 16,
  DIGITAL10 = 17,
  DIGITAL11 = 18,
  DIGITAL12 = 19,
  LEFTDISPLAYBUTTON = 20,
  CENTERDISPLAYBUTTON = 21,
  RIGHTDISPLAYBUTTON = 22,
  ANYDISPLAYBUTTON = 23
} TJumpCondition;

//---------------------------------------------< Structs >-----------------------------------------------\\

typedef struct
{
	float Kp;
	float Ki;
	float Kd;
	float Integral;
	float Derivative;
	float Error;
	float LastError;
	float TargetValue;
	float TargetPower;
	float Output;
} TPidSystem;

typedef struct
{
	string StepName;
	//Outputs
	int LiftPower;
	//int LiftHeight;
	int IntakePower;
	TAutoDriveType DriveType;
	int DrivePower;
	//Trip values
	int Timeout;
	int GyroDegrees;
	int EncoderTicks;
	//Functions
	TJumpCondition JumpCondition;
	int JumpToStep;
} TAutonomous;


//-------------------------------------< Global Variable Declarations >-----------------------------------------\\
// btn = Button (Input), stk = Stick (Input), pneu = Pneumatics (Output), motor = Motor (Output)

//Inputs
float stkDriveX;									//Current X value of drive stick (-127 to 127)
float stkDriveY;							 		//Current Y value of drive stick (-127 to 127)
float stkDriveS;
int stkLift;								  		//Lift Joystick Channel
int stkLift1;
int stkLift2;
int btnOldNewDrive;								//Old/New-Drive Joystick Button
int btnFrontBackDrive;
int gyrGyroscope;
int btnIntakeIn1;
int btnIntakeOut1;
int btnIntakeIn2;
int btnIntakeOut2;
int btnLiftEncoderReset1;
int btnLiftEncoderReset2;
int btnLiftLowGoal1;
int btnLiftMiddleGoal1;
int btnLiftHighGoal1;
int btnLiftLowGoal2;
int btnLiftMiddleGoal2;
int btnLiftHighGoal2;
float MainBatteryVoltageAverage;
float MainBatteryVoltageLevel;
int ButtonBitMap;
int LeftDisplayButton;
int CenterDisplayButton;
int RightDisplayButton;
int LeftLiftEncoder;
int RightLiftEncoder;
int LeftDriveEncoder;
int RightDriveEncoder;
int BottomLeftLiftLimitSwitch;
int BottomRightLiftLimitSwitch;

//Outputs
int motorLeftDriveTrain;							//Value assigned to motors on the left of the robot
int motorRightDriveTrain;							//Value assigned to motors on the right of the robot
int motorLeftFrontDrive;
int motorLeftBackDrive;
int motorRightFrontDrive;
int motorRightBackDrive;
int motorLiftLeft;									//Value assigned to left lift motors
int motorLiftRight;									//Value assigned to right lift motors
int motorIntakeFront;								//gets put into the font of the intake mechanism
int motorIntakeBack;								//Gets put into the beack of the intake mechanism

//Stuff that needs to remembered
int btnOldNewDrivePressed;							//Old/New-Drive Joystick Button Pressed Variable
TDriveAlgorithm OldNewDrive = PLAIN;
int btnFrontBackDrivePressed;
TRobotDirection FrontBackDrive = NORMAL;
int btnLiftLowGoal1Pressed;
int btnLiftMiddleGoal1Pressed;
int btnLiftHighGoal1Pressed;
int btnLiftLowGoal2Pressed;
int btnLiftMiddleGoal2Pressed;
int btnLiftHighGoal2Pressed;
TGoalHeightButton LastGoalHeightButton1;
TGoalHeightButton LastGoalHeightButton2;
int LiftTargetHeight;
int LiftToPresetHeight;
int LeftDisplayButtonPressed;
int CenterDisplayButtonPressed;
int RightDisplayButtonPressed;
int ActivateMenuItem = 0;
int DisplayNeedsRefreshing = 1;
int CurrentMenu = 0;
int CurrentMenuItem = 0;
int TotalMenuItems;
//int MenuStack[64];
string MainMenu[7] = {"Run Autonomous", "Pick Autonomous", "Motor Test", "Show Variables", "Edit Autonomous", "Make Autonomous", "Show Errors"};
string AutonomousMenu[3] = {"LoadScoreReturn", "ObjectScorer", "No Autonomous"};
TPidSystem PIDLift;
TAutonomous AutonomousLoadScoreReturn[11];
TAutonomous AutonomousObjectScorer[10];
TAutonomous CurrentStep;
int ReadyForNextAutonomousStep = 1;
int AutonomousStep = 0;
int AutonomousRoutine = 0;
int LockInAutonomous = 0;
int EnableOutput = 1;

//----------------------------------------< Function Declarations >----------------------------------------------\\
//void pre_auton();
//task autonomous()
//task usercontrol();
void initializeTimers();
int initializeDisplay();
int initializePID();
int initializeGyro();
int initializeAutonomous();
int getInput();
int processAutonomous();
int processOperator();
int operatorDriveTrain();
int operatorLift();
int operatorIntake();
int UpdatePIDControllers();
int PickAutonomous();
int Display();
void DisplayMainMenu();
void DisplayMenu(string MenuTitle, string MenuItem);
void DisplayButtonHandling();
int IsMenuItemActivated();
int CheckJoystick();
void ToggleCheck (int CurrentButtonState, int &WasAlreadyPressed, int &ToBeToggled);
void RangeCheck (int LowerLimit, int &Value, int UpperLimit);
void PIDController(TPidSystem &PIDObject);
void MotorTest();
int doOutput();

void pre_auton()
{
	initializeTimers();
	initializeDisplay();
	initializePID();
	//initializeGyro(); 							//Uncomment when we start using Gyro Sensor
	initializeAutonomous();
#ifdef _SIMULATED
	while (bSimulatedRobotDisabled)
#else
	while (bIfiRobotDisabled)						//Keep letting Autonomous be selected while robot is disabled
#endif
  {
    getInput();
		if (!LockInAutonomous)
		{
		  PickAutonomous();
		}
  }
	AutonomousRoutine = CurrentMenuItem;
	CurrentMenuItem = 0;
	CurrentMenu = 0;
	DisplayNeedsRefreshing = 1;
}

//----------------------------------------------< Autonomous >-----------------------------------------------\\

task autonomous()
{
	AutonomousStep = 0;
	while (true)
	{
		getInput();
		processAutonomous();
		doOutput();
	}
	/*motor[LiftBL] = 90;
	motor[LiftBR] = 90;
	wait1Msec(4000);
	motor[LiftBL] = 0;
	motor[LiftBR] = 0;*/

}

//-------------------------------------------< Operator Control >--------------------------------------------\\
task usercontrol()
{
#ifdef _SIMULATED
	while (!bSimulatedAutonomousMode)
#else
	while (!bIfiAutonomousMode)
#endif
	{
		getInput();
		processOperator();
		if (EnableOutput)
			doOutput();
	}

}
//---------------------------------------------< Initialize >---------------------------------------------------\\
void initializeTimers()
{
	ClearTimer(T1);
	ClearTimer(T2);
}

int initializeDisplay()
{
	//clearLCDLine(0);
    //clearLCDLine(1);
    bLCDBacklight = true;							//Turn Backlight on
	displayLCDPos(1, 0);							//Move "Cursor" to first spot
	displayNextLCDString("Ready to PWN :-D");		//Display motivational message
	return 0;
}

int initializePID()
{
	PIDLift.Kp = 1.5; //.75
	PIDLift.Ki = 0;
	PIDLift.Kd = 0.0; //0.5;
	PIDLift.Integral = 0;
	PIDLift.Derivative = 0;
	PIDLift.Error = 0;
	PIDLift.LastError = 0;
	PIDLift.TargetValue = 0;
	PIDLift.TargetPower = 0;
	PIDLift.Output = 0;
	return 1;
}

int initializeGyro()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in1] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
	return 0;
}

int initializeAutonomous()
{
	// *** LoadScoreReturn ***
	AutonomousLoadScoreReturn[0].StepName = "Raise Lift";
	AutonomousLoadScoreReturn[0].LiftPower = UP;		//Lift Up
	AutonomousLoadScoreReturn[0].Timeout = 2000;

	//Repeat starting here
	AutonomousLoadScoreReturn[1].StepName = "DriveToGoal+Lift";
	AutonomousLoadScoreReturn[1].DriveType = STRAIGHT;	//Drive toward Goal and Lift
	AutonomousLoadScoreReturn[1].DrivePower = FORWARD;
	//AutonomousLoadScoreReturn[1].			//Add encoder stuff here
	AutonomousLoadScoreReturn[1].Timeout = 1700;

	AutonomousLoadScoreReturn[2].StepName = "WaitForStableBot";
	AutonomousLoadScoreReturn[2].LiftPower = 20;		//Stop the lift, and stablalize robot.
	AutonomousLoadScoreReturn[2].Timeout = 250;

	AutonomousLoadScoreReturn[3].StepName = "Release Elements";
	AutonomousLoadScoreReturn[3].IntakePower = OUT;	//Release the Barrels!
	AutonomousLoadScoreReturn[3].Timeout = 3000;

	AutonomousLoadScoreReturn[4].StepName = "StopIntake+Pause";
	AutonomousLoadScoreReturn[4].IntakePower = STOP;
	AutonomousLoadScoreReturn[4].Timeout = 250; //250
	AutonomousLoadScoreReturn[4].JumpCondition = dgtl12;
	AutonomousLoadScoreReturn[4].JumpToStep = 6;

	AutonomousLoadScoreReturn[5].StepName = "Blue (Turn Left)";
	AutonomousLoadScoreReturn[5].DriveType = LEFTONEWHEELTURN;
	AutonomousLoadScoreReturn[5].DrivePower = BACKWARD;
	AutonomousLoadScoreReturn[5].Timeout = 250; //250
	AutonomousLoadScoreReturn[5].JumpToStep = 7;

	AutonomousLoadScoreReturn[6].StepName = "Red (Turn Right)";
	AutonomousLoadScoreReturn[6].DriveType = RIGHTONEWHEELTURN;
	AutonomousLoadScoreReturn[6].DrivePower = BACKWARD;
	AutonomousLoadScoreReturn[6].Timeout = 250; //250

	AutonomousLoadScoreReturn[7].StepName = "BackToStartTile";
	AutonomousLoadScoreReturn[7].DriveType = STRAIGHT;	//Drive toward Goal and Lift
	AutonomousLoadScoreReturn[7].DrivePower = BACKWARD;
	AutonomousLoadScoreReturn[7].Timeout = 1800;

	AutonomousLoadScoreReturn[8].StepName = "HitABtnToGoAgain";
	AutonomousLoadScoreReturn[8].JumpCondition = ANYDISPLAYBUTTON;
	AutonomousLoadScoreReturn[8].JumpToStep = 1;
	AutonomousLoadScoreReturn[8].Timeout = 0;

	AutonomousLoadScoreReturn[9].StepName = "HitABtnToGoAgain";
	AutonomousLoadScoreReturn[9].JumpToStep = 8;
	AutonomousLoadScoreReturn[9].Timeout = 0;

	AutonomousLoadScoreReturn[10].StepName = "Finished!";
	AutonomousLoadScoreReturn[10].Timeout = -1;

	// *** ObjectScorer ***
	AutonomousObjectScorer[0].StepName = "HeightRaise Lift";
	AutonomousObjectScorer[0].LiftPower = UP;		//Lift Up
	AutonomousObjectScorer[0].Timeout = 1100;

	//Repeat starting here
	AutonomousObjectScorer[1].StepName = "DriveToGoal+Lift";
	AutonomousObjectScorer[1].DriveType = STRAIGHT;	//Drive toward Goal and Lift
	AutonomousObjectScorer[1].DrivePower = FORWARD;
	//AutonomousLoadScoreReturn[1].			//Add encoder stuff here
	AutonomousObjectScorer[1].Timeout = 1700;

	AutonomousObjectScorer[2].StepName = "WaitForStableBot";
	AutonomousObjectScorer[2].LiftPower = 20;		//Stop the lift, and stablalize robot.
	AutonomousObjectScorer[2].Timeout = 250;

	AutonomousObjectScorer[3].StepName = "Finished!";
	AutonomousObjectScorer[3].Timeout = -1;

	return 0;
}
//----------------------------------------------------< Get Input >---------------------------------------------\\

int getInput()
{
	//input code here
	//Joystick Inputs
	int ErrorCode = 0;
	stkDriveX = vexRT[Ch4];							//Turn Left and Right Drive Joystick Channel
	stkDriveY = vexRT[Ch3];							//Up and Down Drive Joystick Channel
	stkDriveS = vexRT[Ch1];							//Strafe Left and Right Drive Joystick Channel
	stkLift1 = vexRT[Ch2];				    	//Lift Joystick Channel
	stkLift2 = vexRT[Ch2Xmtr2];					//Lift Joystick Channel
	//btnOldNewDrive = vexRT[Btn8D];    //Uncomment to try new drive systems
	btnFrontBackDrive = vexRT[Btn8U];
	gyrGyroscope = SensorValue[Gyro];
	btnIntakeIn1 = vexRT[Btn6U];
	btnIntakeOut1 = vexRT[Btn6D];
	btnIntakeIn2 = vexRT[Btn6UXmtr2];
	btnIntakeOut2 = vexRT[Btn6DXmtr2];
	btnLiftEncoderReset1 = vexRT[Btn5U];
	btnLiftEncoderReset2 = vexRT[Btn5UXmtr2];
	btnLiftLowGoal1 = vexRT[Btn8L];
  btnLiftMiddleGoal1 = vexRT[Btn8D];
  btnLiftHighGoal1 = vexRT[Btn8R];
  btnLiftLowGoal2  = vexRT[Btn8LXmtr2];
  btnLiftMiddleGoal2 = vexRT[Btn8DXmtr2];
  btnLiftHighGoal2 = vexRT[Btn8RXmtr2];
	//Digital Inputs
	LeftLiftEncoder = SensorValue[LeftLiftEncoderPort] * LIFTENCODERCONSTANT;
	RightLiftEncoder = SensorValue[RightLiftEncoderPort] * LIFTENCODERCONSTANT;
	LeftDriveEncoder = SensorValue[LeftDriveEncoderPort] * DRIVEENCODERCONSTANT;
	RightDriveEncoder = SensorValue[RightDriveEncoderPort] * DRIVEENCODERCONSTANT;
	BottomLeftLiftLimitSwitch = SensorValue[BottomLeftLiftLimitSwitchPort];
	BottomRightLiftLimitSwitch = SensorValue[BottomRightLiftLimitSwitchPort];
	MainBatteryVoltageAverage = nAvgBatteryLevel;
	MainBatteryVoltageLevel = nImmediateBatteryLevel;
	ButtonBitMap = nLCDButtons;
	LeftDisplayButton = (ButtonBitMap & 1) && 1;
	CenterDisplayButton = (ButtonBitMap & 2) && 1;
	RightDisplayButton = (ButtonBitMap & 4) && 1;
	return ErrorCode;
}

//-------------------------------------------< Processes >--------------------------------------------\\
int processAutonomous()
{
	int ErrorCode = 0;
	int StartGyro = 0;
	int WillJump = 0;

	if (ReadyForNextAutonomousStep)
	{
		if (AutonomousRoutine == 0)			//LoadScoreReturn
		{
			//CurrentStep = AutonomousLoadScoreReturn[AutonomousStep]; //This doesn't work in ROBOTC
			memcpy(CurrentStep, AutonomousLoadScoreReturn[AutonomousStep], sizeof(CurrentStep)); //This does
		}
		else if (AutonomousRoutine == 1)	//ObjectScorer
		{
			memcpy(CurrentStep, AutonomousObjectScorer[AutonomousStep], sizeof(CurrentStep)); //This does
		}
		else								//No Autonomous
		{
			CurrentStep.Timeout = -1;
			CurrentStep.StepName = "Preparing to PWN";
		}
		displayLCDNumber(0, 14, AutonomousStep, 1); //Debug line; implement in future
	  displayLCDString(1, 0, "                ");
	  displayLCDString(1, 0, CurrentStep.StepName);

		if (CurrentStep.LiftPower != 0 && CurrentStep.LiftPower >= -127 && CurrentStep.LiftPower <= 127)
		{
			motorLiftLeft = motorLiftRight = CurrentStep.LiftPower;
		}
		else if (CurrentStep.LiftPower == 128)
		{
			motorLiftLeft = motorLiftRight = 0;
		}
		if (CurrentStep.IntakePower  != 0 && CurrentStep.IntakePower >= -127 && CurrentStep.IntakePower <= 127)
		{
			motorIntakeBack = motorIntakeFront = CurrentStep.IntakePower;
		}
		else if (CurrentStep.IntakePower == 128)
		{
			motorIntakeBack = motorIntakeFront = 0;
		}
		if (CurrentStep.DriveType == STRAIGHT)
		{
			motorLeftFrontDrive = CurrentStep.DrivePower;
			motorLeftBackDrive = CurrentStep.DrivePower;
			motorRightFrontDrive = CurrentStep.DrivePower;
			motorRightBackDrive = CurrentStep.DrivePower;
		}
		else if (CurrentStep.DriveType == LEFTONEWHEELTURN)
		{
			motorLeftFrontDrive = 0;
			motorLeftBackDrive = 0;
			motorRightFrontDrive = CurrentStep.DrivePower;
			motorRightBackDrive = CurrentStep.DrivePower;

		}
		else if (CurrentStep.DriveType == RIGHTONEWHEELTURN)
		{
			motorLeftFrontDrive = CurrentStep.DrivePower;
			motorLeftBackDrive = CurrentStep.DrivePower;
			motorRightFrontDrive = 0;
			motorRightBackDrive = 0;
		}
		else if (CurrentStep.DriveType == BOTHWHEELTURN)
		{
			motorLeftFrontDrive = CurrentStep.DrivePower;
			motorLeftBackDrive = CurrentStep.DrivePower;
			motorRightFrontDrive = 0 - CurrentStep.DrivePower;
			motorRightBackDrive = 0 - CurrentStep.DrivePower;
		}
		ReadyForNextAutonomousStep = 0;
		ClearTimer(T2);
		StartGyro = gyrGyroscope;
	}
	if (CurrentStep.Timeout != -1)			//If the trip statement isn't met
	{
		if (CurrentStep.Timeout != 0 && ((time1[T2]) >= CurrentStep.Timeout))
			ReadyForNextAutonomousStep = 1;
		if (CurrentStep.GyroDegrees != 0 && (gyrGyroscope - StartGyro >= CurrentStep.GyroDegrees))
			ReadyForNextAutonomousStep = 1;
		if (CurrentStep.EncoderTicks != 0 && (RightDriveEncoder >= CurrentStep.EncoderTicks))
			ReadyForNextAutonomousStep = 1;
	  if (CurrentStep.Timeout == 0)
	    ReadyForNextAutonomousStep = 1;
  }
  else
	{
		motorLiftLeft = motorLiftRight = 0;
		motorIntakeBack = motorIntakeFront = 0;
		motorLeftFrontDrive = 0;
		motorLeftBackDrive = 0;
		motorRightFrontDrive = 0;
		motorRightBackDrive = 0;
	}
	if (CheckJoystick())
	{
		StartTask(usercontrol);
		StopTask(autonomous);
	}

	if (ReadyForNextAutonomousStep)
  {
    if (CurrentStep.JumpToStep != 0)
    {
      if (CurrentStep.JumpCondition == 0)
        WillJump = 1;
      else if ((CurrentStep.JumpCondition >= 8) && CurrentStep.JumpCondition <= 19)
      {
        if (SensorValue[CurrentStep.JumpCondition])
          WillJump = 1;
      }
      else if(CurrentStep.JumpCondition == LEFTDISPLAYBUTTON && LeftDisplayButton)
        WillJump = 1;
      else if(CurrentStep.JumpCondition == CENTERDISPLAYBUTTON && CenterDisplayButton)
        WillJump = 1;
      else if(CurrentStep.JumpCondition == RIGHTDISPLAYBUTTON && RightDisplayButton)
        WillJump = 1;
      else if((CurrentStep.JumpCondition == ANYDISPLAYBUTTON) && (LeftDisplayButton || CenterDisplayButton || RightDisplayButton))
	    {
	      writeDebugStreamLine("Hi");
	      WillJump = 1;
	    }
	  }

	  if (WillJump)
	  {

      if (CurrentStep.JumpToStep == -1)
		  	AutonomousStep = 0;
		  else
		    AutonomousStep = CurrentStep.JumpToStep;
		}
		else
		{
			AutonomousStep++;
	  }
	}
	return ErrorCode;
}

int processOperator()
{
	//Driver control code here
	int ErrorCode = 0;
	operatorDriveTrain();
	operatorLift();
	operatorIntake();
	Display();
	UpdatePIDControllers();
	return ErrorCode;
}


//--------------------------------------------< Drive-train Code >-----------------------------------------------\\

int operatorDriveTrain()
{
  int ErrorCode;

	//ToggleCheck(btnOldNewDrive, btnOldNewDrivePressed, (int) OldNewDrive);
	ToggleCheck(btnFrontBackDrive, btnFrontBackDrivePressed, (int) FrontBackDrive);

	if (OldNewDrive == PLAIN)
	{
	  if(!(abs(stkDriveX) > JOYSTICKDEADZONE))
	  {
	    stkDriveX = 0;
	  }
	  if(!(abs(stkDriveY) > JOYSTICKDEADZONE))
	  {
	    stkDriveY = 0;
	  }
	  if(!(abs(stkDriveS) > JOYSTICKDEADZONE * 2))
	  {
	    stkDriveS = 0;
	  }
	  /*if((abs(stkDriveY) > JOYSTICKDEADZONE) || (abs(stkDriveX) > JOYSTICKDEADZONE) || (abs(stkDriveS) > JOYSTICKDEADZONE))	//If the Joystick hasn't been pushed far enough
		{*/
			motorLeftFrontDrive = stkDriveY + stkDriveX + stkDriveS;
			motorLeftBackDrive =  stkDriveY + stkDriveX - stkDriveS;
			motorRightFrontDrive = stkDriveY - stkDriveX - stkDriveS;
			motorRightBackDrive =  stkDriveY - stkDriveX + stkDriveS;
		/*}*/
		/*else
		{
			motorLeftFrontDrive = 0;
			motorLeftBackDrive = 0;
			motorRightFrontDrive = 0;
			motorRightBackDrive = 0;
		}*/
	}
	else
	{
		if((abs(stkDriveY) > JOYSTICKDEADZONE) || (abs(stkDriveX) > JOYSTICKDEADZONE))	//If the Joystick has been pushed far enough
		{
		  motorLeftFrontDrive = stkDriveY + stkDriveX;
		  motorLeftBackDrive = stkDriveY + stkDriveX;
		  motorRightFrontDrive = stkDriveY - stkDriveX;
		  motorRightBackDrive = stkDriveY - stkDriveX;
		}
		else
		{
			motorLeftFrontDrive = 0;
			motorLeftBackDrive = 0;
			motorRightFrontDrive = 0;
			motorRightBackDrive = 0;
		}
	}
	RangeCheck(0-MOTORDRIVEMAX, motorLeftFrontDrive, MOTORDRIVEMAX);
	RangeCheck(0-MOTORDRIVEMAX, motorLeftBackDrive, MOTORDRIVEMAX);
	RangeCheck(0-MOTORDRIVEMAX, motorRightFrontDrive, MOTORDRIVEMAX);
	RangeCheck(0-MOTORDRIVEMAX, motorRightBackDrive, MOTORDRIVEMAX);

	return ErrorCode;
}

//------------------------------------Lift Code-------------------------------------//

int operatorLift()
{
  int ErrorCode = 0;
	/*//Direct Lift
	if (btnLiftRestBack1 && btnLiftRestFront1)
	{
		stkLift = 0;
	}
	else if (btnLiftRestBack2 && btnLiftRestFront2)
	{
		stkLift = 0;
	}
	else if (abs(stkLift1) > JOYSTICKDEADZONE)
	{
		stkLift = stkLift1;
	}
	else if (abs(stkLift2) > JOYSTICKDEADZONE)
	{
		stkLift = stkLift2;
	}
	else if (BottomLiftLimitSwitch)
	{
		stkLift = 0;
	}
	else
	{
		stkLift = 10;
	}

	motorLiftLeft = stkLift;
	motorLiftRight = stkLift;*/

	//PID Lift

	//Main Joystick Low Goal Button
	if (btnLiftLowGoal1 && !btnLiftLowGoal1Pressed)
	{
	  if (LastGoalHeightButton1 == LOWGOALBUTTON)
	  {
  	  LastGoalHeightButton1 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
      LastGoalHeightButton1 = LOWGOALBUTTON;
  	  LiftTargetHeight = LOWGOALHEIGHT;
  	}
	  LiftToPresetHeight = 1;
	}
	btnLiftLowGoal1Pressed = btnLiftLowGoal1;

	//Main Joystick Middle Goal Button
	if (btnLiftMiddleGoal1 && !btnLiftMiddleGoal1Pressed)
	{
	  if (LastGoalHeightButton1 == MIDDLEGOALBUTTON)
	  {
  	  LastGoalHeightButton1 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
      LastGoalHeightButton1 = MIDDLEGOALBUTTON;
  	  LiftTargetHeight = MIDDLEGOALHEIGHT;
  	}
	  LiftToPresetHeight = 1;
	}
	btnLiftMiddleGoal1Pressed = btnLiftMiddleGoal1;

	//Main Joystick High Goal Button
	if (btnLiftHighGoal1 && !btnLiftHighGoal1Pressed)
	{
	  if (LastGoalHeightButton1 == HIGHGOALBUTTON)
	  {
  	  LastGoalHeightButton1 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
  	  LastGoalHeightButton1 = HIGHGOALBUTTON;
  	  LiftTargetHeight = HIGHGOALHEIGHT;
  	}
	  LiftToPresetHeight = 1;
	}
	btnLiftHighGoal1Pressed = btnLiftHighGoal1;


	//Second Joystick Low Goal Button
	if (btnLiftLowGoal2 && !btnLiftLowGoal2Pressed)
	{
	  if (LastGoalHeightButton2 == LOWGOALBUTTON)
	  {
  	  LastGoalHeightButton2 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
      LastGoalHeightButton2 = LOWGOALBUTTON;
  	  LiftTargetHeight = LOWGOALHEIGHT;
  	}
	  LiftToPresetHeight = 2;
	}
	btnLiftLowGoal2Pressed = btnLiftLowGoal2;

	//Second Joystick Middle Goal Button
	if (btnLiftMiddleGoal2 && !btnLiftMiddleGoal2Pressed)
	{
	  if (LastGoalHeightButton2 == MIDDLEGOALBUTTON)
	  {
  	  LastGoalHeightButton2 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
      LastGoalHeightButton2 = MIDDLEGOALBUTTON;
  	  LiftTargetHeight = MIDDLEGOALHEIGHT;
  	}
	  LiftToPresetHeight = 2;
	}
	btnLiftMiddleGoal2Pressed = btnLiftMiddleGoal2;

	//Second Joystick High Goal Button
	if (btnLiftHighGoal2 && !btnLiftHighGoal2Pressed)
	{
	  if (LastGoalHeightButton2 == HIGHGOALBUTTON)
	  {
  	  LastGoalHeightButton2 = NOGOALBUTTON;
  	  LiftTargetHeight = FLOORHEIGHT;
  	}
	  else
	  {
  	  LastGoalHeightButton2 = HIGHGOALBUTTON;
  	  LiftTargetHeight = HIGHGOALHEIGHT;
  	}
	  LiftToPresetHeight = 2;
	}
	btnLiftHighGoal2Pressed = btnLiftHighGoal2;

	/*else if (btnLiftMiddleGoal1 && !btnLiftMiddleGoal1Pressed)
	  LiftTargetHeight = MIDDLEGOALHEIGHT;
	else if (btnLiftHighGoal1 && !btnLiftHighGoal1Pressed)
	  LiftTargetHeight = HIGHGOALHEIGHT;
	else if (btnLiftLowGoal2 && !btnLiftLowGoal2Pressed)
	  LiftTargetHeight = LOWGOALHEIGHT;
	else if (btnLiftMiddleGoal2 && !btnLiftMiddleGoal2Pressed)
	  LiftTargetHeight = MIDDLEGOALHEIGHT;
	else if (btnLiftHighGoal2 && !btnLiftHighGoal2Pressed)
	  LiftTargetHeight = HIGHGOALHEIGHT;*/


	PIDLift.Error = RightLiftEncoder - LeftLiftEncoder;

	if (btnLiftEncoderReset1 || btnLiftEncoderReset2)
	{
		SensorValue[LeftLiftEncoderPort] = 0;
		SensorValue[RightLiftEncoderPort] = 0;
	}

	if (abs(stkLift1) > JOYSTICKDEADZONE)
	{
		PIDLift.TargetPower = stkLift1;
	}
	else if (abs(stkLift2) > JOYSTICKDEADZONE)
	{
		PIDLift.TargetPower = stkLift2;
	}
	else if (BottomLeftLiftLimitSwitch && BottomRightLiftLimitSwitch)
	{
	  PIDLift.TargetPower = 0;
		SensorValue[LeftLiftEncoderPort] = 0;
		SensorValue[RightLiftEncoderPort] = 0;
	}
	else			//Joysticks are Centered, the encoder reset buttons and the bottom lift switches are not pressed
	{
		PIDLift.TargetPower = 0;
	}

	//motorLiftLeft = PIDLift.TargetPower + PIDLift.Output;
	//motorLiftRight = PIDLift.TargetPower - PIDLift.Output;
	motorLiftLeft = PIDLift.TargetPower;
	motorLiftRight = PIDLift.TargetPower;
	/*if ((PIDLift.TargetPower + PIDLift.Output) < 0)   //If Left Lift is going down, slow it down
	{
		motorLiftLeft = (PIDLift.TargetPower + PIDLift.Output)*.5;  //.75
	}
	if ((PIDLift.TargetPower - PIDLift.Output) < 0)   //If Right Lift is going down, slow it down
	{
		motorLiftRight = (PIDLift.TargetPower + PIDLift.Output)*.5;  //.75
	}*/

	return ErrorCode;
}

//------------------------------------Intake Code-------------------------------------//

int operatorIntake()
{
  int ErrorCode = 0;
  	if(btnIntakeIn1 == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeOut1 == 1)
    {
	    motorIntakeFront = -127;
      motorIntakeBack = -127;
   }
    else if(btnIntakeIn2 == 1)
    {
      motorIntakeFront = 127;
      motorIntakeBack = 127;
    }
    else if(btnIntakeOut2 == 1)
    {
      motorIntakeFront = -127;
      motorIntakeBack = -127;
    }
    else
    {
      motorIntakeFront = 0;
      motorIntakeBack = 0;
    }
  return ErrorCode;
}

int UpdatePIDControllers()
{
	PIDController(PIDLift);
	return 1;
}

int PickAutonomous()
{
  LockInAutonomous = 0;
	TotalMenuItems = 3;
		if (DisplayNeedsRefreshing)
		{
			DisplayMenu("Pick Autonomous", AutonomousMenu[CurrentMenuItem]);
			DisplayNeedsRefreshing = 0;
		}
		DisplayButtonHandling();
		if (IsMenuItemActivated())
		{
			AutonomousRoutine = CurrentMenuItem;
			CurrentMenuItem = 0;
			CurrentMenu = 0;
			LockInAutonomous = 1;
		}
	return 0;
}

int Display()
{
	switch(CurrentMenu)
	{
		case 1:   //Start Autonomous
			CurrentMenu = 0;
			StartTask(autonomous);
			StopTask(usercontrol);
			break;
		case 2:   //Pick Autonomous
		  CurrentMenuItem = AutonomousRoutine;
		  allMotorsOff();
		  do
		  {
		    getInput();
			  PickAutonomous();
			} while (!LockInAutonomous);
			while(nLCDButtons);
			break;
		case 3:
			//StopTask(usercontrol);
			//EnableOutput = 0;
			allMotorsOff();
			MotorTest();
			//EnableOutput = 1;
			CurrentMenu = 0;
			break;
		default:
			DisplayMainMenu();
			break;
	}
	return 0;
}

void DisplayMainMenu()
{
	TotalMenuItems = 7;
	if (DisplayNeedsRefreshing)
	{
		DisplayMenu("Main Menu", MainMenu[CurrentMenuItem]);
		DisplayNeedsRefreshing = 0;
	}
	DisplayButtonHandling();
	if (IsMenuItemActivated())
	{
		CurrentMenu = CurrentMenuItem + 1;
	}
}

void DisplayMenu(string MenuTitle, string MenuItem)
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, MenuTitle);
	displayLCDCenteredString(1, MenuItem);
}

void DisplayButtonHandling()
{
	if (LeftDisplayButton && !LeftDisplayButtonPressed && CurrentMenuItem > 0)
	{
		CurrentMenuItem--;
		DisplayNeedsRefreshing = 1;
	}
	LeftDisplayButtonPressed = LeftDisplayButton;
	if (RightDisplayButton && !RightDisplayButtonPressed && CurrentMenuItem < TotalMenuItems - 1)
	{
		CurrentMenuItem++;
		DisplayNeedsRefreshing = 1;
	}
	RightDisplayButtonPressed = RightDisplayButton;
	if (CenterDisplayButton && !CenterDisplayButtonPressed)
	{
		ActivateMenuItem = 1;
		DisplayNeedsRefreshing = 1;
	}
	CenterDisplayButtonPressed = CenterDisplayButton;
}

int IsMenuItemActivated() //This function makes sure that the activate action happens only when it is supposed to
{
	int Dummy = ActivateMenuItem;
	ActivateMenuItem = 0;
	return Dummy;
}

int CheckJoystick()
{
	//Are the joystick tests
	if (abs(vexRT[Ch1]) > JOYSTICKDEADZONE || abs(vexRT[Ch2]) > JOYSTICKDEADZONE || abs(vexRT[Ch3]) > JOYSTICKDEADZONE || abs(vexRT[Ch4]) > JOYSTICKDEADZONE)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void ToggleCheck (int CurrentButtonState, int &WasAlreadyPressed, int &ToBeToggled)
{
	if (CurrentButtonState && !WasAlreadyPressed)
	{
		ToBeToggled = !ToBeToggled;			//If Old Drive, switch to New Drive. If New Drive, switch to Old Drive
	}
	WasAlreadyPressed = CurrentButtonState;
}

void RangeCheck (int LowerLimit, int &Value, int UpperLimit)
{
	if (Value > UpperLimit)
	{
		Value = UpperLimit;
	}
	if (Value < LowerLimit)
	{
		Value = LowerLimit;
	}
}

void PIDController(TPidSystem &PIDObject)
{
	PIDObject.Integral = ((3 / 4) * PIDObject.Integral) + PIDObject.Error;
	PIDObject.Derivative = PIDObject.Error - PIDObject.LastError;
	PIDObject.Output = (PIDObject.Error * PIDObject.Kp) + (PIDObject.Integral * PIDObject.Ki) + (PIDObject.Derivative * PIDObject.Kd);
	PIDObject.LastError = PIDObject.Error;
}

void MotorTest()
{
	int i;
	displayLCDString(0, 0, "Motor Test      ");
	displayLCDString(1, 0, "MTR:   PWR:     ");
	for(i = 1; i <= 10; i++)
	{
		displayLCDString(1, 4, "   ");
		displayLCDNumber(1, 5, i, 0);
		displayLCDNumber(1, 12, 127);
		motor[i - 1] = 127;
		wait1Msec(750);
		displayLCDString(1, 12, "    ");
		displayLCDNumber(1, 12, 0, 0);
		motor[i - 1] = 0;
		wait1Msec(250);
		displayLCDString(1, 12, "    ");
		displayLCDNumber(1, 12, -127, 0);
		motor[i - 1] = -127;
		wait1Msec(750);
		displayLCDString(1, 12, "    ");
		displayLCDNumber(1, 12, 0, 0);
		motor[i - 1] = 0;
		wait1Msec(250);
	}
}
int doOutput()
{
	//output code here
	int ErrorCode = 0;
	if (FrontBackDrive == NORMAL)
	{
		motor[DriveFL] = motorLeftFrontDrive;
		motor[DriveBL] = motorLeftBackDrive;
		motor[DriveFR] = motorRightFrontDrive;
		motor[DriveBR] = motorRightBackDrive;

		motor[IntakeL] = motorIntakeFront;
		motor[IntakeR] = motorIntakeFront;
	}
	else
	{
		motor[DriveBR] = 0 - motorLeftFrontDrive;
		motor[DriveFR] = 0 - motorLeftBackDrive;
		motor[DriveBL] = 0 - motorRightFrontDrive;
		motor[DriveFL] = 0 - motorRightBackDrive;

		motor[IntakeL] = 0 - motorIntakeFront;
		motor[IntakeR] = 0 - motorIntakeBack;

	}
	motor[LiftFL] = motorLiftLeft;
	motor[LiftBL] = motorLiftLeft;
	motor[LiftFR] = motorLiftRight;
	motor[LiftBR] = motorLiftRight;

	return ErrorCode;
}
