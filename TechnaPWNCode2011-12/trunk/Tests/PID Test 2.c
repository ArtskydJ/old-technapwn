#pragma config(UART_Usage, UART2, VEX_2x16_LCD, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro,                sensorGyro)
#pragma config(Sensor, dgtl11, LiftEncoderPort,     sensorQuadEncoder)
#pragma config(Motor,  port1,           DriveBL,       tmotorNormal, openLoop)
#pragma config(Motor,  port2,           IntakeL,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           LiftBR,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           LiftBL,        tmotorNormal, openLoop)
#pragma config(Motor,  port5,           DriveFR,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port6,           DriveFL,       tmotorNormal, openLoop)
#pragma config(Motor,  port7,           LiftFL,        tmotorNormal, openLoop)
#pragma config(Motor,  port8,           LiftFR,        tmotorNormal, openLoop)
#pragma config(Motor,  port9,           IntakeR,       tmotorNormal, openLoop)
#pragma config(Motor,  port10,          DriveBR,       tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int MotorFrontLeft;
int MotorBackLeft;
int MotorFrontRight;
int MotorBackRight;

task main()
{
	float Kp = .5;
	float Ki = 0;
	float Kd = 0; //0.5;
	float Integral;
	float Sum;
	float Derivative;
	float Error;
	float LastError;
	float TargetValue;
	float Tp = 0;
	float Output;
	int LiftEncoder;
	SensorValue[LiftEncoderPort] = 0;
	while (true)
	{
		if (vexRT[Btn5D])
		{
			SensorValue[LiftEncoderPort] = 0;
		}

		TargetValue = (vexRT[Ch3]+130)*2;
		LiftEncoder = SensorValue[liftEncoderPort];
		Error = TargetValue - LiftEncoder;
		Integral = (Sum + LastError + Error)/2;
		Sum = (Sum + LastError + Error);
		Derivative = Error - LastError;
	Output = Kp * Error + Ki * Integral + Kd * Derivative;
		LastError = Error;
		MotorFrontLeft = Output;
		MotorBackLeft = Output;
		MotorFrontRight = Output;
		MotorBackRight = Output;

		if (Output < 0)
		{
			MotorFrontLeft = Output * 0.5;  //.75
			MotorBackLeft = Output * 0.5;   //.75
		}
		if (Output < 0)
		{
			MotorFrontRight = Output * 0.5; //.75
			MotorBackRight = Output * 0.5;  //.75
		}


		motor[LiftFL] = MotorFrontLeft;
		motor[LiftBL] = MotorBackLeft;
		motor[LiftFR] = MotorFrontRight;
		motor[LiftBR] = MotorBackRight;

		/*motor[LiftFR] = Tp;
		motor[LiftFL] = Tp;
		motor[LiftBR] = Tp;
		motor[LiftBL] = Tp;*/
		wait1Msec(70);
	}
}
